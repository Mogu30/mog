<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<parameter name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive Wall with Lightmaps</title>

<style>
  body { margin: 0; overflow: hidden; background: #000; }
  #canvas-container { 
    width: 100%; 
    height: 100%; 
  }
  #back-btn {
    position: absolute;
    top: 40px;
    left: 40px;
    z-index: 10;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(12px);
    padding: 15px 40px;
    color: white;
    text-transform: uppercase;
    letter-spacing: 2px;
    cursor: pointer;
    font-family: 'Segoe UI', sans-serif;
    transition: all 0.3s ease;
    pointer-events: auto;
  }
  #back-btn:hover { background: rgba(255, 255, 255, 0.1); }

  /* Loading overlay - HIDDEN, keep homepage visible */
  #loading {
    position: fixed;
    inset: 0;
    background: #000;
    display: none; /* Hidden - we'll use opacity transition instead */
    justify-content: center;
    align-items: center;
    flex-direction: column;
    color: #4CAF50;
    font-family: monospace;
    z-index: 100;
    opacity: 0;
    pointer-events: none;
  }
  #loading-progress { margin-top: 10px; font-size: 14px; }

  /* ‚îÄ‚îÄ INFO MODAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  #info-modal {
    position: fixed;
    inset: 0;
    z-index: 50;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    opacity: 0;
  }
  #info-modal.visible {
    pointer-events: auto;
  }

  /* dark backdrop */
  #info-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
  }

  #info-card {
    position: relative;
    width: min(680px, 92vw);
    background: rgba(255,255,255,0.07);
    backdrop-filter: blur(28px) saturate(160%);
    -webkit-backdrop-filter: blur(28px) saturate(160%);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 24px;
    overflow: hidden;
    color: #fff;
    font-family: 'Segoe UI', sans-serif;
    box-shadow: 0 32px 80px rgba(0,0,0,0.6), 0 0 0 1px rgba(255,255,255,0.05) inset;
  }

  /* card enter */
  @keyframes cardIn {
    0%   { opacity: 0; transform: translateY(52px) scale(0.92) rotateX(8deg); filter: blur(8px); }
    60%  { filter: blur(0px); }
    100% { opacity: 1; transform: translateY(0)    scale(1)    rotateX(0deg); }
  }
  /* card exit */
  @keyframes cardOut {
    0%   { opacity: 1; transform: translateY(0)    scale(1);    filter: blur(0px); }
    100% { opacity: 0; transform: translateY(28px) scale(0.95); filter: blur(6px); }
  }
  /* backdrop enter */
  @keyframes backdropIn  { from { opacity: 0; } to { opacity: 1; } }
  @keyframes backdropOut { from { opacity: 1; } to { opacity: 0; } }

  /* text stagger */
  @keyframes textIn {
    from { opacity: 0; transform: translateY(14px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  #info-card.animating-in {
    animation: cardIn 0.55s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }
  #info-card.animating-out {
    animation: cardOut 0.28s cubic-bezier(0.4, 0, 1, 1) forwards;
  }
  #info-backdrop.animating-in  { animation: backdropIn  0.35s ease forwards; }
  #info-backdrop.animating-out { animation: backdropOut 0.28s ease forwards; }

  /* stagger tag ‚Üí title ‚Üí desc on open */
  #info-card.animating-in #info-tag  { animation: textIn 0.4s 0.18s ease both; }
  #info-card.animating-in #info-title{ animation: textIn 0.4s 0.26s ease both; }
  #info-card.animating-in #info-desc { animation: textIn 0.4s 0.34s ease both; }
  /* image slides up */
  #info-card.animating-in #info-img-wrap {
    animation: textIn 0.5s 0.05s cubic-bezier(0.16,1,0.3,1) both;
  }

  #info-img-wrap {
    width: 100%;
    height: 280px;
    overflow: hidden;
    background: rgba(255,255,255,0.04);
    position: relative;
  }
  #info-img-wrap img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    opacity: 0.85;
  }
  #info-img-wrap .img-placeholder {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 88px;
    background: linear-gradient(135deg, rgba(60,80,120,0.6), rgba(20,20,40,0.8));
  }

  #info-body { padding: 32px 40px 40px; }
  #info-tag {
    font-size: 10px;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: rgba(120,180,255,0.8);
    margin-bottom: 10px;
  }
  #info-title {
    font-size: 32px;
    font-weight: 700;
    letter-spacing: 0.5px;
    margin: 0 0 14px;
    line-height: 1.2;
  }
  #info-desc {
    font-size: 15px;
    line-height: 1.75;
    color: rgba(255,255,255,0.72);
    margin: 0;
  }

  /* glowing top border */
  #info-card::before {
    content: '';
    position: absolute;
    top: 0; left: 10%; right: 10%;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(100,160,255,0.8), transparent);
  }

  #info-close {
    position: absolute;
    top: 14px; right: 16px;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 50%;
    width: 32px; height: 32px;
    color: #fff;
    font-size: 16px;
    cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: background 0.2s, transform 0.2s;
    z-index: 2;
  }
  #info-close:hover { background: rgba(255,255,255,0.22); transform: scale(1.1) rotate(90deg); }

</style>

<!-- GSAP for animations -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.167.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.167.0/examples/jsm/",
    "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
    "postprocessing": "https://unpkg.com/postprocessing@6.36.3/build/index.js"
  }
}
</script>
</head>
<body>

<div id="canvas-container"></div>
<button id="back-btn">‚Üê BACK</button>

<!-- INFO MODAL -->
<div id="info-modal">
  <div id="info-backdrop"></div>
  <div id="info-card">
    <button id="info-close">‚úï</button>
    <div id="info-img-wrap">
      <div class="img-placeholder" id="info-emoji">üé∏</div>
    </div>
    <div id="info-body">
      <div id="info-tag">OBJECT</div>
      <h2 id="info-title">Title</h2>
      <p id="info-desc">Description goes here.</p>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';

// üåü POST-PROCESSING IMPORTS
import { EffectComposer, RenderPass } from 'postprocessing';

// Configuration
const WALL_CONFIG = {
  cols: 16,
  rows: 9,
  cubeSize: 3,
  gap: 0.001,
  centerY: 13.5
};
const GLB_PATH = 'assets/scene.glb';
const CAM_FOV = 23;

// ============================================
// LIGHTMAP CONFIGURATION - DISABLED
// ============================================
const LIGHTMAP_CONFIG = {
  enabled: false  // Lightmaps disabled - using lights from GLB instead
};

// üé® POST-PROCESSING SETTINGS - ALL DISABLED
const POST_FX_CONFIG = {
  enabled: false,
  bloom: {
    enabled: false,
    strength: 0.4,
    radius: 0.5,
    threshold: 0.85
  },
  ssao: {
    enabled: false,
    kernelRadius: 8,
    minDistance: 0.005,
    maxDistance: 0.1,
    intensity: 1.0
  },
  godRays: {
    enabled: false,
    density: 0.96,
    weight: 0.3,
    decay: 0.95,
    exposure: 0.3,
    samples: 60
  },
  volumetricLight: {
    enabled: false,
    intensity: 2.0,
    color: 0xfff4e6,
    opacity: 0.3
  },
  fxaa: {
    enabled: false
  },
  vignette: {
    enabled: false,
    darkness: 0.5,
    offset: 1.0
  }
};

// Globals
let scene, camera, renderer, world;
let physicsObjects = [];
let raycaster, mouse;
let dragConstraint = null;
let dragBody = null;
let isDragging = false;
let dragPlane = new THREE.Plane();
let initialCameraPos = null;
let sceneMeshes = [];
let loadedLightmaps = {}; // Store loaded lightmap textures

// üåü POST-PROCESSING GLOBALS
let composer, godRaysPass;
let godRaysLight;
let volumetricLights = []; // Array of volumetric light beam meshes
let blockerPlane = null;

// ‚ú® HOVER GLOW
const GLOW_TARGET_NAMES = ['monitro', 'globe', 'chair', 'arch', 'guitar'];

// ‚ú® PARTICLES
let particleSystem = null;
const glowTargetMeshes = []; // ONLY the ~5 target meshes ‚Äî tiny raycast list
const glowShells = new Map();
let currentHovered = null;
let glowNeedsUpdate = false;
const _localY = new THREE.Vector3(0, 1, 0); // cached ‚Äî reused every frame for globe spin

// üìã INFO PANEL DATA ‚Äî swap in real content whenever you're ready
const INFO_DATA = {
  guitar: {
    tag:   'INSTRUMENT',
    title: 'The Guitar',
    desc:  'A placeholder description for the guitar. Talk about its story, origin, or whatever makes it special in your world.',
    emoji: 'üé∏',
    img:   null, // set to 'path/to/image.jpg' to use a real image
  },
  globe: {
    tag:   'ARTIFACT',
    title: 'The Globe',
    desc:  'A placeholder description for the globe. Maybe it shows an ancient map, or a world that no longer exists.',
    emoji: 'üåç',
    img:   null,
  },
  chair: {
    tag:   'FURNITURE',
    title: 'The Chair',
    desc:  'A placeholder description for the chair. Every great room has one seat that means something.',
    emoji: 'ü™ë',
    img:   null,
  },
  monitro: {
    tag:   'TECHNOLOGY',
    title: 'The Monitor',
    desc:  'A placeholder description for the monitor. A window into something ‚Äî or someone.',
    emoji: 'üñ•Ô∏è',
    img:   null,
  },
  arch: {
    tag:   'ARCHITECTURE',
    title: 'The Arch',
    desc:  'A placeholder description for the arch. A threshold between what is and what could be.',
    emoji: 'üèõÔ∏è',
    img:   null,
  },
};

// Modal DOM refs
const infoModal    = document.getElementById('info-modal');
const infoCard     = document.getElementById('info-card');
const infoBackdrop = document.getElementById('info-backdrop');
const infoImgWrap  = document.getElementById('info-img-wrap');
const infoTag      = document.getElementById('info-tag');
const infoTitle    = document.getElementById('info-title');
const infoDesc     = document.getElementById('info-desc');
function openInfoPanel(baseKey) {
  const data = INFO_DATA[baseKey];
  if (!data) return;

  infoTag.textContent   = data.tag;
  infoTitle.textContent = data.title;
  infoDesc.textContent  = data.desc;

  infoImgWrap.innerHTML = '';
  if (data.img) {
    const img = document.createElement('img');
    img.src = data.img;
    img.alt = data.title;
    infoImgWrap.appendChild(img);
  } else {
    const ph = document.createElement('div');
    ph.className = 'img-placeholder';
    ph.textContent = data.emoji;
    infoImgWrap.appendChild(ph);
  }

  // Reset any leftover exit classes
  infoCard.classList.remove('animating-out');
  infoBackdrop.classList.remove('animating-out');

  infoModal.style.opacity = '1';
  infoModal.style.pointerEvents = 'auto';
  infoModal.classList.add('visible');

  // Trigger enter animations
  infoCard.classList.add('animating-in');
  infoBackdrop.classList.add('animating-in');
}

function closeInfoPanel() {
  // Swap to exit animation classes
  infoCard.classList.remove('animating-in');
  infoBackdrop.classList.remove('animating-in');
  infoCard.classList.add('animating-out');
  infoBackdrop.classList.add('animating-out');

  setTimeout(() => {
    infoModal.classList.remove('visible');
    infoModal.style.pointerEvents = 'none';
    infoModal.style.opacity = '0';
    infoCard.classList.remove('animating-out');
    infoBackdrop.classList.remove('animating-out');
  }, 300);
}

// Close on backdrop or X button
document.getElementById('info-backdrop').addEventListener('click', closeInfoPanel);
document.getElementById('info-close').addEventListener('click', closeInfoPanel);
document.addEventListener('keydown', e => { if (e.key === 'Escape') closeInfoPanel(); });

// üé≠ HOVER ANIMATIONS ‚Äî all state lives here, animate() reads it each frame
const hoverAnims = {
  guitar: {
    active: false,
    meshes: [],
    floatOffset: 0,   // current float height (GSAP tweens this)
    tiltDir: 1,       // left/right alternator
  },
  globe: {
    active: false,
    meshes: [],
  },
  chair: {
    active: false,
    meshes: [],
  },
  arch: {
    active: false,
    sorted: [],       // arch meshes sorted arch ‚Üí arch_7
    restYs: [],       // original Y per arch mesh
    hopIndex: 0,      // which arch is currently hopping
    hopTimer: 0,      // countdown to next hop (ms)
    hopOffset: [],    // current Y lift per arch mesh (GSAP tweens these)
  },
};

init();

async function init() {
  // 1. Setup Physics World
  world = new CANNON.World();
  world.gravity.set(0, -9.82, 0);
  world.broadphase = new CANNON.NaiveBroadphase();
  world.solver.iterations = 20;

  // Materials - BRICK-LIKE PHYSICS
  const wallMaterial = new CANNON.Material('wall');
  const ballMaterial = new CANNON.Material('ball');
  const wallBallContact = new CANNON.ContactMaterial(wallMaterial, ballMaterial, {
    friction: 0.6,      // Was 0.1, now 0.6 (more friction, less sliding)
    restitution: 0.2    // Was 0.5, now 0.2 (less bouncy, more thud)
  });
  world.addContactMaterial(wallBallContact);

  // 2. Setup Three.js Scene
  scene = new THREE.Scene();
  scene.background = null; // Transparent - homepage shows through

  // Camera
  camera = new THREE.PerspectiveCamera(CAM_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 15, 68); // Updated camera position
  camera.lookAt(0, WALL_CONFIG.centerY, 0);

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha = transparent
  renderer.setClearColor(0x000000, 0); // Fully transparent background
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.NeutralToneMapping;
  renderer.toneMappingExposure = 1;
  renderer.useLegacyLights = false;
  document.getElementById('canvas-container').appendChild(renderer.domElement);

  // Add WebGL context loss/restore handlers
  renderer.domElement.addEventListener('webglcontextlost', (event) => {
    event.preventDefault();
    console.error('‚ö†Ô∏è WebGL context lost! Stopping animation...');
  }, false);

  renderer.domElement.addEventListener('webglcontextrestored', () => {
    console.log('‚úÖ WebGL context restored!');
  }, false);

  // Initialize RectAreaLight
  RectAreaLightUniformsLib.init();

  // Add Ambient Light for general scene illumination
  const ambientLight = new THREE.AmbientLight(0xffffff, 5); // Low ‚Äî shadows already baked into textures
  scene.add(ambientLight);

  // üíô Blue directional light
  const blueLight = new THREE.DirectionalLight(0x191970, 0.5);
  blueLight.position.set(70, 30, -100);
  blueLight.target.position.set(0, WALL_CONFIG.centerY, 0);
  blueLight.castShadow = true;
  blueLight.shadow.mapSize.width  = 2048;
  blueLight.shadow.mapSize.height = 2048;
  blueLight.shadow.camera.near   = 0.5;
  blueLight.shadow.camera.far    = 300;
  blueLight.shadow.camera.left   = -50;
  blueLight.shadow.camera.right  =  50;
  blueLight.shadow.camera.top    =  50;
  blueLight.shadow.camera.bottom = -50;
  blueLight.shadow.bias          = -0.001;
  scene.add(blueLight);
  scene.add(blueLight.target);
  console.log('‚úÖ Ambient light added (intensity: 5.0)');

  // 4. Environment (HDRI) - ENABLED
  await loadHDRI();

  // 5. Create Environment
  createFloor(wallMaterial);
  
  await createWall(wallMaterial);
  
  await loadGLB();
  
  // Capture initial camera position for parallax
  initialCameraPos = camera.position.clone();

  // 7. Interaction
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  window.addEventListener('mousedown', onMouseDown);
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);
  window.addEventListener('resize', onWindowResize);
  
  document.getElementById('back-btn').addEventListener('click', async () => {
    document.getElementById('back-btn').style.pointerEvents = 'none';
    await resetWall(); // Reset the wall pieces
    window.parent.postMessage('wallBackClicked', '*');
  });

  // üåü Setup God Rays
  await setupGodRaysSystem();

  // ‚ú® Particles
  createParticles();

  // Scene is ready - just notify parent (no fade, scene is already visible)
  window.parent.postMessage('sceneReady', '*');

  // 8. Start Loop
  animate();
}

function applyLightmapToMesh(mesh, lightmapKey) {
  if (!LIGHTMAP_CONFIG.enabled) return;
  
  const lightmap = loadedLightmaps[lightmapKey];
  if (!lightmap) {
    console.warn(`‚ö†Ô∏è No lightmap found for key: ${lightmapKey}`);
    return;
  }
  
  // Check if mesh has UV2 (lightmap UVs)
  if (!mesh.geometry.attributes.uv2) {
    console.warn(`‚ö†Ô∏è Mesh "${mesh.name}" has no UV2 attribute for lightmaps. Copying UV1...`);
    // Fallback: copy UV1 to UV2 if not present
    mesh.geometry.setAttribute('uv2', mesh.geometry.attributes.uv.clone());
  }
  
  // Apply lightmap to material
  if (mesh.material) {
    mesh.material.lightMap = lightmap;
    mesh.material.lightMapIntensity = 1.0;
    mesh.material.needsUpdate = true;
    
    console.log(`üîÜ Applied lightmap "${lightmapKey}" to "${mesh.name}"`);
  }
}

// ============================================
// SCENE SETUP (existing functions)
// ============================================

function loadHDRI() {
  const hdriLoader = new RGBELoader();
  hdriLoader.load('assets/studio.hdr', (texture) => {
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = texture;
    scene.userData.envMap = texture;
    console.log('‚úÖ HDRI Loaded');
  }, undefined, (err) => {
    console.log('‚ÑπÔ∏è No HDRI file - using GLB lights only');
  });
}

async function resetWall() {
  // STOP physics simulation during animation
  const wasAnimating = true;
  
  // Animate wall pieces back to original positions
  const animations = [];
  
  for (const obj of physicsObjects) {
    // Disable physics body during animation
    obj.body.mass = 0;
    obj.body.updateMassProperties();
    obj.body.velocity.set(0, 0, 0);
    obj.body.angularVelocity.set(0, 0, 0);
    
    // Animate the visual mesh smoothly
    const anim = gsap.to(obj.mesh.position, {
      x: obj.initialPos.x,
      y: obj.initialPos.y,
      z: obj.initialPos.z,
      duration: 1.5,
      ease: 'power2.inOut',
      onUpdate: function() {
        // Sync physics body to animated mesh position
        obj.body.position.set(
          obj.mesh.position.x,
          obj.mesh.position.y,
          obj.mesh.position.z
        );
      }
    });
    animations.push(anim);
    
    // Also animate rotation
    gsap.to(obj.mesh.quaternion, {
      x: obj.initialQuat.x,
      y: obj.initialQuat.y,
      z: obj.initialQuat.z,
      w: obj.initialQuat.w,
      duration: 1.5,
      ease: 'power2.inOut',
      onUpdate: function() {
        obj.body.quaternion.set(
          obj.mesh.quaternion.x,
          obj.mesh.quaternion.y,
          obj.mesh.quaternion.z,
          obj.mesh.quaternion.w
        );
      }
    });
  }
  
  // Wait for animations to complete
  await Promise.all(animations.map(a => a.then()));
  
  // Re-enable physics
  for (const obj of physicsObjects) {
    obj.body.mass = 25; // Match the brick mass
    obj.body.updateMassProperties();
    obj.body.position.copy(obj.initialPos);
    obj.body.quaternion.copy(obj.initialQuat);
    obj.body.velocity.set(0, 0, 0);
    obj.body.angularVelocity.set(0, 0, 0);
  }

  // Re-enable the back button for next time
  document.getElementById('back-btn').style.pointerEvents = 'auto';
}

function createFloor(material) {
  const floorShape = new CANNON.Plane();
  const floorBody = new CANNON.Body({ mass: 0, material: material });
  floorBody.addShape(floorShape);
  floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
  floorBody.position.set(0, 0, 0);
  world.addBody(floorBody);

  const geo = new THREE.PlaneGeometry(200, 200);
  const mat = new THREE.ShadowMaterial({ opacity: 0.3 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = -Math.PI / 2;
  mesh.receiveShadow = true;
  scene.add(mesh);
}

async function createWall(material) {
  const { cols, rows, cubeSize, gap, centerY } = WALL_CONFIG;
  const wallWidth = cols * (cubeSize + gap) - gap;
  const wallHeight = rows * (cubeSize + gap) - gap;
  
  const startX = -(wallWidth / 2) + (cubeSize / 2);
  const startY = centerY - (wallHeight / 2) + (cubeSize / 2);

  const baseGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
  const baseEdgesGeo = new THREE.EdgesGeometry(baseGeo);
  const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });

  const shape = new CANNON.Box(new CANNON.Vec3(cubeSize/2, cubeSize/2, cubeSize/2));

  // Load Texture
  const textureLoader = new THREE.TextureLoader();
  const masterTexture = await new Promise(resolve => textureLoader.load('mog.png', resolve));
  masterTexture.colorSpace = THREE.SRGBColorSpace;
  masterTexture.wrapS = THREE.ClampToEdgeWrapping;
  masterTexture.wrapT = THREE.ClampToEdgeWrapping;

  const wallVisualMaterial = new THREE.MeshStandardMaterial({ 
    map: masterTexture, 
    bumpMap: masterTexture,
    bumpScale: 0.2,
    roughness: 0.7, 
    metalness: 0.1,
    envMapIntensity: 0.1
  });

  // Back Barrier
  const barrierShape = new CANNON.Plane();
  const barrierBody = new CANNON.Body({ mass: 0 });
  barrierBody.addShape(barrierShape);
  barrierBody.position.set(0, 0, -cubeSize/2 - 0.05);
  world.addBody(barrierBody);

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const x = startX + c * (cubeSize + gap);
      const y = startY + r * (cubeSize + gap);
      
      // Physics - BRICK-LIKE: Heavy mass, less bouncy
      const body = new CANNON.Body({ mass: 500, material: material }); // Was 5, now 25 (5x heavier!)
      body.addShape(shape);
      body.position.set(x, y, 0);
      body.linearDamping = 0;  // Was 0.1, now 0.4 (slows down faster)
      body.angularDamping = 0; // Was 0.1, now 0.3 (less spinning)
      world.addBody(body);

      // Visual
      const meshGeometry = baseGeo.clone();
      const uvs = meshGeometry.attributes.uv;
      for (let i = 0; i < uvs.count; i++) {
        const u = uvs.getX(i);
        const v = uvs.getY(i);
        uvs.setXY(i, (u + c) / cols, (v + r) / rows);
      }

      const mesh = new THREE.Mesh(meshGeometry, wallVisualMaterial);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.name = `wall_cube_${r}_${c}`;
      scene.add(mesh);

      // Edges
      const edges = new THREE.LineSegments(baseEdgesGeo, edgesMaterial);
      mesh.add(edges);

      physicsObjects.push({ 
        mesh, 
        body,
        initialPos: new CANNON.Vec3().copy(body.position),
        initialQuat: new CANNON.Quaternion().copy(body.quaternion)
      });
      
      // Apply lightmap if available
      applyLightmapToMesh(mesh, 'wall');
    }
  }
}

async function loadGLB() {
  const loader = new GLTFLoader();
  const textureLoader = new THREE.TextureLoader();

  // Load the baked textures as base textures for MeshBasicMaterial
  const bakedTextures = {};
  
  console.log('üé® Loading baked textures...');
  try {
    const texturePaths = {
      'animated': 'assets/textures/animated_Bake1_CyclesBake_COMBINED.png',
      'bg': 'assets/textures/BG_Bake1_CyclesBake_COMBINED.png',
      'decorations': 'assets/textures/DECORATIONS_Bake1_CyclesBake_COMBINED.png',
      'furniture': 'assets/textures/furnitrure_Bake1_CyclesBake_COMBINED.png', // fixed key spelling
      'walls': 'assets/textures/WALLS_Bake1_CyclesBake_COMBINED.png',
      'eye': 'assets/textures/eye_Bake1_CyclesBake_COMBINED.png',
    };
    
    for (const [key, path] of Object.entries(texturePaths)) {
      try {
        const texture = await new Promise((resolve, reject) => {
          textureLoader.load(path, resolve, undefined, reject);
        });
        // PNG textures are usually sRGB
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.flipY = false; // Standard for GLTF models
        texture.channel = 0;
        texture.needsUpdate = true;
        bakedTextures[key] = texture;
        console.log(`  ‚úÖ Loaded ${key} texture`);
      } catch (err) {
        console.log(`  ‚ö†Ô∏è Couldn't load ${key} texture - will use material color`);
      }
    }
  } catch (err) {
    console.log('  ‚ÑπÔ∏è No baked textures found - using GLB materials');
  }

  try {
    const gltf = await new Promise((resolve, reject) => {
      loader.load(
        GLB_PATH, 
        resolve, 
        undefined, 
        (error) => {
          console.error('GLB loading error:', error);
          reject(error);
        }
      );
    });
    const model = gltf.scene;
    
    // Debug: Log what we got from the GLB
    console.log('üì¶ GLB Info:');
    console.log('  - Scenes:', gltf.scenes?.length || 0);
    console.log('  - Meshes:', gltf.scene.children.length);
    console.log('  - Textures:', gltf.textures?.length || 0);
    console.log('  - Materials:', gltf.materials?.length || 0);
    
    model.traverse(child => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
        child.frustumCulled = false;
        
        // Use MeshBasicMaterial for baked textures (no lighting needed!)
        const meshName = child.name.toLowerCase();
        let bakedTexture = null;
        
        console.log(`üîç Checking mesh: "${child.name}" (lowercase: "${meshName}")`);
        
        // Define meshes that use the 'things' texture
        const thingsMeshes = [
          'arch', 'chair', 'globe', 'guitar', 'monitro', 'things'
        ];

        // Find matching baked texture (check specific keywords before generic ones)
        // We use a unified logic for all meshes to ensure consistent mapping
        if (meshName.includes('walls') && bakedTextures.walls) {
          bakedTexture = bakedTextures.walls;
          console.log(`  ‚úÖ Matched to WALLS texture`);
        } else if ((meshName.includes('furniture') || meshName.includes('furnitrure')) && bakedTextures.furniture) {
          bakedTexture = bakedTextures.furniture;
          console.log(`  ‚úÖ Matched to FURNITURE texture`);
        } else if ((meshName.includes('decoration') || meshName.includes('decorations')) && bakedTextures.decorations) {
          bakedTexture = bakedTextures.decorations;
          console.log(`  ‚úÖ Matched to DECORATIONS texture`);
        } else if (meshName.includes('animated') && bakedTextures.animated) {
          bakedTexture = bakedTextures.animated;
          console.log(`  ‚úÖ Matched to ANIMATED texture`);
        } else if (meshName.includes('bg') && bakedTextures.bg) {
          bakedTexture = bakedTextures.bg;
          console.log(`  ‚úÖ Matched to BG texture`);
        } else if (meshName.includes('eye') && bakedTextures.eye) {
          bakedTexture = bakedTextures.eye;
          console.log(`  ‚úÖ Matched to EYE texture`);
        } else if (["arch","chair","globe","guitar","monitro"].some(t => meshName === t || meshName.startsWith(t+"_")) && bakedTextures.animated) {
          bakedTexture = bakedTextures.animated;
          console.log(`  ‚úÖ Matched to ANIMATED texture (fallback for arch/chair/globe/guitar/monitro)`);
        } else if (thingsMeshes.some(t => meshName.includes(t)) && bakedTextures.things) {
          bakedTexture = bakedTextures.things;
          console.log(`  ‚úÖ Matched to THINGS texture`);
        } else {
          console.log(`  ‚ö†Ô∏è No texture match found`);
        }
        
        if (bakedTexture) {
          child.material = new THREE.MeshBasicMaterial({
            map: bakedTexture,
          });
          console.log(`üé® Applied baked texture to ${child.name}`);
        } else {
          // No baked texture - create default material
          if (!child.material) {
            child.material = new THREE.MeshBasicMaterial({
              color: 0xcccccc,
            });
          }
        }
        
        // DoubleSide breaks shadow casting in Three.js ‚Äî use FrontSide
        child.material.side = THREE.FrontSide;
        sceneMeshes.push(child);

        // ‚ú® If this is a glow target, add to the tiny raycast list
        const n = child.name.toLowerCase();
        if (GLOW_TARGET_NAMES.some(t => n === t || n.startsWith(t+'_') || n.startsWith(t+'.') || n.includes(t))) {
          glowTargetMeshes.push(child);
        }
        
        // Check for camera sphere
        if (meshName.includes('sphere')) {
          console.log('üìç Found camera sphere, updating camera...');
          const pos = new THREE.Vector3();
          child.getWorldPosition(pos);
          camera.position.copy(pos);
          camera.lookAt(0, WALL_CONFIG.centerY, 0);
          child.visible = false;
        }
      }
      
      // Handle Lights
      if (child.isLight) {
        console.log(`üí° Found GLB Light: ${child.name} (Type: ${child.type})`);
        child.castShadow = true;
        child.shadow.mapSize.width = 2048;
        child.shadow.mapSize.height = 2048;
        child.shadow.normalBias = 0.02;
        
        if (child.isSpotLight && child.target) {
          model.add(child.target);
        }
      }
    });
    
    model.position.set(0, 0, -1.9);
    scene.add(model);

    // ‚ú® GLOW COLORS ‚Äî one per object, change these freely
    const GLOW_COLORS = {
      guitar:  new THREE.Color(1.0,  0.35, 0.1 ),  // üî• orange
      globe:   new THREE.Color(0.1,  0.9,  0.4 ),  // üåç green
      chair:   new THREE.Color(0.8,  0.3,  1.0 ),  // üíú purple
      monitro: new THREE.Color(0.0,  1.0,  1.0 ),  // üñ•Ô∏è bright cyan
      arch:    new THREE.Color(1.0,  0.85, 0.2 ),  // üèõÔ∏è gold
    };
    // Lower power = glow spreads further from edges (good for flat meshes like the monitor)
    const GLOW_POWER = {
      monitro: 0.6,  // spreads across more of the flat screen surface
    };

    // ‚ú® Fresnel glow ‚Äî custom shader reads view angle per-pixel,
    //    bright at silhouette edges, fully transparent at center
    const fresnelMat = new THREE.ShaderMaterial({
      uniforms: {
        fresnelColor: { value: new THREE.Color(0.25, 0.55, 1.0) },
        fresnelPower: { value: 1.2 },
        fresnelStrength: { value: 2.5 },
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vViewDir;
        void main() {
          vec4 worldPos = modelMatrix * vec4(position, 1.0);
          vNormal   = normalize(normalMatrix * normal);
          vViewDir  = normalize(cameraPosition - worldPos.xyz);
          gl_Position = projectionMatrix * viewMatrix * worldPos;
        }
      `,
      fragmentShader: `
        uniform vec3  fresnelColor;
        uniform float fresnelPower;
        uniform float fresnelStrength;
        varying vec3  vNormal;
        varying vec3  vViewDir;
        void main() {
          float fresnel = 1.0 - clamp(dot(normalize(vNormal), normalize(vViewDir)), 0.0, 1.0);
          fresnel = pow(fresnel, fresnelPower) * fresnelStrength;
          gl_FragColor = vec4(fresnelColor * fresnel, fresnel);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      side: THREE.FrontSide,
      polygonOffset: true,
      polygonOffsetFactor: -1,
      polygonOffsetUnits: -1,
    });

    // Backface shell material for flat/thin meshes (monitor) ‚Äî works regardless of normals
    const backfaceMat = new THREE.MeshBasicMaterial({
      side: THREE.BackSide,
      transparent: true,
      opacity: 0.9,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });

    glowTargetMeshes.forEach(mesh => {
      const base = mesh.name.toLowerCase().split('_')[0].split('.')[0];
      let shell;

      if (base === 'monitro') {
        // Flat mesh ‚Äî use backface shell with a fixed world-space expansion
        const mat = backfaceMat.clone();
        mat.color = GLOW_COLORS['monitro'] || new THREE.Color(0.0, 1.0, 1.0);
        shell = new THREE.Mesh(mesh.geometry, mat);
        // Expand enough to be visible on a thin mesh
        shell.scale.setScalar(1.12);
      } else {
        // Normal 3D mesh ‚Äî use Fresnel
        const mat = fresnelMat.clone();
        if (GLOW_COLORS[base]) mat.uniforms.fresnelColor.value = GLOW_COLORS[base];
        if (GLOW_POWER[base])  mat.uniforms.fresnelPower.value  = GLOW_POWER[base];
        shell = new THREE.Mesh(mesh.geometry, mat);
      }

      shell.visible = false;
      shell.renderOrder = 999;
      mesh.add(shell);
      glowShells.set(mesh, shell);
    });
    console.log(`‚ú® Glow shells built for ${glowShells.size} meshes`);

    // üé≠ Populate hover animation mesh lists
    sceneMeshes.forEach(mesh => {
      const n = mesh.name.toLowerCase();
      if (n === 'guitar' || n.startsWith('guitar_') || n.startsWith('guitar.')) {
        hoverAnims.guitar.meshes.push(mesh);
      }
      if (n === 'globe' || n.startsWith('globe_') || n.startsWith('globe.')) {
        hoverAnims.globe.meshes.push(mesh);
      }
      if (n === 'chair' || n.startsWith('chair_') || n.startsWith('chair.')) {
        hoverAnims.chair.meshes.push(mesh);
      }
      if (n === 'arch' || n.startsWith('arch_') || n.startsWith('arch.')) {
        hoverAnims.arch.sorted.push(mesh);
      }
    });

    // Sort arch meshes: 'arch' first, then arch_1 ‚Üí arch_7 by number
    hoverAnims.arch.sorted.sort((a, b) => {
      const numA = parseInt(a.name.replace(/\D/g,'')) || 0;
      const numB = parseInt(b.name.replace(/\D/g,'')) || 0;
      return numA - numB;
    });

    // Store rest positions and init hop offsets
    hoverAnims.arch.sorted.forEach(m => {
      hoverAnims.arch.restYs.push(m.position.y);
      hoverAnims.arch.hopOffset.push(0);
    });

    // Store guitar rest Y
    if (hoverAnims.guitar.meshes.length > 0) {
      hoverAnims.guitar.meshes.forEach(m => m.userData.restY = m.position.y);
    }

    console.log('‚úÖ GLB Loaded successfully');

    // üëÅÔ∏è Eye animation ‚Äî all positions relative to origin (imported position)
    // Each pass: fixed start‚Üíend, alternating direction, different Y each time
    const eyeMesh = sceneMeshes.find(m => m.name.toLowerCase().includes('eye'));
    if (eyeMesh) {
      const ox = eyeMesh.position.x; // origin X
      const oy = eyeMesh.position.y; // origin Y
      const travel = 50;

      // Define passes: [fromX, fromY, toX, toY] ‚Äî all relative to origin
      const passes = [
        [ox,          oy,      ox - travel, oy     ],
        [ox - travel, oy - 10, ox,          oy - 10],
        [ox,          oy - 5,  ox - travel, oy - 5 ],
        [ox - travel, oy - 3,  ox,          oy - 3 ],
        [ox,          oy - 8,  ox - travel, oy - 8 ],
        [ox - travel, oy,      ox,          oy     ],
      ];
      let passIndex = 0;
      let bobTween  = null;

      function nextPass() {
        const [fromX, fromY, toX, toY] = passes[passIndex % passes.length];
        passIndex++;
        const duration = 4;

        // Snap to start of this pass
        gsap.set(eyeMesh.position, { x: fromX, y: fromY });

        // Bob during sweep
        if (bobTween) bobTween.kill();
        bobTween = gsap.to(eyeMesh.position, {
          y: fromY + 1.2,
          duration: 1.3,
          ease: 'sine.inOut',
          yoyo: true,
          repeat: -1,
        });

        gsap.to(eyeMesh.position, {
          x: toX,
          duration,
          ease: 'none',
          onComplete: () => {
            if (bobTween) bobTween.kill();
            gsap.delayedCall(30 + Math.random() * 10, nextPass);
          }
        });
      }

      nextPass();
      console.log('üëÅÔ∏è Eye animation started ‚Äî origin:', ox, oy);
    } else {
      console.warn('üëÅÔ∏è eye_Baked mesh not found');
    }
    
    // üîç DEBUG: List all individual objects
    console.log('');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üìã INDIVIDUAL OBJECTS IN GLB:');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log(`Total meshes found: ${sceneMeshes.length}`);
    console.log('');
    sceneMeshes.forEach((mesh, index) => {
      console.log(`${index + 1}. Name: "${mesh.name}"`);
      console.log(`   Type: ${mesh.type}`);
      console.log(`   Position: (${mesh.position.x.toFixed(2)}, ${mesh.position.y.toFixed(2)}, ${mesh.position.z.toFixed(2)})`);
      console.log(`   Has Material: ${!!mesh.material}`);
      console.log('');
    });
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üí° TIP: You can access any object by name using:');
    console.log('   sceneMeshes.find(m => m.name === "YourObjectName")');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('');
    
  } catch (e) {
    console.error("GLB Load Error:", e);
    console.warn('‚ö†Ô∏è Could not load GLB. Using default setup.');
  }
}

// ============================================
// üåü VOLUMETRIC LIGHT BEAMS
// ============================================

function setupVolumetricLights() {
  console.log('‚òÄÔ∏è Setting up volumetric light beams...');
  
  // Create realistic window light beams (like dust particles showing sunlight)
  const beamGeometry = new THREE.CylinderGeometry(0.1, 4, 30, 32, 1, true);
  const beamMaterial = new THREE.ShaderMaterial({
    transparent: true,
    side: THREE.DoubleSide,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: {
      lightColor: { value: new THREE.Color(POST_FX_CONFIG.volumetricLight.color) },
      intensity: { value: POST_FX_CONFIG.volumetricLight.intensity },
      opacity: { value: POST_FX_CONFIG.volumetricLight.opacity }
    },
    vertexShader: `
      varying vec3 vPosition;
      varying vec3 vNormal;
      void main() {
        vPosition = position;
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 lightColor;
      uniform float intensity;
      uniform float opacity;
      varying vec3 vPosition;
      varying vec3 vNormal;
      
      void main() {
        // Fade from bright at top to transparent at bottom
        float heightFade = smoothstep(-15.0, 15.0, vPosition.y);
        
        // Fade at edges (radial fade)
        float dist = length(vPosition.xz);
        float radialFade = 1.0 - smoothstep(0.0, 4.0, dist);
        
        // View angle fade (more visible from side)
        float viewFade = abs(dot(vNormal, vec3(0.0, 0.0, 1.0)));
        viewFade = pow(1.0 - viewFade, 2.0);
        
        float finalAlpha = heightFade * radialFade * viewFade * opacity;
        
        gl_FragColor = vec4(lightColor * intensity, finalAlpha);
      }
    `
  });
  
  // Create multiple light beams from different window positions
  const lightPositions = [
    { x: -20, y: 25, z: -5, rotation: 0.3 },   // Left window
    { x: -15, y: 25, z: -8, rotation: 0.2 },   // Left window 2
    { x: 20, y: 25, z: -5, rotation: -0.3 },   // Right window
    { x: 15, y: 25, z: -8, rotation: -0.2 }    // Right window 2
  ];
  
  lightPositions.forEach((pos, i) => {
    const beam = new THREE.Mesh(beamGeometry, beamMaterial.clone());
    beam.position.set(pos.x, pos.y, pos.z);
    beam.rotation.x = Math.PI / 2;  // Point downward
    beam.rotation.z = pos.rotation;  // Slight angle
    scene.add(beam);
    volumetricLights.push(beam);
    console.log(`  ‚úÖ Added volumetric light beam ${i + 1}`);
  });
  
  console.log('‚ú® Volumetric lights setup complete!');
}

// ============================================
// üåü POST-PROCESSING SETUP
// ============================================

async function setupGodRaysSystem() {
  console.log('üåÖ Setting up God Rays...');

  // HARDCODED GOD RAYS CONFIGURATION
  // Change these values to adjust god rays
  const GOD_RAYS_CONFIG = {
    // Light color - RGB format (0.0 to 1.0) - Click on values in VS Code for color picker!
    color: [0, 0.5, 1],  // [R, G, B] - Warm white/yellow
    intensity: 0.7,
    
    // Light position
    lightX: 46.1,
    lightY: 26.3,
    lightZ: -200,
    
    // Ray properties
    density: 0.01,
    maxDensity: 0.05,
    edgeStrength: 3,
    
    // Blocker plane (to prevent ray leaking)
    blockerX: -200,
    blockerY: 13.5,
    blockerZ: -5,
    blockerWidth: 20,
    blockerHeight: 20,
    blockerRotY: 90
  };

  // Create color from RGB array
  const godRayColor = new THREE.Color(...GOD_RAYS_CONFIG.color);

  // 1. Create Directional Light for God Rays
  godRaysLight = new THREE.DirectionalLight(godRayColor, GOD_RAYS_CONFIG.intensity);
  godRaysLight.position.set(GOD_RAYS_CONFIG.lightX, GOD_RAYS_CONFIG.lightY, GOD_RAYS_CONFIG.lightZ);
  godRaysLight.castShadow = true;
  godRaysLight.shadow.mapSize.width = 2048;
  godRaysLight.shadow.mapSize.height = 2048;
  godRaysLight.shadow.camera.near = 0.5;
  godRaysLight.shadow.camera.far = 500;
  godRaysLight.shadow.camera.left = -50;
  godRaysLight.shadow.camera.right = 50;
  godRaysLight.shadow.camera.top = 50;
  godRaysLight.shadow.camera.bottom = -50;
  scene.add(godRaysLight);

  // 2. Setup Composer
  composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  // 3. Import and Setup GodraysPass
  const GodraysPassModule = await import('https://unpkg.com/three-good-godrays@0.8.1/build/three-good-godrays.esm.js');
  const { GodraysPass } = GodraysPassModule;

  godRaysPass = new GodraysPass(godRaysLight, camera, {
    density: GOD_RAYS_CONFIG.density,
    maxDensity: GOD_RAYS_CONFIG.maxDensity,
    edgeStrength: GOD_RAYS_CONFIG.edgeStrength,
    edgeRadius: 2,
    distanceAttenuation: 2,
    color: godRayColor,  // Use the converted RGB color
    raymarchSteps: 30,
    blur: true,
    gammaCorrection: true
  });
  composer.addPass(godRaysPass);

  // 4. Create Blocker Plane (to block god rays from leaking)
  createBlockerPlane(GOD_RAYS_CONFIG);
  
  console.log('‚úÖ God Rays setup complete!');
}

function createBlockerPlane(config) {
  // Create a plane that casts shadows to block god rays
  const blockerGeo = new THREE.PlaneGeometry(config.blockerWidth, config.blockerHeight);
  const blockerMat = new THREE.MeshStandardMaterial({
    color: 0x000000,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0  // Invisible but casts shadows
  });
  
  blockerPlane = new THREE.Mesh(blockerGeo, blockerMat);
  blockerPlane.castShadow = true;
  blockerPlane.receiveShadow = false;
  blockerPlane.position.set(config.blockerX, config.blockerY, config.blockerZ);
  blockerPlane.rotation.y = config.blockerRotY * Math.PI / 180;
  blockerPlane.visible = true;
  scene.add(blockerPlane);
  
  console.log('üöß Blocker plane created');
}

// ============================================
// ‚ú® HOVER GLOW
// ============================================

function onHoverEnter(mesh) {
  const n = mesh.name.toLowerCase();
  const base = n.split('_')[0].split('.')[0];

  if (base === 'guitar') {
    hoverAnims.guitar.active = true;
    // Float up
    hoverAnims.guitar.meshes.forEach(m => {
      gsap.to(m.position, { y: m.userData.restY + 0.8, duration: 0.5, ease: 'power2.out' });
    });
  }
  if (base === 'globe')  hoverAnims.globe.active = true;
  if (base === 'chair')  hoverAnims.chair.active = true;
  if (base === 'arch') {
    hoverAnims.arch.active = true;
    hoverAnims.arch.hopIndex = 0;
    hoverAnims.arch.hopTimer = 0;
  }
}

function onHoverLeave(mesh) {
  const n = mesh.name.toLowerCase();
  const base = n.split('_')[0].split('.')[0];

  if (base === 'guitar') {
    hoverAnims.guitar.active = false;
    // Return to rest, reset tilt
    hoverAnims.guitar.meshes.forEach(m => {
      gsap.to(m.position, { y: m.userData.restY, duration: 0.4, ease: 'power2.inOut' });
      gsap.to(m.rotation, { z: 0, duration: 0.4, ease: 'power2.inOut' });
    });
  }
  if (base === 'globe') hoverAnims.globe.active = false;
  if (base === 'chair') hoverAnims.chair.active = false;
  if (base === 'arch') {
    hoverAnims.arch.active = false;
    // Drop any mid-hop arches back down
    hoverAnims.arch.sorted.forEach((m, i) => {
      gsap.to(m.position, { y: hoverAnims.arch.restYs[i], duration: 0.3, ease: 'power2.inOut' });
    });
  }
}

function updateHoverGlow() {
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(glowTargetMeshes, false);
  const hit = hits.length > 0 ? hits[0].object : null;
  if (hit === currentHovered) return;

  if (currentHovered) {
    glowShells.get(currentHovered).visible = false;
    onHoverLeave(currentHovered);
  }
  currentHovered = hit;
  if (hit) {
    glowShells.get(hit).visible = true;
    onHoverEnter(hit);
  }
}

// ============================================
// INTERACTION
// ============================================

function onMouseDown(event) {
  if (event.target !== renderer.domElement) return;
  if (isDragging) onMouseUp();

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  // Step 1: check wall cubes first (they sit IN FRONT of the scene)
  const wallMeshes = physicsObjects.map(o => o.mesh);
  const wallHits = raycaster.intersectObjects(wallMeshes, false);

  // Step 2: check glow targets (non-recursive ‚Äî we stored the exact mesh refs)
  const glowHits = raycaster.intersectObjects(glowTargetMeshes, false);

  const wallDist = wallHits.length > 0 ? wallHits[0].distance : Infinity;
  const glowDist = glowHits.length > 0 ? glowHits[0].distance : Infinity;

  if (glowDist < Infinity && glowDist <= wallDist) {
    // Glow target is closest (or no wall in the way) ‚Äî open panel
    const hit = glowHits[0].object;
    const n = hit.name.toLowerCase();
    const base = n.split('_')[0].split('.')[0];
    console.log('üéØ Clicked glow target:', hit.name, '‚Üí base:', base);
    openInfoPanel(base);
    return;
  }

  if (wallHits.length > 0) {
    // Wall cube is closest ‚Äî drag it
    const hit = wallHits[0];
    const obj = physicsObjects.find(o => o.mesh === hit.object || o.mesh === hit.object.parent);
    if (obj) {
      isDragging = true;
      obj.body.wakeUp();

      const dragShape = new CANNON.Sphere(0.1);
      dragBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC });
      dragBody.addShape(dragShape);
      dragBody.collisionFilterGroup = 0;
      dragBody.collisionFilterMask = 0;
      dragBody.position.copy(hit.point);
      world.addBody(dragBody);

      const localPivot = new CANNON.Vec3();
      obj.body.pointToLocalFrame(new CANNON.Vec3(hit.point.x, hit.point.y, hit.point.z), localPivot);

      dragConstraint = new CANNON.PointToPointConstraint(obj.body, localPivot, dragBody, new CANNON.Vec3(0,0,0));
      world.addConstraint(dragConstraint);

      dragPlane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), hit.point);
    }
  }
}

function onMouseMove(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  if (glowTargetMeshes.length > 0) glowNeedsUpdate = true;

  // Handle dragging
  if (!isDragging || !dragBody) return;

  raycaster.setFromCamera(mouse, camera);

  const target = new THREE.Vector3();
  raycaster.ray.intersectPlane(dragPlane, target);
  if (target) dragBody.position.set(target.x, target.y, target.z);
}

function onMouseUp() {
  if (isDragging) {
    world.removeConstraint(dragConstraint);
    world.removeBody(dragBody);
    isDragging = false;
    dragBody = null;
    dragConstraint = null;
  }
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  
  if (composer) {
    composer.setSize(window.innerWidth, window.innerHeight);
  }
}

function animate() {
  requestAnimationFrame(animate);
  
  // Subtle Camera Parallax
  if (initialCameraPos && !isDragging) {
    const targetX = initialCameraPos.x + mouse.x * 5;
    const targetY = initialCameraPos.y + mouse.y * 3;
    camera.position.x += (targetX - camera.position.x) * 0.05;
    camera.position.y += (targetY - camera.position.y) * 0.05;
    camera.lookAt(0, WALL_CONFIG.centerY, 0);
  }
  
  // Step physics
  world.step(1 / 60);

  // Sync visual meshes
  for (const obj of physicsObjects) {
    obj.mesh.position.copy(obj.body.position);
    obj.mesh.quaternion.copy(obj.body.quaternion);
  }

  // ‚ú® Glow: tiny raycast, only when mouse moved, only against 5 meshes
  if (glowNeedsUpdate) { glowNeedsUpdate = false; updateHoverGlow(); }

  // ‚ú® Particles
  if (particleSystem) particleSystem.material.uniforms.uTime.value += 0.016;

  // üé≠ HOVER ANIMATIONS
  const t = Date.now();

  // Guitar: float + tilt left/right
  if (hoverAnims.guitar.active) {
    hoverAnims.guitar.meshes.forEach(m => {
      // Gentle sway on Z
      m.rotation.z = Math.sin(t * 0.002) * 0.18;
    });
  }

  // Globe: spin on LOCAL Y (the mesh's own "up" from Blender, not world up)
  if (hoverAnims.globe.active) {
    hoverAnims.globe.meshes.forEach(m => {
      m.rotateOnAxis(_localY, 0.02);
    });
  }
  if (hoverAnims.chair.active) {
    hoverAnims.chair.meshes.forEach(m => { m.rotation.y += 0.025; });
  }

  // Arch: sequential hop ‚Äî each arch hops in turn, 200ms apart
  if (hoverAnims.arch.active) {
    hoverAnims.arch.hopTimer -= 16; // ~60fps
    if (hoverAnims.arch.hopTimer <= 0) {
      const idx = hoverAnims.arch.hopIndex;
      const mesh = hoverAnims.arch.sorted[idx];
      if (mesh) {
        const restY = hoverAnims.arch.restYs[idx];
        gsap.to(mesh.position, { y: restY + 1.2, duration: 0.18, ease: 'power2.out',
          onComplete: () => gsap.to(mesh.position, { y: restY, duration: 0.22, ease: 'bounce.out' })
        });
      }
      hoverAnims.arch.hopIndex = (idx + 1) % hoverAnims.arch.sorted.length;
      hoverAnims.arch.hopTimer = 180; // ms between hops
    }
  }

  // Render via Composer if available, else fallback
  if (composer) {
    composer.render();
  } else {
    renderer.render(scene, camera);
  }
}

function createParticles() {
  const COUNT = 2000;

  // ‚îÄ‚îÄ CONFIG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const PARTICLE_COLOR = new THREE.Color(0.45, 0.75, 1.0); // original blue-white
  const PARTICLE_SIZE  = 5.0;
  const SPREAD_X       = 50;
  const SPREAD_Y       = 35;
  const SPREAD_Z       = 60;   // deep ‚Äî some close, some very far
  const Z_CENTER       = -15;  // center of depth range behind wall
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  const positions = new Float32Array(COUNT * 3);
  const randoms   = new Float32Array(COUNT * 4);
  // aRandom: x = drift phase X, y = drift phase Y, z = drift phase Z, w = size/speed seed

  for (let i = 0; i < COUNT; i++) {
    positions[i * 3 + 0] = (Math.random() - 0.5) * SPREAD_X;
    positions[i * 3 + 1] = (Math.random() - 0.5) * SPREAD_Y + 13.5;
    positions[i * 3 + 2] = Z_CENTER + (Math.random() - 0.5) * SPREAD_Z;

    randoms[i * 4 + 0] = Math.random() * Math.PI * 2; // phase X
    randoms[i * 4 + 1] = Math.random() * Math.PI * 2; // phase Y
    randoms[i * 4 + 2] = Math.random() * Math.PI * 2; // phase Z + fade
    randoms[i * 4 + 3] = 0.2 + Math.random() * 0.8;  // speed & size seed
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('aRandom',  new THREE.BufferAttribute(randoms, 4));

  const mat = new THREE.ShaderMaterial({
    uniforms: {
      uTime:  { value: 0 },
      uColor: { value: PARTICLE_COLOR },
      uSize:  { value: PARTICLE_SIZE },
    },
    vertexShader: `
      attribute vec4  aRandom;
      uniform   float uTime;
      uniform   float uSize;
      varying   float vAlpha;

      void main() {
        float speed = 0.08 + aRandom.w * 0.12; // slow ‚Äî dust is lazy

        vec3 pos = position;
        // Each axis drifts independently with different frequencies
        // so motion is truly random-feeling, not circular
        pos.x += sin(uTime * speed       + aRandom.x) * 1.8
               + cos(uTime * speed * 0.6 + aRandom.y) * 1.2;
        pos.y += sin(uTime * speed * 0.7 + aRandom.y) * 1.4
               + sin(uTime * speed * 0.4 + aRandom.z) * 0.9;
        pos.z += cos(uTime * speed * 0.5 + aRandom.z) * 2.5
               + sin(uTime * speed * 0.3 + aRandom.x) * 1.5;

        // Fade: slow breathe per particle using its own phase
        float breathe = 0.5 + 0.5 * sin(uTime * 0.35 * aRandom.w + aRandom.z);
        vAlpha = breathe * breathe; // square for snappier fade

        vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);
        gl_Position  = projectionMatrix * mvPos;

        // Size scales with depth ‚Äî far = tiny, close = big, gives real parallax feel
        float depth = clamp(1.0 / -mvPos.z, 0.0, 1.0);
        gl_PointSize = uSize * aRandom.w * depth * 30.0;
      }
    `,
    fragmentShader: `
      uniform vec3  uColor;
      varying float vAlpha;

      void main() {
        float d = length(gl_PointCoord - vec2(0.5));
        if (d > 0.5) discard;
        // Sharp bright core, very tight falloff = star-like
        float softness = pow(1.0 - d * 2.0, 3.0);
        gl_FragColor = vec4(uColor, softness * vAlpha * 0.8);
      }
    `,
    transparent: true,
    depthWrite:  false,
    blending:    THREE.AdditiveBlending,
  });

  particleSystem = new THREE.Points(geo, mat);
  particleSystem.frustumCulled = false;
  scene.add(particleSystem);
  console.log(`‚ú® Dust particles created (${COUNT})`);
}
</script>

</body>
</html>
