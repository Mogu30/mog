<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<parameter name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive Wall with Lightmaps</title>

<style>
  body { margin: 0; overflow: hidden; background: #000; }
  #canvas-container { 
    width: 100%; 
    height: 100%; 
  }
  #back-btn {
    position: absolute;
    top: 40px;
    left: 40px;
    z-index: 10;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(12px);
    padding: 15px 40px;
    color: white;
    text-transform: uppercase;
    letter-spacing: 2px;
    cursor: pointer;
    font-family: 'Segoe UI', sans-serif;
    transition: all 0.3s ease;
    pointer-events: auto;
  }
  #back-btn:hover { background: rgba(255, 255, 255, 0.1); }
  
  /* Loading overlay - HIDDEN, keep homepage visible */
  #loading {
    position: fixed;
    inset: 0;
    background: #000;
    display: none; /* Hidden - we'll use opacity transition instead */
    justify-content: center;
    align-items: center;
    flex-direction: column;
    color: #4CAF50;
    font-family: monospace;
    z-index: 100;
    opacity: 0;
    pointer-events: none;
  }
  #loading-progress { margin-top: 10px; font-size: 14px; }
</style>

<!-- GSAP for animations -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.152.2/examples/jsm/",
    "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
    "postprocessing": "https://unpkg.com/postprocessing@6.36.3/build/index.js"
  }
}
</script>
</head>
<body>

<div id="canvas-container"></div>
<button id="back-btn">‚Üê BACK</button>

<script type="module">
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';

// üåü POST-PROCESSING IMPORTS
import { EffectComposer, RenderPass } from 'postprocessing';

// Configuration
const WALL_CONFIG = {
  cols: 16,
  rows: 9,
  cubeSize: 3,
  gap: 0.05,
  centerY: 13.5
};
const GLB_PATH = 'assets/scene.glb';
const CAM_FOV = 23;

// ============================================
// LIGHTMAP CONFIGURATION - DISABLED
// ============================================
const LIGHTMAP_CONFIG = {
  enabled: false  // Lightmaps disabled - using lights from GLB instead
};

// üé® POST-PROCESSING SETTINGS - ALL DISABLED
const POST_FX_CONFIG = {
  enabled: false,
  bloom: {
    enabled: false,
    strength: 0.4,
    radius: 0.5,
    threshold: 0.85
  },
  ssao: {
    enabled: false,
    kernelRadius: 8,
    minDistance: 0.005,
    maxDistance: 0.1,
    intensity: 1.0
  },
  godRays: {
    enabled: false,
    density: 0.96,
    weight: 0.3,
    decay: 0.95,
    exposure: 0.3,
    samples: 60
  },
  volumetricLight: {
    enabled: false,
    intensity: 2.0,
    color: 0xfff4e6,
    opacity: 0.3
  },
  fxaa: {
    enabled: false
  },
  vignette: {
    enabled: false,
    darkness: 0.5,
    offset: 1.0
  }
};

// Globals
let scene, camera, renderer, world;
let physicsObjects = [];
let raycaster, mouse;
let dragConstraint = null;
let dragBody = null;
let isDragging = false;
let dragPlane = new THREE.Plane();
let initialCameraPos = null;
let sceneMeshes = [];
let loadedLightmaps = {}; // Store loaded lightmap textures

// üåü POST-PROCESSING GLOBALS
let composer, godRaysPass;
let godRaysLight;
let volumetricLights = []; // Array of volumetric light beam meshes
let blockerPlane = null; // Plane to block god rays

init();

async function init() {
  // 1. Setup Physics World
  world = new CANNON.World();
  world.gravity.set(0, -9.82, 0);
  world.broadphase = new CANNON.NaiveBroadphase();
  world.solver.iterations = 20;

  // Materials - BRICK-LIKE PHYSICS
  const wallMaterial = new CANNON.Material('wall');
  const ballMaterial = new CANNON.Material('ball');
  const wallBallContact = new CANNON.ContactMaterial(wallMaterial, ballMaterial, {
    friction: 0.6,      // Was 0.1, now 0.6 (more friction, less sliding)
    restitution: 0.2    // Was 0.5, now 0.2 (less bouncy, more thud)
  });
  world.addContactMaterial(wallBallContact);

  // 2. Setup Three.js Scene
  scene = new THREE.Scene();
  scene.background = null; // Transparent - homepage shows through

  // Camera
  camera = new THREE.PerspectiveCamera(CAM_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 15, 68); // Updated camera position
  camera.lookAt(0, WALL_CONFIG.centerY, 0);

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha = transparent
  renderer.setClearColor(0x000000, 0); // Fully transparent background
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 0.8; // Reduced from 1.0 to prevent blown out look
  renderer.useLegacyLights = false;
  document.getElementById('canvas-container').appendChild(renderer.domElement);

  // Add WebGL context loss/restore handlers
  renderer.domElement.addEventListener('webglcontextlost', (event) => {
    event.preventDefault();
    console.error('‚ö†Ô∏è WebGL context lost! Stopping animation...');
  }, false);

  renderer.domElement.addEventListener('webglcontextrestored', () => {
    console.log('‚úÖ WebGL context restored!');
  }, false);

  // Initialize RectAreaLight
  RectAreaLightUniformsLib.init();

  // Add Ambient Light for general scene illumination
  const ambientLight = new THREE.AmbientLight(0xffffff, 5.0); // Set to 2.0 (your preferred value)
  scene.add(ambientLight);
  console.log('‚úÖ Ambient light added (intensity: 5.0)');

  // 3. Load Lightmaps FIRST (if enabled)
  if (LIGHTMAP_CONFIG.enabled) {
    await loadLightmaps();
  }

  // 4. Environment (HDRI) - ENABLED
  await loadHDRI();

  // 5. Create Environment
  createFloor(wallMaterial);
  
  await createWall(wallMaterial);
  
  await loadGLB();
  
  // Capture initial camera position for parallax
  initialCameraPos = camera.position.clone();

  // 7. Interaction
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  window.addEventListener('mousedown', onMouseDown);
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);
  window.addEventListener('resize', onWindowResize);
  
  document.getElementById('back-btn').addEventListener('click', async () => {
    document.getElementById('back-btn').style.pointerEvents = 'none';
    await resetWall(); // Reset the wall pieces
    window.parent.postMessage('wallBackClicked', '*');
  });

  // üåü Setup God Rays
  await setupGodRaysSystem();

  // Scene is ready - just notify parent (no fade, scene is already visible)
  window.parent.postMessage('sceneReady', '*');

  // 8. Start Loop
  animate();
}

// ============================================
// LIGHTMAP LOADING FUNCTIONS
// ============================================

async function loadLightmaps() {
  const exrLoader = new EXRLoader();
  const promises = [];
  
  console.log('üîÜ Loading lightmaps...');
  
  for (const [key, path] of Object.entries(LIGHTMAP_CONFIG.lightmaps)) {
    const promise = new Promise((resolve) => {
      exrLoader.load(
        path,
        (texture) => {
          // Configure lightmap texture
          texture.mapping = THREE.UVMapping;
          texture.colorSpace = THREE.LinearSRGBColorSpace; // IMPORTANT for lightmaps!
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.generateMipmaps = false;
          
          loadedLightmaps[key] = texture;
          console.log(`‚úÖ Loaded lightmap: ${key} from ${path}`);
          resolve();
        },
        undefined,
        (error) => {
          console.warn(`‚ö†Ô∏è Could not load lightmap ${key}: ${error.message}`);
          console.warn(`   Path: ${path}`);
          resolve(); // Don't block on failed lightmaps
        }
      );
    });
    promises.push(promise);
  }
  
  await Promise.all(promises);
  console.log(`üîÜ Lightmap loading complete. Loaded ${Object.keys(loadedLightmaps).length} lightmaps.`);
}

function findBestLightmapMatch(meshName) {
  if (!LIGHTMAP_CONFIG.autoMatch) return null;
  
  meshName = meshName.toLowerCase();
  
  // Try to find the best match by checking if mesh name contains lightmap key
  for (const key of Object.keys(loadedLightmaps)) {
    if (meshName.includes(key.toLowerCase())) {
      return key;
    }
  }
  
  // If no match found, use default
  return LIGHTMAP_CONFIG.defaultLightmap;
}

function applyLightmapToMesh(mesh, lightmapKey) {
  if (!LIGHTMAP_CONFIG.enabled) return;
  
  const lightmap = loadedLightmaps[lightmapKey];
  if (!lightmap) {
    console.warn(`‚ö†Ô∏è No lightmap found for key: ${lightmapKey}`);
    return;
  }
  
  // Check if mesh has UV2 (lightmap UVs)
  if (!mesh.geometry.attributes.uv2) {
    console.warn(`‚ö†Ô∏è Mesh "${mesh.name}" has no UV2 attribute for lightmaps. Copying UV1...`);
    // Fallback: copy UV1 to UV2 if not present
    mesh.geometry.setAttribute('uv2', mesh.geometry.attributes.uv.clone());
  }
  
  // Apply lightmap to material
  if (mesh.material) {
    mesh.material.lightMap = lightmap;
    mesh.material.lightMapIntensity = 1.0;
    mesh.material.needsUpdate = true;
    
    console.log(`üîÜ Applied lightmap "${lightmapKey}" to "${mesh.name}"`);
  }
}

// ============================================
// SCENE SETUP (existing functions)
// ============================================

function loadHDRI() {
  const hdriLoader = new RGBELoader();
  hdriLoader.load('assets/studio.hdr', (texture) => {
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.environment = texture;
    scene.userData.envMap = texture;
    console.log('‚úÖ HDRI Loaded');
  }, undefined, (err) => {
    console.log('‚ÑπÔ∏è No HDRI file - using GLB lights only');
  });
}

async function resetWall() {
  // STOP physics simulation during animation
  const wasAnimating = true;
  
  // Animate wall pieces back to original positions
  const animations = [];
  
  for (const obj of physicsObjects) {
    // Disable physics body during animation
    obj.body.mass = 0;
    obj.body.updateMassProperties();
    obj.body.velocity.set(0, 0, 0);
    obj.body.angularVelocity.set(0, 0, 0);
    
    // Animate the visual mesh smoothly
    const anim = gsap.to(obj.mesh.position, {
      x: obj.initialPos.x,
      y: obj.initialPos.y,
      z: obj.initialPos.z,
      duration: 1.5,
      ease: 'power2.inOut',
      onUpdate: function() {
        // Sync physics body to animated mesh position
        obj.body.position.set(
          obj.mesh.position.x,
          obj.mesh.position.y,
          obj.mesh.position.z
        );
      }
    });
    animations.push(anim);
    
    // Also animate rotation
    gsap.to(obj.mesh.quaternion, {
      x: obj.initialQuat.x,
      y: obj.initialQuat.y,
      z: obj.initialQuat.z,
      w: obj.initialQuat.w,
      duration: 1.5,
      ease: 'power2.inOut',
      onUpdate: function() {
        obj.body.quaternion.set(
          obj.mesh.quaternion.x,
          obj.mesh.quaternion.y,
          obj.mesh.quaternion.z,
          obj.mesh.quaternion.w
        );
      }
    });
  }
  
  // Wait for animations to complete
  await Promise.all(animations.map(a => a.then()));
  
  // Re-enable physics
  for (const obj of physicsObjects) {
    obj.body.mass = 25; // Match the brick mass
    obj.body.updateMassProperties();
    obj.body.position.copy(obj.initialPos);
    obj.body.quaternion.copy(obj.initialQuat);
    obj.body.velocity.set(0, 0, 0);
    obj.body.angularVelocity.set(0, 0, 0);
  }

  // Re-enable the back button for next time
  document.getElementById('back-btn').style.pointerEvents = 'auto';
}

function createFloor(material) {
  const floorShape = new CANNON.Plane();
  const floorBody = new CANNON.Body({ mass: 0, material: material });
  floorBody.addShape(floorShape);
  floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
  floorBody.position.set(0, 0, 0);
  world.addBody(floorBody);

  const geo = new THREE.PlaneGeometry(200, 200);
  const mat = new THREE.ShadowMaterial({ opacity: 0.3 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = -Math.PI / 2;
  mesh.receiveShadow = true;
  scene.add(mesh);
}

async function createWall(material) {
  const { cols, rows, cubeSize, gap, centerY } = WALL_CONFIG;
  const wallWidth = cols * (cubeSize + gap) - gap;
  const wallHeight = rows * (cubeSize + gap) - gap;
  
  const startX = -(wallWidth / 2) + (cubeSize / 2);
  const startY = centerY - (wallHeight / 2) + (cubeSize / 2);

  const baseGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
  const baseEdgesGeo = new THREE.EdgesGeometry(baseGeo);
  const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });

  const shape = new CANNON.Box(new CANNON.Vec3(cubeSize/2, cubeSize/2, cubeSize/2));

  // Load Texture
  const textureLoader = new THREE.TextureLoader();
  const masterTexture = await new Promise(resolve => textureLoader.load('mog.png', resolve));
  masterTexture.colorSpace = THREE.SRGBColorSpace;
  masterTexture.wrapS = THREE.ClampToEdgeWrapping;
  masterTexture.wrapT = THREE.ClampToEdgeWrapping;

  const wallVisualMaterial = new THREE.MeshStandardMaterial({ 
    map: masterTexture, 
    bumpMap: masterTexture,
    bumpScale: 0.2,
    roughness: 0.7, 
    metalness: 0.1,
    envMapIntensity: 0.5
  });

  // Back Barrier
  const barrierShape = new CANNON.Plane();
  const barrierBody = new CANNON.Body({ mass: 0 });
  barrierBody.addShape(barrierShape);
  barrierBody.position.set(0, 0, -cubeSize/2 - 0.05);
  world.addBody(barrierBody);

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const x = startX + c * (cubeSize + gap);
      const y = startY + r * (cubeSize + gap);
      
      // Physics - BRICK-LIKE: Heavy mass, less bouncy
      const body = new CANNON.Body({ mass: 25, material: material }); // Was 5, now 25 (5x heavier!)
      body.addShape(shape);
      body.position.set(x, y, 0);
      body.linearDamping = 0.4;  // Was 0.1, now 0.4 (slows down faster)
      body.angularDamping = 0.3; // Was 0.1, now 0.3 (less spinning)
      world.addBody(body);

      // Visual
      const meshGeometry = baseGeo.clone();
      const uvs = meshGeometry.attributes.uv;
      for (let i = 0; i < uvs.count; i++) {
        const u = uvs.getX(i);
        const v = uvs.getY(i);
        uvs.setXY(i, (u + c) / cols, (v + r) / rows);
      }

      const mesh = new THREE.Mesh(meshGeometry, wallVisualMaterial);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.name = `wall_cube_${r}_${c}`;
      scene.add(mesh);

      // Edges
      const edges = new THREE.LineSegments(baseEdgesGeo, edgesMaterial);
      mesh.add(edges);

      physicsObjects.push({ 
        mesh, 
        body,
        initialPos: new CANNON.Vec3().copy(body.position),
        initialQuat: new CANNON.Quaternion().copy(body.quaternion)
      });
      
      // Apply lightmap if available
      applyLightmapToMesh(mesh, 'wall');
    }
  }
}

async function loadGLB() {
  const loader = new GLTFLoader();
  const exrLoader = new EXRLoader();

  // Load the baked textures as base textures for MeshBasicMaterial
  const bakedTextures = {};
  
  console.log('üé® Loading baked textures...');
  try {
    const texturePaths = {
      'decorations': 'assets/textures/DECORATIONS_Bake1_CyclesBake_COMBINED.exr',
      'furniture': 'assets/textures/FURNITURE_Bake1_CyclesBake_COMBINED.exr',
      'stuff': 'assets/textures/STUFF_Bake1_CyclesBake_COMBINED.exr',
      'walls': 'assets/textures/WALLS_Bake1_CyclesBake_COMBINED.exr'
    };
    
    for (const [key, path] of Object.entries(texturePaths)) {
      try {
        const texture = await new Promise((resolve, reject) => {
          exrLoader.load(path, resolve, undefined, reject);
        });
        // EXR files should be Linear, not sRGB!
        texture.colorSpace = THREE.LinearSRGBColorSpace;
        texture.flipY = true; // ‚ö†Ô∏è Try toggling this if texture is upside down!
        texture.channel = 0;
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.needsUpdate = true;
        bakedTextures[key] = texture;
        console.log(`  ‚úÖ Loaded ${key} texture`);
      } catch (err) {
        console.log(`  ‚ö†Ô∏è Couldn't load ${key} texture - will use material color`);
      }
    }
  } catch (err) {
    console.log('  ‚ÑπÔ∏è No baked textures found - using GLB materials');
  }

  try {
    const gltf = await new Promise((resolve, reject) => {
      loader.load(
        GLB_PATH, 
        resolve, 
        undefined, 
        (error) => {
          console.error('GLB loading error:', error);
          reject(error);
        }
      );
    });
    const model = gltf.scene;
    
    // Debug: Log what we got from the GLB
    console.log('üì¶ GLB Info:');
    console.log('  - Scenes:', gltf.scenes?.length || 0);
    console.log('  - Meshes:', gltf.scene.children.length);
    console.log('  - Textures:', gltf.textures?.length || 0);
    console.log('  - Materials:', gltf.materials?.length || 0);
    
    model.traverse(child => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
        child.frustumCulled = false;
        
        // Use MeshBasicMaterial for baked textures (no lighting needed!)
        const meshName = child.name.toLowerCase();
        let bakedTexture = null;
        
        console.log(`üîç Checking mesh: "${child.name}" (lowercase: "${meshName}")`);
        
        // Find matching baked texture (check specific keywords before generic ones)
        if (meshName.includes('walls') && bakedTextures.walls) {
          bakedTexture = bakedTextures.walls;
          console.log(`  ‚úÖ Matched to WALLS texture`);
        } else if (meshName.includes('stuff') && bakedTextures.stuff) {
          bakedTexture = bakedTextures.stuff;
          console.log(`  ‚úÖ Matched to STUFF texture`);
        } else if ((meshName.includes('furniture') || meshName.includes('furnitrure')) && bakedTextures.furniture) {
          bakedTexture = bakedTextures.furniture;
          console.log(`  ‚úÖ Matched to FURNITURE texture`);
        } else if (meshName.includes('decorations') && bakedTextures.decorations) {
          bakedTexture = bakedTextures.decorations;
          console.log(`  ‚úÖ Matched to DECORATIONS texture`);
        } else {
          console.log(`  ‚ö†Ô∏è No texture match found`);
        }
        
        if (bakedTexture) {
          // Texture is already set to flipY = true from loading
          
          // Clone the texture for this mesh so we can adjust UVs independently
          const texClone = bakedTexture.clone();
          texClone.needsUpdate = true;
          
          // UV transform - adjust these if texture scale is wrong
          // Default is 1,1 (no repeat). Increase to tile more, decrease to tile less
          texClone.repeat.set(1, 1);
          texClone.offset.set(0, 0);
          
          // FIX: Use UV2 (LightMapUV) for 'stuff' mesh if available
          if (bakedTexture === bakedTextures.stuff && child.geometry.attributes.uv2) {
            console.log(`  üîÑ Swapping UVs for ${child.name} to use LightMapUV (uv2)`);
            child.geometry.setAttribute('uv', child.geometry.attributes.uv2);
          }
          
          child.material = new THREE.MeshBasicMaterial({
            map: texClone
          });
          
          console.log(`üé® Applied baked texture to ${child.name}`);
        } else {
          // No baked texture - create default material
          if (!child.material) {
            child.material = new THREE.MeshStandardMaterial({
              color: 0xcccccc,
              roughness: 0.7,
              metalness: 0.0
            });
          }
        }
        
        child.material.side = THREE.DoubleSide;

        sceneMeshes.push(child);
        
        // Check for camera sphere
        if (meshName.includes('sphere')) {
          console.log('üìç Found camera sphere, updating camera...');
          const pos = new THREE.Vector3();
          child.getWorldPosition(pos);
          camera.position.copy(pos);
          camera.lookAt(0, WALL_CONFIG.centerY, 0);
          child.visible = false;
        }
      }
      
      // Handle Lights
      if (child.isLight) {
        console.log(`üí° Found GLB Light: ${child.name} (Type: ${child.type})`);
        child.castShadow = true;
        child.shadow.mapSize.width = 2048;
        child.shadow.mapSize.height = 2048;
        child.shadow.normalBias = 0.02;
        
        if (child.isSpotLight && child.target) {
          model.add(child.target);
        }
      }
    });
    
    model.position.set(0, 0, -1.9);
    scene.add(model);
    console.log('‚úÖ GLB Loaded successfully');
    
    // üîç DEBUG: List all individual objects
    console.log('');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üìã INDIVIDUAL OBJECTS IN GLB:');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log(`Total meshes found: ${sceneMeshes.length}`);
    console.log('');
    sceneMeshes.forEach((mesh, index) => {
      console.log(`${index + 1}. Name: "${mesh.name}"`);
      console.log(`   Type: ${mesh.type}`);
      console.log(`   Position: (${mesh.position.x.toFixed(2)}, ${mesh.position.y.toFixed(2)}, ${mesh.position.z.toFixed(2)})`);
      console.log(`   Has Material: ${!!mesh.material}`);
      console.log('');
    });
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üí° TIP: You can access any object by name using:');
    console.log('   sceneMeshes.find(m => m.name === "YourObjectName")');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('');
    
  } catch (e) {
    console.error("GLB Load Error:", e);
    console.warn('‚ö†Ô∏è Could not load GLB. Using default setup.');
  }
}

// ============================================
// üåü VOLUMETRIC LIGHT BEAMS
// ============================================

function setupVolumetricLights() {
  console.log('‚òÄÔ∏è Setting up volumetric light beams...');
  
  // Create realistic window light beams (like dust particles showing sunlight)
  const beamGeometry = new THREE.CylinderGeometry(0.1, 4, 30, 32, 1, true);
  const beamMaterial = new THREE.ShaderMaterial({
    transparent: true,
    side: THREE.DoubleSide,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: {
      lightColor: { value: new THREE.Color(POST_FX_CONFIG.volumetricLight.color) },
      intensity: { value: POST_FX_CONFIG.volumetricLight.intensity },
      opacity: { value: POST_FX_CONFIG.volumetricLight.opacity }
    },
    vertexShader: `
      varying vec3 vPosition;
      varying vec3 vNormal;
      void main() {
        vPosition = position;
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 lightColor;
      uniform float intensity;
      uniform float opacity;
      varying vec3 vPosition;
      varying vec3 vNormal;
      
      void main() {
        // Fade from bright at top to transparent at bottom
        float heightFade = smoothstep(-15.0, 15.0, vPosition.y);
        
        // Fade at edges (radial fade)
        float dist = length(vPosition.xz);
        float radialFade = 1.0 - smoothstep(0.0, 4.0, dist);
        
        // View angle fade (more visible from side)
        float viewFade = abs(dot(vNormal, vec3(0.0, 0.0, 1.0)));
        viewFade = pow(1.0 - viewFade, 2.0);
        
        float finalAlpha = heightFade * radialFade * viewFade * opacity;
        
        gl_FragColor = vec4(lightColor * intensity, finalAlpha);
      }
    `
  });
  
  // Create multiple light beams from different window positions
  const lightPositions = [
    { x: -20, y: 25, z: -5, rotation: 0.3 },   // Left window
    { x: -15, y: 25, z: -8, rotation: 0.2 },   // Left window 2
    { x: 20, y: 25, z: -5, rotation: -0.3 },   // Right window
    { x: 15, y: 25, z: -8, rotation: -0.2 }    // Right window 2
  ];
  
  lightPositions.forEach((pos, i) => {
    const beam = new THREE.Mesh(beamGeometry, beamMaterial.clone());
    beam.position.set(pos.x, pos.y, pos.z);
    beam.rotation.x = Math.PI / 2;  // Point downward
    beam.rotation.z = pos.rotation;  // Slight angle
    scene.add(beam);
    volumetricLights.push(beam);
    console.log(`  ‚úÖ Added volumetric light beam ${i + 1}`);
  });
  
  console.log('‚ú® Volumetric lights setup complete!');
}

// ============================================
// üåü POST-PROCESSING SETUP
// ============================================

async function setupGodRaysSystem() {
  console.log('üåÖ Setting up God Rays...');

  // HARDCODED GOD RAYS CONFIGURATION
  // Change these values to adjust god rays
  const GOD_RAYS_CONFIG = {
    // Light color - RGB format (0.0 to 1.0) - Click on values in VS Code for color picker!
    color: [0, 0.5, 1],  // [R, G, B] - Warm white/yellow
    intensity: 0.7,
    
    // Light position
    lightX: 46.1,
    lightY: 26.3,
    lightZ: -200,
    
    // Ray properties
    density: 0.0125,
    maxDensity: 0.7,
    edgeStrength: 3,
    
    // Blocker plane (to prevent ray leaking)
    blockerX: -200,
    blockerY: 13.5,
    blockerZ: -5,
    blockerWidth: 20,
    blockerHeight: 20,
    blockerRotY: 90
  };

  // Create color from RGB array
  const godRayColor = new THREE.Color(...GOD_RAYS_CONFIG.color);

  // 1. Create Directional Light for God Rays
  godRaysLight = new THREE.DirectionalLight(godRayColor, GOD_RAYS_CONFIG.intensity);
  godRaysLight.position.set(GOD_RAYS_CONFIG.lightX, GOD_RAYS_CONFIG.lightY, GOD_RAYS_CONFIG.lightZ);
  godRaysLight.castShadow = true;
  godRaysLight.shadow.mapSize.width = 2048;
  godRaysLight.shadow.mapSize.height = 2048;
  godRaysLight.shadow.camera.near = 0.5;
  godRaysLight.shadow.camera.far = 500;
  godRaysLight.shadow.camera.left = -50;
  godRaysLight.shadow.camera.right = 50;
  godRaysLight.shadow.camera.top = 50;
  godRaysLight.shadow.camera.bottom = -50;
  scene.add(godRaysLight);

  // 2. Setup Composer
  composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  // 3. Import and Setup GodraysPass
  const GodraysPassModule = await import('https://unpkg.com/three-good-godrays@0.8.1/build/three-good-godrays.esm.js');
  const { GodraysPass } = GodraysPassModule;

  godRaysPass = new GodraysPass(godRaysLight, camera, {
    density: GOD_RAYS_CONFIG.density,
    maxDensity: GOD_RAYS_CONFIG.maxDensity,
    edgeStrength: GOD_RAYS_CONFIG.edgeStrength,
    edgeRadius: 2,
    distanceAttenuation: 2,
    color: godRayColor,  // Use the converted RGB color
    raymarchSteps: 70,
    blur: true,
    gammaCorrection: true
  });
  composer.addPass(godRaysPass);

  // 4. Create Blocker Plane (to block god rays from leaking)
  createBlockerPlane(GOD_RAYS_CONFIG);
  
  console.log('‚úÖ God Rays setup complete!');
}

function createBlockerPlane(config) {
  // Create a plane that casts shadows to block god rays
  const blockerGeo = new THREE.PlaneGeometry(config.blockerWidth, config.blockerHeight);
  const blockerMat = new THREE.MeshStandardMaterial({
    color: 0x000000,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0  // Invisible but casts shadows
  });
  
  blockerPlane = new THREE.Mesh(blockerGeo, blockerMat);
  blockerPlane.castShadow = true;
  blockerPlane.receiveShadow = false;
  blockerPlane.position.set(config.blockerX, config.blockerY, config.blockerZ);
  blockerPlane.rotation.y = config.blockerRotY * Math.PI / 180;
  blockerPlane.visible = true;
  scene.add(blockerPlane);
  
  console.log('üöß Blocker plane created');
}

// ============================================
// INTERACTION
// ============================================

function onMouseDown(event) {
  if (event.target !== renderer.domElement) return;
  if (isDragging) onMouseUp();

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(physicsObjects.map(o => o.mesh), true);

  if (intersects.length > 0) {
    const hit = intersects[0];
    const obj = physicsObjects.find(o => o.mesh === hit.object || o.mesh === hit.object.parent);
    
    if (obj) {
      isDragging = true;
      obj.body.wakeUp();
      
      const dragShape = new CANNON.Sphere(0.1);
      dragBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC });
      dragBody.addShape(dragShape);
      dragBody.collisionFilterGroup = 0;
      dragBody.collisionFilterMask = 0;
      dragBody.position.copy(hit.point);
      world.addBody(dragBody);

      const localPivot = new CANNON.Vec3();
      obj.body.pointToLocalFrame(new CANNON.Vec3(hit.point.x, hit.point.y, hit.point.z), localPivot);
      
      dragConstraint = new CANNON.PointToPointConstraint(obj.body, localPivot, dragBody, new CANNON.Vec3(0,0,0));
      world.addConstraint(dragConstraint);

      dragPlane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), hit.point);
    }
  }
}

function onMouseMove(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // Handle dragging
  if (!isDragging || !dragBody) return;

  raycaster.setFromCamera(mouse, camera);

  const target = new THREE.Vector3();
  raycaster.ray.intersectPlane(dragPlane, target);
  if (target) dragBody.position.set(target.x, target.y, target.z);
}

function onMouseUp() {
  if (isDragging) {
    world.removeConstraint(dragConstraint);
    world.removeBody(dragBody);
    isDragging = false;
    dragBody = null;
    dragConstraint = null;
  }
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  
  if (composer) {
    composer.setSize(window.innerWidth, window.innerHeight);
  }
}

function animate() {
  requestAnimationFrame(animate);
  
  // Subtle Camera Parallax
  if (initialCameraPos && !isDragging) {
    const targetX = initialCameraPos.x + mouse.x * 5;
    const targetY = initialCameraPos.y + mouse.y * 3;
    camera.position.x += (targetX - camera.position.x) * 0.05;
    camera.position.y += (targetY - camera.position.y) * 0.05;
    camera.lookAt(0, WALL_CONFIG.centerY, 0);
  }
  
  // Step physics
  world.step(1 / 60);

  // Sync visual meshes
  for (const obj of physicsObjects) {
    obj.mesh.position.copy(obj.body.position);
    obj.mesh.quaternion.copy(obj.body.quaternion);
  }

  // Render via Composer if available, else fallback
  if (composer) {
    composer.render();
  } else {
    renderer.render(scene, camera);
  }
}
</script>

</body>
</html>
