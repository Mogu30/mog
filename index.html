<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MOG Eye (PNG Mask + Blink)</title>

<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: black;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Loading screen */
#loadingScreen {
  position: fixed;
  inset: 0;
  background: black;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  color: white;
  font-family: Arial, sans-serif;
}

#loadingScreen h2 {
  font-size: 2rem;
  margin-bottom: 1rem;
}

#loadingProgress {
  font-size: 1.2rem;
  opacity: 0.7;
}

#container {
  position: relative;
  width: 100vw;
  height: 100vh;
  max-width: calc(100vh * 16 / 9);
  max-height: calc(100vw * 9 / 16);
  background: black;
  opacity: 0;
  transition: opacity 0.5s ease;
}

#container.loaded {
  opacity: 1;
}

#bgGif,
#bgFreeze {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  z-index: 0;
}

#bgFreeze {
  display: none;
}

/* Main home page content */
#mainContent {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

/* Contacts Page - same level as main content */
#contactsPage {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  background: black;
  color: white;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1;
  font-family: Arial, sans-serif;
}

/* Transition GIF - plays ON TOP of everything as an overlay */
#transitionGif {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  z-index: 999;
  display: none;
  pointer-events: none;
}

svg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

.icon {
  position: absolute;
  width: 180px;
  height: 180px;
  transform-origin: center center;
  z-index: 2;
  pointer-events: auto;
  cursor: pointer;
  filter: drop-shadow(0 0 0px rgba(0,0,0,0));
  transition: filter 0.5s ease;
}

.icon img {
  width: 100%;
  height: 100%;
  display: block;
  object-fit: contain;
  pointer-events: none;
}

#eyeOffset {
  opacity: 0;
  transition: opacity 0.8s ease;
}

#blinkLid {
  transform-origin: 50% 50%;
  transform: scaleY(0);
  pointer-events: none;
}

@keyframes blink {
  0%   { transform: scaleY(0); }
  45%  { transform: scaleY(1); }
  55%  { transform: scaleY(1); }
  100% { transform: scaleY(0); }
}

#contactsPage h1 {
  font-size: 4rem;
  margin-bottom: 2rem;
  text-transform: uppercase;
  letter-spacing: 0.5rem;
}

#contactsPage p {
  font-size: 1.5rem;
  margin-bottom: 3rem;
  opacity: 0.7;
}

#backButton {
  padding: 1rem 3rem;
  font-size: 1.2rem;
  background: white;
  color: black;
  border: none;
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 0.2rem;
  transition: all 0.3s ease;
}

#backButton:hover {
  background: #333;
  color: white;
  transform: scale(1.05);
}
</style>
</head>

<body>

<!-- Loading Screen -->
<div id="loadingScreen">
  <h2>Loading...</h2>
  <p id="loadingProgress">Preparing assets...</p>
</div>

<div id="container">
  <img id="bgGif" src="mog.gif" alt="">
  <canvas id="bgFreeze"></canvas>
  
  <!-- Main home page with eye and icons -->
  <div id="mainContent">
    <div class="icon" id="icon-art"><img src="frames/art/Frame_00000.png" alt="Art"></div>
    <div class="icon" id="icon-edu"><img src="frames/edu/Frame_00000.png" alt="Education"></div>
    <div class="icon" id="icon-contacts"><img src="frames/contacts/Frame_00000.png" alt="Contacts"></div>
    <div class="icon" id="icon-work"><img src="frames/work/Frame_00000.png" alt="Work"></div>

    <svg viewBox="0 0 1920 1080">
      <defs>
        <mask id="eyeMask" maskUnits="userSpaceOnUse">
          <image href="mask.png" x="0" y="0" width="1920" height="1080" preserveAspectRatio="none"/>
        </mask>
      </defs>

      <g id="eyeContainer" transform="translate(960,535) scale(1) translate(-960,-540)">
        <g id="eyeOffset">
          <image href="White.png" x="0" y="0" width="1920" height="1080"/>
          <g mask="url(#eyeMask)">
            <g id="eyeMove">
              <image href="Iris.png" x="0" y="0" width="1920" height="1080"/>
            </g>
            <image href="reflections.png" x="-690" y="-487" width="3090" height="2390" style="mix-blend-mode: screen;" />
            <rect id="blinkLid" x="0" y="0" width="1920" height="1080" fill="black"/>
          </g>
        </g>
      </g>
    </svg>
  </div>
  
  <!-- Contacts Page (hidden by default) -->
  <div id="contactsPage">
    <h1>Contacts</h1>
    <p>This is the contacts page content.</p>
    <p>You can add your contact information here!</p>
    <button id="backButton">← Back to Home</button>
  </div>
  
  <!-- Transition GIF overlay (plays on top of current page) -->
  <img id="transitionGif" src="" alt="">
</div>

<script>
/* ======================================================================== */
/* PRELOADER */
/* ======================================================================== */

const loadingScreen = document.getElementById('loadingScreen');
const loadingProgress = document.getElementById('loadingProgress');
const container = document.getElementById('container');

// Critical assets that MUST load before showing the page
const criticalAssets = [
  'mog.gif',
  'White.png',
  'Iris.png',
  'mask.png',
  'reflections.png',
  'transition.gif',
  'transition-reverse.gif'
];

let loadedCount = 0;
const totalAssets = criticalAssets.length;

function updateProgress() {
  loadedCount++;
  const percent = Math.round((loadedCount / totalAssets) * 100);
  loadingProgress.textContent = `Loading assets... ${percent}%`;
  
  if (loadedCount === totalAssets) {
    console.log('All assets loaded!');
    setTimeout(() => {
      loadingScreen.style.display = 'none';
      container.classList.add('loaded');
    }, 500);
  }
}

// Preload all critical assets
criticalAssets.forEach(src => {
  const img = new Image();
  img.onload = () => {
    console.log(`Loaded: ${src}`);
    updateProgress();
  };
  img.onerror = () => {
    console.error(`Failed to load: ${src}`);
    updateProgress(); // Continue anyway
  };
  img.src = src;
});

/* ======================================================================== */
/* ICON SYSTEM */
/* ======================================================================== */

const CHARGE_TIME = 500;
const ART_FORWARD_SPEED = 2;
const ART_REVERSE_SPEED = 0.3;
const EDU_FORWARD_SPEED = 0.3;
const EDU_REVERSE_SPEED = 0.3;
const CONTACTS_FORWARD_SPEED = 0.85;
const CONTACTS_REVERSE_SPEED = 0.3;
const WORK_LOOP_SPEED = 0.2;
const WORK_REVERSE_SPEED = 0.3;

const DESIGN_WIDTH = 1920;
const DESIGN_HEIGHT = 1080;

const iconSettings = {
  "icon-art":      { x: 220,  y: 810, scale: 2.5 },
  "icon-edu":      { x: 230,  y: 225, scale: 2.5 },
  "icon-work":     { x: 1690, y: 235, scale: 2.25 },
  "icon-contacts": { x: 1690, y: 810, scale: 2.35 }
};

function positionIcons() {
  const container = document.getElementById('container');
  const containerWidth = container.offsetWidth;
  const containerHeight = container.offsetHeight;
  
  for (const id in iconSettings) {
    const el = document.getElementById(id);
    const s = iconSettings[id];
    const scaleX = containerWidth / DESIGN_WIDTH;
    const scaleY = containerHeight / DESIGN_HEIGHT;
    const scale = Math.min(scaleX, scaleY);

    el.style.left = (s.x / DESIGN_WIDTH) * 100 + "%";
    el.style.top  = (s.y / DESIGN_HEIGHT) * 100 + "%";
    el.style.transform = `translate(-50%, -50%) scale(${s.scale * scale})`;
  }
}
positionIcons();
window.addEventListener('resize', positionIcons);

class SequenceIcon {
  constructor(element, frameCount, folder, holdFrame = null, speed = 0.04, forwardSpeed = 0.5, reverseSpeed = 0.3, loopSpeed = 0.2) {
    this.element = element;
    this.img = element.querySelector('img');
    this.frameCount = frameCount;
    this.folder = folder;
    this.holdFrame = holdFrame;
    this.speed = speed;
    this.forwardSpeed = forwardSpeed;
    this.reverseSpeed = reverseSpeed;
    this.loopSpeed = loopSpeed;
    this.currentFrame = 0;
    this.targetFrame = 0;
    this.isHovering = false;
    this.isHolding = false;
    this.isCharged = false;
    this.chargeTimer = null;
    this.isClickable = false;
    this.preloadFrames();
    this.setupListeners();
    this.animate();
  }
  
  preloadFrames() {
    this.frames = [];
    for (let i = 0; i < this.frameCount; i++) {
      const img = new Image();
      const frameNum = String(i).padStart(5, '0');
      img.src = `frames/${this.folder}/Frame_${frameNum}.png`;
      this.frames.push(img);
    }
  }
  
  setupListeners() {
    this.element.addEventListener('mouseenter', () => {
      this.isHovering = true;
      this.isCharged = false;
      this.isClickable = false;
      this.element.style.filter =
        "drop-shadow(0 0 10px rgba(0,0,0,1)) drop-shadow(0 0 18px rgba(0,0,0,1)) drop-shadow(0 0 28px rgba(0,0,0,1))";
      this.chargeTimer = setTimeout(() => {
        this.isCharged = true;
        if (this.holdFrame !== null) this.targetFrame = this.holdFrame;
      }, CHARGE_TIME);
    });
    
    this.element.addEventListener('mouseleave', () => {
      this.isHovering = false;
      this.isHolding = false;
      this.isCharged = false;
      this.isClickable = false;
      this.targetFrame = 0;
      this.element.style.filter = "drop-shadow(0 0 0px rgba(0,0,0,0))";
      clearTimeout(this.chargeTimer);
    });
  }
  
  animate() {
    if (this.isCharged) {
      if (this.holdFrame === null) {
        this.currentFrame += this.speed * this.frameCount * this.loopSpeed;
        if (this.currentFrame >= this.frameCount - 1) this.currentFrame = 0;
      } else {
        if (this.isHovering && !this.isHolding && Math.abs(this.currentFrame - this.holdFrame) < 0.5) {
          this.isHolding = true;
          this.isClickable = true;
          this.currentFrame = this.holdFrame;
          this.targetFrame = this.holdFrame;
        }
        if (!this.isHolding) {
          const distance = Math.abs(this.targetFrame - this.currentFrame);
          let easingSpeed = this.speed * this.forwardSpeed;
          if (distance < 2) easingSpeed = 0.5;
          this.currentFrame += (this.targetFrame - this.currentFrame) * easingSpeed;
          if (distance < 0.1) this.currentFrame = this.targetFrame;
        }
      }
    } else {
      if (this.currentFrame > 0) {
        this.currentFrame -= this.speed * this.frameCount * this.reverseSpeed;
        if (this.currentFrame < 0) this.currentFrame = 0;
      }
    }
    
    const frameIndex = Math.round(this.currentFrame);
    if (this.frames[frameIndex] && this.frames[frameIndex].complete) {
      this.img.src = this.frames[frameIndex].src;
    }
    requestAnimationFrame(() => this.animate());
  }
}

const artIcon = new SequenceIcon(document.getElementById('icon-art'),28,'art',20,0.028,ART_FORWARD_SPEED,ART_REVERSE_SPEED);
const eduIcon = new SequenceIcon(document.getElementById('icon-edu'),21,'edu',24,0.025,EDU_FORWARD_SPEED,EDU_REVERSE_SPEED);
const contactsIcon = new SequenceIcon(document.getElementById('icon-contacts'),30,'contacts',12,0.030,CONTACTS_FORWARD_SPEED,CONTACTS_REVERSE_SPEED);
const workIcon = new SequenceIcon(document.getElementById('icon-work'),29,'work',null,0.029,null,WORK_REVERSE_SPEED,WORK_LOOP_SPEED);

/* ======================================================================== */
/* TRANSITION SYSTEM - CORRECT UNDERSTANDING */
/* ======================================================================== */

const transitionGif = document.getElementById('transitionGif');
const contactsPage = document.getElementById('contactsPage');
const mainContent = document.getElementById('mainContent');
const backButton = document.getElementById('backButton');
let isTransitioning = false;

// GIF Configuration
const GIF_CONFIG = {
  forward: {
    path: 'transition.gif',
    duration: 2670      // Eye expands, pupil goes black and fills screen
  },
  reverse: {
    path: 'transition-reverse.gif',
    duration: 1170      // Black pupil shrinks, eye returns to center
  }
};

// Preload GIFs
const forwardGifImg = new Image();
forwardGifImg.src = GIF_CONFIG.forward.path;
const reverseGifImg = new Image();
reverseGifImg.src = GIF_CONFIG.reverse.path;

// Smooth eye centering
function resetEyeToCenter() {
  return new Promise((resolve) => {
    const transformAttr = eyeMove.getAttribute('transform') || 'translate(0, 0)';
    const matches = transformAttr.match(/translate\(([-\d.]+),\s*([-\d.]+)\)/);
    
    const startX = matches ? parseFloat(matches[1]) : 0;
    const startY = matches ? parseFloat(matches[2]) : 0;
    
    const duration = 800;
    const startTime = performance.now();
    
    function animate(currentTime) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const eased = 1 - Math.pow(1 - progress, 3);
      
      const currentX = startX * (1 - eased);
      const currentY = startY * (1 - eased);
      
      eyeMove.setAttribute('transform', `translate(${currentX}, ${currentY})`);
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        resolve();
      }
    }
    
    requestAnimationFrame(animate);
  });
}

// Play GIF transition with cache buster for repeatability
function playGifTransition(gifPath, duration) {
  return new Promise((resolve) => {
    console.log(`Playing transition: ${gifPath} (${duration}ms)`);
    
    // Clear and reload with cache buster
    transitionGif.src = '';
    
    requestAnimationFrame(() => {
      const cacheBuster = '?t=' + Date.now();
      transitionGif.src = gifPath + cacheBuster;
      transitionGif.style.display = 'block';
      
      const startTime = performance.now();
      
      function checkProgress() {
        const elapsed = performance.now() - startTime;
        
        if (elapsed >= duration) {
          console.log('Transition GIF complete!');
          resolve();
        } else {
          requestAnimationFrame(checkProgress);
        }
      }
      
      requestAnimationFrame(checkProgress);
    });
  });
}

/* ======================================================================== */
/* FORWARD TRANSITION: Home → Contacts */
/* Flow:
   1. Center eye smoothly
   2. Play forward GIF (eye expands, pupil goes black)
   3. When GIF ends (screen is BLACK from pupil), show contacts page
   4. Hide GIF
*/
/* ======================================================================== */

document.getElementById('icon-contacts').addEventListener('click', async () => {
  if (isTransitioning || !contactsIcon.isClickable) return;
  
  console.log('=== FORWARD TRANSITION START ===');
  isTransitioning = true;
  
  try {
    // Step 1: Center the eye
    console.log('Step 1: Centering eye...');
    await resetEyeToCenter();
    
    // Step 2: Play forward GIF (eye expands, pupil fills screen with black)
    console.log('Step 2: Playing forward GIF (eye expanding)...');
    await playGifTransition(GIF_CONFIG.forward.path, GIF_CONFIG.forward.duration);
    
    // Step 3: Wait for paint cycles to ensure GIF last frame is composited
    await new Promise(requestAnimationFrame);
    await new Promise(requestAnimationFrame);
    
    // Step 4: Switch to contacts (both black - no flash)
    console.log('Step 3: Switching to contacts (both black - no flash)...');
    mainContent.style.display = 'none';
    contactsPage.style.display = 'flex';
    
    // Step 5: Hide the GIF (don't clear src - let it cache)
    transitionGif.style.display = 'none';
    
    console.log('=== FORWARD TRANSITION COMPLETE ===');
  } catch (error) {
    console.error('Forward transition error:', error);
    transitionGif.style.display = 'none';
    mainContent.style.display = 'none';
    contactsPage.style.display = 'flex';
  } finally {
    isTransitioning = false;
  }
});

/* ======================================================================== */
/* REVERSE TRANSITION: Contacts → Home */
/* Flow:
   1. Show home page BEHIND contacts (home becomes visible)
   2. Hide contacts page (now only home page visible)
   3. Play reverse GIF ON TOP of home (starts with black pupil, shrinks)
   4. Home page visible through transparent parts as pupil shrinks
   5. When GIF ends, just hide it - home is already there!
*/
/* ======================================================================== */

backButton.addEventListener('click', async () => {
  if (isTransitioning) return;
  
  console.log('=== REVERSE TRANSITION START ===');
  isTransitioning = true;
  
  try {
    // Step 1: Show home page behind contacts AND ensure it's fully visible
    console.log('Step 1: Preparing home page with everything visible...');
    mainContent.style.display = 'block';
    mainContent.style.opacity = '1';
    container.style.opacity = '1';
    
    // Force eye to be fully visible immediately (no fade-in transition)
    eyeOffset.style.transition = 'none';
    eyeOffset.style.opacity = '1';
    void eyeOffset.offsetHeight;
    eyeOffset.style.transition = 'opacity 0.8s ease';
    
    // Small delay to ensure home page is fully rendered
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // Step 2: Start reverse GIF WHILE contacts is still visible
    console.log('Step 2: Starting reverse GIF (covers contacts with black pupil)...');
    const cacheBuster = '?t=' + Date.now();
    transitionGif.src = GIF_CONFIG.reverse.path + cacheBuster;
    transitionGif.style.display = 'block';
    
    // Wait for GIF to start displaying
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // Step 3: NOW hide contacts - GIF is already covering it
    console.log('Step 3: Hiding contacts (GIF already covering with black pupil)...');
    contactsPage.style.display = 'none';
    
    // Step 4: Wait for reverse GIF to finish playing
    console.log('Step 4: Waiting for reverse GIF to complete (pupil shrinking)...');
    await new Promise(resolve => setTimeout(resolve, GIF_CONFIG.reverse.duration));
    
    // Step 5: Wait TWO paint cycles to ensure home is composited before removing GIF
    console.log('Step 5: Waiting for home page to composite...');
    await new Promise(requestAnimationFrame);
    await new Promise(requestAnimationFrame);
    
    // Step 6: NOW hide GIF - home is guaranteed to be painted
    console.log('Step 6: Hiding GIF - home page already painted!');
    transitionGif.style.display = 'none';
    // DON'T clear src - let it stay cached
    
    console.log('=== REVERSE TRANSITION COMPLETE ===');
  } catch (error) {
    console.error('Reverse transition error:', error);
    transitionGif.style.display = 'none';
    contactsPage.style.display = 'none';
    mainContent.style.display = 'block';
    eyeOffset.style.opacity = '1';
  } finally {
    isTransitioning = false;
  }
});

/* ======================================================================== */
/* EYE SYSTEM WITH GIF FREEZE */
/* ======================================================================== */

const BLINK_SPEED = 240;
const DOUBLE_BLINK_CHANCE = 0.3;
const DOUBLE_BLINK_DELAY = 180;
const BLINK_MIN_DELAY = 2400;
const BLINK_MAX_DELAY = 5000;

const eyeMove   = document.getElementById("eyeMove");
const eyeOffset = document.getElementById("eyeOffset");
const blinkLid  = document.getElementById("blinkLid");

const bgGif = document.getElementById("bgGif");
const bgFreeze = document.getElementById("bgFreeze");
const ctx = bgFreeze.getContext("2d");

let eyeActive = false;

// Wait for background GIF to load, then freeze it
bgGif.addEventListener('load', () => {
  console.log('Background GIF loaded, waiting to freeze frame...');
  
  setTimeout(() => {
    if (eyeActive) return;

    // Ensure GIF is fully loaded
    if (!bgGif.complete || bgGif.naturalWidth === 0 || bgGif.naturalHeight === 0) {
      console.error('GIF not ready, retrying...');
      setTimeout(() => bgGif.dispatchEvent(new Event('load')), 100);
      return;
    }

    // Use naturalWidth/Height for accurate dimensions
    bgFreeze.width = bgGif.naturalWidth;
    bgFreeze.height = bgGif.naturalHeight;
    
    console.log(`Canvas size: ${bgFreeze.width}x${bgFreeze.height}`);
    
    if (bgFreeze.width > 0 && bgFreeze.height > 0) {
      try {
        ctx.drawImage(bgGif, 0, 0, bgFreeze.width, bgFreeze.height);
        console.log('Successfully froze GIF frame');
        
        bgGif.style.display = "none";
        bgFreeze.style.display = "block";

        eyeOffset.style.opacity = "1";
        eyeActive = true;
        startBlinking();
      } catch (error) {
        console.error('Failed to draw GIF to canvas:', error);
      }
    }
  }, 4078);
});

// Fallback
setTimeout(() => {
  if (!eyeActive && bgGif.complete) {
    console.log('Manually triggering GIF load event');
    bgGif.dispatchEvent(new Event('load'));
  }
}, 200);

function moveEye(clientX, clientY) {
  if (!eyeActive) return;
  const x = (clientX / window.innerWidth  - 0.5) * 120;
  const y = (clientY / window.innerHeight - 0.5) * 60;
  eyeMove.setAttribute("transform", `translate(${x}, ${y})`);
}

document.addEventListener("mousemove", (e) => moveEye(e.clientX, e.clientY));

function blinkOnce() {
  blinkLid.style.animation = `blink ${BLINK_SPEED}ms ease-in-out`;
  blinkLid.addEventListener("animationend", () => blinkLid.style.animation = "", { once: true });
}

function blink() {
  blinkOnce();
  if (Math.random() < DOUBLE_BLINK_CHANCE) {
    setTimeout(blinkOnce, DOUBLE_BLINK_DELAY);
  }
}

function startBlinking() {
  (function loop() {
    blink();
    const delay = BLINK_MIN_DELAY + Math.random() * (BLINK_MAX_DELAY - BLINK_MIN_DELAY);
    setTimeout(loop, delay);
  })();
}
</script>

</body>
</html>
