<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>MOG /title>

<!-- GSAP from cdnjs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<style>
/* ========================================================================
   CSS VARIABLES
   ======================================================================== */
:root {
  --z-background: 0;
  --z-content: 1;
  --z-icons: 2;
  --z-transition: 999;
  --z-loading: 9999;

  --color-bg: black;
  --color-text: white;
  --color-accent: #333;

  --transition-fast: 0.1s;
  --transition-normal: 0.3s;

  --space-sm: 1rem;
  --space-md: 2rem;
  --space-lg: 3rem;
}

/* ========================================================================
   BASE
   ======================================================================== */
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: var(--color-bg);
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  overscroll-behavior: none;
  -webkit-overflow-scrolling: touch;
}

/* ========================================================================
   LOADING SCREEN
   ======================================================================== */
#loadingScreen {
  position: fixed;
  inset: 0;
  background: transparent;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: var(--z-loading);
  color: var(--color-text);
  font-family: Arial, sans-serif;
  pointer-events: none;
}
#loadingScreen h2 {
  font-size: 2rem;
  margin-bottom: var(--space-sm);
  pointer-events: auto;
  font-family: 'Arial Black', 'Helvetica Neue', sans-serif;
  font-weight: 900;
  letter-spacing: -1px;
  color: black;
  text-shadow: -1px -1px 0 #ff0000, 1px -1px 0 #ff0000, -1px 1px 0 #ff0000, 1px 1px 0 #ff0000;
  animation: smokeOut 1s ease-in-out infinite alternate;
}
@keyframes smokeOut {
  100% { opacity: 0.08; filter: blur(3px); letter-spacing: 1px; }
}

/* Comet animation SVG */
#loadingSvg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  pointer-events: none;
}
#loadingScreen h2 {
  position: relative;
  z-index: 1;
}
#loadingSvg path,
#loadingSvg line,
#loadingSvg polyline,
#loadingSvg polygon {
  fill: none;
  stroke-linecap: round;
  stroke-linejoin: round;
}

/* ========================================================================
   CONTAINER  ‚Äî starts invisible, fades in after loading
   ======================================================================== */
#container {
  position: relative;
  width: 100vw;
  height: 100vh;
  max-width: calc(100vh * 16 / 9);
  max-height: calc(100vw * 9 / 16);
  background: var(--color-bg);
  opacity: 0;
  -webkit-tap-highlight-color: transparent;
  touch-action: none;
}

/* ========================================================================
   BACKGROUND VIDEO & FREEZE
   ======================================================================== */
#bgVideo, #bgFreeze {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  z-index: var(--z-background);
}
#bgFreeze { display: none; }

/* ========================================================================
   FULLSCREEN WALL (independent layer, not in container)
   ======================================================================== */
#wall-fullscreen {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
  z-index: 500;
  opacity: 0;
  pointer-events: none;
  background: black;
}
#wall-fullscreen canvas {
  display: block;
  width: 100%;
  height: 100%;
  position: relative;
  z-index: 1;
}
#wall-click-text {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 2.2rem;
  color: rgba(255,255,255,0.7);
  font-family: 'Inter', 'Segoe UI', 'Arial', sans-serif;
  font-weight: 300;
  letter-spacing: -0.04em;
  animation: fadeInOut 2s infinite;
  pointer-events: none;
  z-index: 9999 !important; /* High z-index to be above WebGL canvas */
  visibility: hidden;
  isolation: isolate;
  text-shadow: 0 1px 4px rgba(0,0,0,0.12);
}
@keyframes fadeInOut {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 1; }
}
#backButtonWall {
  position: fixed;
  top: 2rem;
  right: 2rem;
  padding: 0.8rem 1.5rem;
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: 2px solid white;
  border-radius: 0.5rem;
  font-size: 1rem;
  font-family: Arial, sans-serif;
  cursor: pointer;
  z-index: 10000 !important; /* Very high to ensure on top of WebGL canvas */
  visibility: hidden;
  pointer-events: none;
  opacity: 0;
  /* Prevent any transform/filter that could affect stacking */
  isolation: isolate;
}
#backButtonWall:hover {
  background: rgba(255, 255, 255, 0.4);
  transform: scale(1.05);
}
#wall-content {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
  background: black;
  color: white;
  z-index: 499;
  opacity: 0;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 2rem;
  overflow-y: auto;
}
#wall-content.visible {
  opacity: 1;
  pointer-events: auto;
}
#wall-content-text {
  max-width: 800px;
  font-size: 1.2rem;
  line-height: 1.6;
  font-family: Arial, sans-serif;
  margin-bottom: 2rem;
}
#backButtonContent {
  padding: 0.8rem 1.5rem;
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: 2px solid white;
  border-radius: 0.5rem;
  font-size: 1rem;
  font-family: Arial, sans-serif;
  cursor: pointer;
  transition: all 0.3s ease;
}
#backButtonContent:hover {
  background: rgba(255, 255, 255, 0.4);
  transform: scale(1.05);
}

/* ========================================================================
   CONTENT LAYERS
   ======================================================================== */
#mainContent {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-content);
}

/* Pages ‚Äî opacity / children animated entirely by GSAP */
#contactsPage, #eduPage {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  background: var(--color-bg);
  color: var(--color-text);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: var(--z-content);
  font-family: Arial, sans-serif;
}

/* ========================================================================
   TRANSITION VIDEO
   ======================================================================== */
#transitionVideo {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  z-index: var(--z-transition);
  display: none;
  pointer-events: none;
}
/* Edu: video behind icons so their fade is visible */
#transitionVideo.under-icons { z-index: 0; }

/* ========================================================================
   SVG / EYE  ‚Äî opacity managed by GSAP
   ======================================================================== */
svg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-content);
  will-change: transform;
  transform: translateZ(0);
}
#eyeOffset { opacity: 0; }   /* GSAP sets this */

#blinkLid {
  transform-origin: 50% 50%;
  transform: scaleY(0);
  pointer-events: none;
}
#reflections { mix-blend-mode: screen; }

@keyframes blink {
  0%   { transform: scaleY(0) translateY(-50%); }
  45%  { transform: scaleY(1) translateY(0%); }
  55%  { transform: scaleY(1) translateY(0%); }
  100% { transform: scaleY(0) translateY(-50%); }
}

/* ========================================================================
   SPRITE SHEET ICONS
   ======================================================================== */
.icon {
  position: absolute;
  transform-origin: center center;
  z-index: var(--z-icons);
  pointer-events: auto;
  cursor: pointer;
  filter: drop-shadow(0 0 0px rgba(0,0,0,0));
  opacity: 1;
  transition: filter var(--transition-fast) ease;
  will-change: background-position, transform;
  transform: translateZ(0);
  backface-visibility: hidden;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
  -webkit-user-select: none;
  background-repeat: no-repeat;
  image-rendering: -webkit-optimize-contrast;
  image-rendering: crisp-edges;
}

/* Flag class ‚Äî pointer-events only; GSAP handles the opacity */
.icon.icon-hidden { pointer-events: none; }
.icon.touching { filter: drop-shadow(0 0 10px rgba(255,255,255,0.5)); }

/* Individual icon sprite settings - base size 180px like original */
#icon-art {
  width: 180px;
  height: 169px; /* maintain aspect ratio: 180 * (425/453) */
  background-image: url('assets/sprites/icon-art.png');
  background-size: 8640px 169px; /* scale proportionally: 21744 * (180/453) */
  background-position: 0 0;
}

#icon-contacts {
  width: 180px;
  height: 203px; /* maintain aspect ratio: 180 * (436/386) */
  background-image: url('assets/sprites/icon-contacts.png');
  background-size: 5400px 203px; /* scale proportionally: 11580 * (180/386) */
  background-position: 0 0;
}

#icon-edu {
  width: 180px;
  height: 105px; /* maintain aspect ratio: 180 * (320/456) */
  background-image: url('assets/sprites/icon-edu.png');
  background-size: 13136px 105px; /* scale proportionally: 40150 * (180/456) */
  background-position: 0 0;
}

#icon-work {
  width: 180px;
  height: 226px; /* maintain aspect ratio: 180 * (397/316) */
  background-image: url('assets/sprites/icon-work.png');
  background-size: 5220px 226px; /* scale proportionally: 9164 * (180/316) */
  background-position: 0 0;
}

/* ========================================================================
   PAGE CONTENT STYLES
   ======================================================================== */
#contactsPage h1, #eduPage h1 {
  font-size: 4rem;
  margin-bottom: var(--space-md);
  text-transform: uppercase;
  letter-spacing: 0.5rem;
}
#contactsPage p, #eduPage p {
  font-size: 1.5rem;
  margin-bottom: var(--space-lg);
  opacity: 0.7;
}
.backButton {
  padding: var(--space-sm) var(--space-lg);
  font-size: 1.2rem;
  background: var(--color-text);
  color: var(--color-bg);
  border: none;
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 0.2rem;
  transition: all var(--transition-normal) ease;
  -webkit-tap-highlight-color: transparent;
}
.backButton:hover { background: var(--color-accent); color: var(--color-text); transform: scale(1.05); }
.backButton:active { transform: scale(0.95); }

/* ========================================================================
   RESPONSIVE
   ======================================================================== */
@media (max-width: 768px) {
  #contactsPage h1, #eduPage h1 { font-size: 2.5rem; letter-spacing: 0.3rem; }
  #contactsPage p, #eduPage p   { font-size: 1.2rem; }
  .backButton { font-size: 1rem; padding: 0.8rem 2rem; }
}

/* ========================================================================
   CONTACTS PAGE - Animated Eye Background
   ======================================================================== */

/* Canvas for contacts eyes */
#contactsPage .contacts-canvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

/* Contacts content - Golden ratio layout */
#contactsPage .contacts-content {
  position: relative;
  z-index: 2;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: center;
  min-height: 100%;
  width: 100%;
  padding: 5vh 2vw;
  padding-left: 3vw;
  gap: 34px;
}

/* Title - Elegant thin typography */
#contactsPage .contacts-title {
  font-size: 3.5rem;
  font-weight: 200;
  letter-spacing: 0.8rem;
  text-transform: uppercase;
  color: #fff;
  position: relative;
  display: inline-block;
  line-height: 1.2em;
  margin: 0;
  padding: 0;
  font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
}

/* Split effect container with box */
#contactsPage .title-split {
  position: relative;
  display: inline-block;
  cursor: pointer;
  background: rgba(255, 255, 255, 0.05);
  border: none;
  border-radius: 16px;
  padding: 1.2rem 2.5rem;
  backdrop-filter: blur(12px);
  transition: all 0.3s ease;
}

#contactsPage .title-split:hover {
  background: linear-gradient(135deg, rgba(139, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0.3) 70%);
}

#contactsPage .title-top {
  position: absolute;
  color: #fff;
  top: 1.2rem;
  left: 2.5rem;
  display: inline-block;
  clip-path: polygon(0% 66%, 0% 0%, 100% 0%, 100% 40%);
  transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1) 0.25s;
}

#contactsPage .title-bottom {
  display: inline-block;
  clip-path: polygon(0% 65%, 100% 40%, 100% 110%, 0% 110%);
  color: #fff;
  transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1) 0.25s;
}

#contactsPage .title-split:hover .title-top {
  transform: translateY(-0.4em);
  transition: transform 0.5s cubic-bezier(.12,.8,.57,1.00) 0.42s;
}

#contactsPage .title-split:hover .title-bottom {
  transform: translateY(0.4em);
  transition: transform 0.5s cubic-bezier(.12,.8,.57,1.00) 0.42s;
}

/* Contacts cards container */
#contactsPage .cards-container {
  display: flex;
  flex-direction: column;
  gap: 21px;
  align-items: flex-start;
  max-width: 500px;
  width: 100%;
}

/* Body box */
#contactsPage .body-box {
  width: 100%;
  max-width: 500px;
  background: rgba(255, 255, 255, 0.05);
  border: none;
  border-radius: 13px;
  padding: 2rem 2.5rem;
  backdrop-filter: blur(12px);
  transition: all 0.3s ease;
  display: flex;
  flex-direction: column;
  gap: 21px;
  position: relative;
  overflow: hidden;
}

#contactsPage .body-box::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(45deg, transparent, rgba(139, 0, 0, 0.4), transparent);
  transform: translateX(-100%);
  transition: transform 0.6s ease;
}

#contactsPage .body-box:hover::before {
  transform: translateX(100%);
}

#contactsPage .body-box:hover {
  background: linear-gradient(135deg, rgba(139, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0.3) 70%);
}

/* Body text lines */
#contactsPage .body-line {
  display: flex;
  gap: 13px;
  align-items: baseline;
  font-size: 1.1rem;
  font-weight: 300;
  font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
  color: #fff;
  cursor: pointer;
  transition: all 0.3s ease;
  padding: 0.4rem 0.6rem;
  border-radius: 8px;
  letter-spacing: 0.05rem;
}

#contactsPage .body-line:hover {
  background: rgba(139, 0, 0, 0.15);
}

#contactsPage .body-line .label {
  min-width: 80px;
  color: rgba(255, 255, 255, 0.5);
  text-transform: uppercase;
  letter-spacing: 0.15rem;
  font-weight: 400;
  font-size: 0.85rem;
}

#contactsPage .body-line .value {
  overflow: hidden;
  height: 1.6rem;
  position: relative;
  font-weight: 300;
}

/* Character animation for carousel effect */
#contactsPage .body-line .value .char {
  display: inline-block;
  position: relative;
  overflow: hidden;
  height: 1.6rem;
  vertical-align: top;
}

#contactsPage .body-line .value .char .char-inner {
  display: block;
  transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
  position: relative;
}

#contactsPage .body-line.animating .value .char .char-inner {
  transform: translateY(-1.6rem);
}

#contactsPage .body-line .value .char .char-inner::before {
  content: attr(data-char);
  position: absolute;
  top: -1.6rem;
  left: 0;
}

#contactsPage .body-line .value .char .char-inner::after {
  content: attr(data-char);
  position: absolute;
  top: 1.6rem;
  left: 0;
}

/* Stagger animation delays */
#contactsPage .body-line.animating .value .char:nth-child(1) .char-inner { transition-delay: 0s; }
#contactsPage .body-line.animating .value .char:nth-child(2) .char-inner { transition-delay: 0.05s; }
#contactsPage .body-line.animating .value .char:nth-child(3) .char-inner { transition-delay: 0.1s; }
#contactsPage .body-line.animating .value .char:nth-child(4) .char-inner { transition-delay: 0.15s; }
#contactsPage .body-line.animating .value .char:nth-child(5) .char-inner { transition-delay: 0.2s; }
#contactsPage .body-line.animating .value .char:nth-child(6) .char-inner { transition-delay: 0.25s; }
#contactsPage .body-line.animating .value .char:nth-child(7) .char-inner { transition-delay: 0.3s; }
#contactsPage .body-line.animating .value .char:nth-child(8) .char-inner { transition-delay: 0.35s; }
#contactsPage .body-line.animating .value .char:nth-child(9) .char-inner { transition-delay: 0.4s; }
#contactsPage .body-line.animating .value .char:nth-child(10) .char-inner { transition-delay: 0.45s; }
#contactsPage .body-line.animating .value .char:nth-child(11) .char-inner { transition-delay: 0.5s; }
#contactsPage .body-line.animating .value .char:nth-child(12) .char-inner { transition-delay: 0.55s; }
#contactsPage .body-line.animating .value .char:nth-child(13) .char-inner { transition-delay: 0.6s; }
#contactsPage .body-line.animating .value .char:nth-child(14) .char-inner { transition-delay: 0.65s; }
#contactsPage .body-line.animating .value .char:nth-child(15) .char-inner { transition-delay: 0.7s; }
#contactsPage .body-line.animating .value .char:nth-child(16) .char-inner { transition-delay: 0.75s; }
#contactsPage .body-line.animating .value .char:nth-child(17) .char-inner { transition-delay: 0.8s; }
#contactsPage .body-line.animating .value .char:nth-child(18) .char-inner { transition-delay: 0.85s; }
#contactsPage .body-line.animating .value .char:nth-child(19) .char-inner { transition-delay: 0.9s; }
#contactsPage .body-line.animating .value .char:nth-child(20) .char-inner { transition-delay: 0.95s; }
#contactsPage .body-line.animating .value .char:nth-child(21) .char-inner { transition-delay: 1s; }
#contactsPage .body-line.animating .value .char:nth-child(22) .char-inner { transition-delay: 1.05s; }
#contactsPage .body-line.animating .value .char:nth-child(23) .char-inner { transition-delay: 1.1s; }
#contactsPage .body-line.animating .value .char:nth-child(24) .char-inner { transition-delay: 1.15s; }
#contactsPage .body-line.animating .value .char:nth-child(25) .char-inner { transition-delay: 1.2s; }

/* Veins overlay effect */
#contactsPage .veins-overlay {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 10;
  opacity: 0.15;
  background-image: 
    radial-gradient(ellipse at 20% 30%, transparent 0%, transparent 40%, rgba(139, 0, 0, 0.1) 40%, transparent 41%),
    radial-gradient(ellipse at 80% 70%, transparent 0%, transparent 40%, rgba(139, 0, 0, 0.1) 40%, transparent 41%),
    radial-gradient(ellipse at 50% 50%, transparent 0%, transparent 50%, rgba(139, 0, 0, 0.05) 50%, transparent 51%);
  animation: contactsVeinsPulse 4s ease-in-out infinite;
}

@keyframes contactsVeinsPulse {
  0%, 100% { opacity: 0.1; }
  50% { opacity: 0.2; }
}

/* Contacts back button - Elegant thin style */
#contactsPage .contacts-back-btn {
  padding: 0.8rem 2rem;
  font-size: 0.85rem;
  background: rgba(255, 255, 255, 0.05);
  color: rgba(255, 255, 255, 0.7);
  border: 1px solid rgba(139, 0, 0, 0.4);
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 0.2rem;
  font-weight: 300;
  font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
  border-radius: 8px;
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  backdrop-filter: blur(12px);
  margin-top: 21px;
}

#contactsPage .contacts-back-btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(45deg, transparent, rgba(139, 0, 0, 0.4), transparent);
  transform: translateX(-100%);
  transition: transform 0.6s ease;
}

#contactsPage .contacts-back-btn:hover::before {
  transform: translateX(100%);
}

#contactsPage .contacts-back-btn:hover {
  color: #fff;
  border-color: rgba(139, 0, 0, 0.7);
  background: linear-gradient(135deg, rgba(139, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.3) 70%);
}

#contactsPage .contacts-back-btn:active {
  transform: scale(0.98);
}

/* Breathing animation for contacts content */
@keyframes contactsBreathe {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.02); }
}

#contactsPage .contacts-content {
  animation: contactsBreathe 8s ease-in-out infinite;
}
</style>
</head>
<body>

<!-- Loading Screen -->
<div id="loadingScreen">
  <!-- üåü COMET ANIMATION SVG üåü -->
  <svg id="loadingSvg" viewBox="0 0 1920 1080" xmlns="http://www.w3.org/2000/svg">
    <defs id="loading-gradient-defs"></defs>
    
    <g id="loading-original-paths">
      <!-- üîΩüîΩüîΩ PASTE YOUR SVG PATHS HERE üîΩüîΩüîΩ -->
            <svg height="1080" viewBox="0 0 1920 1080" width="1920" xmlns="http://www.w3.org/2000/svg"><g fill="none" stroke="#b30000" stroke-linecap="round" stroke-linejoin="round"><path d="m0 110v1h103v859h-102l38 38v35h35l37 37h1v-19h1697v19h3l36-37h35v-35l37-37v-1h-98l-3-3v-856h101v-1l-37-38v-34h-34l-37-38h-3v19h-1697v-19h-1l-37 38h-35v34z"/><path d="m1158 656q21-28 55-37c-30-17-67-2-73 32zm67-383c-54 34-122 39-178 9v2c7 48 54 84 102 67zm-13 187q-34-7-54-35l-18 3c3 33 46 54 72 32m-137-89-28-15c-6 23 12 43 34 42zm-193 430c50 16 108 16 159 0l1-8-9-13c-47 14-98 13-145 0-2 7-11 13-6 21m199-118c-22-2-40 19-34 41l28-14zm-238 50q28 21 36 54c21-29 1-65-32-72z"/><path d="m1079 347a87 87 0 0 1 -36-54c-20 28-2 64 30 71h2zm-35 439q7-33 35-53l-5-17c-32 6-52 43-30 70m-281-361a85 85 0 0 1 -52 35c25 21 66 1 71-30z"/><path d="m788 784c100 74 246 73 346 0-34-6-60 12-89 21-53 17-111 15-163 1l-1 1c-12-3-28-13-42-17q-25-8-51-6m254-499-4-6q-63-18-129-7c-21 5-37 3-22 29q74-22 146 0zm181 332q15-55 9-111c-1-6-7-43-12-44l-18 10q19 69-1 138l17 8z"/><path d="m696 809c54-37 122-40 180-11-7-49-51-83-100-71zm528-2-75-78c-49-17-95 19-102 68l1 1c56-30 123-25 176 9m-345-514q-8 35-36 54l4 17c33-4 52-43 32-71m-176 169-4 2q-21 77 0 153l5 1 16-10q-19-68 0-137zm137-66c22 5 41-18 36-40q-13 11-29 14zm357 213c13-45 14-94 0-137h-24c15 43 15 93 0 137zm-378 33c6 5 18 7 27 18 5 6 8 17 10 20 1 1 10 4 12 7q13 11 14 28l45 14-155-155 12 42c12 3 21 5 29 15z"/><path d="m820 661c13 7 14 22 31 18-5-13-17-26-30-31zm-46-38 12 28 30 7c2-24-19-41-42-35m115 153q72 21 143-1v-23c-46 15-96 15-142 0z"/><path d="m890 748c46 16 97 16 143 0 1-11 13-17 9-28-50 22-112 23-161 0-6 10 7 18 9 28m181-69h14c1 0 11-17 17-18l-1-13c-13 5-25 18-30 31m-231 4 7 27 29 14c5-23-13-43-36-41m-87-213c-17 20-13 115 0 141l17 9 10-3c-22-48-21-107 0-155-6-5-24 4-27 8m63-48-30 7-12 28c23 6 44-11 42-35"/><path d="m748 472h-24c-11 44-14 93 1 137h23q-21-68 0-137m400-15-12-28-30-7c-3 24 19 41 42 35m-438 161q33 10 54 37l19-4c-7-34-44-49-73-33m442-54c4-7 3-43-1-50l-164-164c-7-4-28-4-37-3q-8 0-15 3l-165 165v50l166 165c8 5 42 5 50 0zm-46 94 30-7 12-28c-23-6-44 11-42 35"/><path d="m1170 471c-10-5-17-15-27-9 20 49 20 108 0 156 11 5 16-4 26-7 15-45 15-95 1-140m-1008 121 2-2c-29-14-43-47-24-75 14-22 44-25 60-45 24-29 11-70-23-84l-3 3c29 13 44 46 25 75-15 21-46 25-62 45-22 28-9 72 25 83m495-343v-15q-13-3-28-4c-28-2-85-3-113 2-27 5-55 20-75 39-29-28-68-41-108-41v13c42 2 81 16 108 48 24-29 60-45 97-48s82-1 119 6"/><path d="m454 228h-27l14 11z"/><path d="m374 228q37 10 67 34 29-23 63-34h-38l-25 19-26-19zm131-87c-32-27-86-20-106 18l3 4c20-35 68-45 99-18 17 15 24 40 43 54 32 22 83 13 101-23l-2-4a67 67 0 0 1 -92 25c-23-13-28-40-46-56m828-16c-21 2-43 15-53 35l2 3c20-29 55-43 89-26 25 13 31 42 51 59 32 26 86 17 104-19l-2-4a68 68 0 0 1 -76 31c-51-14-41-85-115-79m-941 49-2-1a69 69 0 0 1 -57 34l2 4q18-1 33-9c6-3 29-21 24-28"/><path d="m404 169c23 45 89 45 110-2a62 62 0 0 0 -56-34c-22 1-46 15-54 36 22 45 90 45 109-2m-851 435c-7 1-22 16-26 22-17 28 0 59 29 69 26-10 42-36 30-64-4-10-22-28-33-27m976-436a63 63 0 0 0 -57-33c-19 1-48 17-51 37 22 43 83 43 108 2z"/><path d="m1004 138c-32-23-85-15-101 23l3 2c20-35 68-45 99-18 16 14 23 37 39 51 31 26 87 17 105-20l-2-4c-18 27-45 40-77 31-38-10-39-46-66-65m-840 559c-26-17-45-45-25-76 17-27 55-25 69-58 12-29-2-59-31-72l-4 2c24 13 40 35 32 63-10 38-65 36-76 74-8 27 6 62 35 67m1105-530a61 61 0 0 0 -56-34c-15 0-33 9-44 20-10 12-11 14-2 27 27 35 87 29 102-13"/><path d="m1132 139c-33-24-84-16-104 21l4 3c15-26 43-38 73-31 54 12 46 96 128 77 14-4 44-20 40-37-20 32-60 45-93 24-23-15-27-41-48-57m-303-14q-18 2-33 13c-2 1-27 23-18 25 20-26 46-40 79-30 41 11 41 64 85 75 29 8 66-2 80-31l-2-4a68 68 0 0 1 -73 31c-54-13-43-85-118-79m-498 744 1 4c66 7 50 85 125 81 19-1 54-16 55-38-22 30-56 44-91 25-27-15-30-45-54-61q-16-11-36-11"/><path d="m891 167a63 63 0 0 0 -58-34q-19 2-35 14c-19 16-21 25-1 41 31 26 73 16 94-17zm-725 820 1 3m0 0c6 11 12 32-5 36l-4-3c-4-5-4-12-8-17l-5-2s-1-7-4-11c-6-6-9-2-11-3l-1-3m202-242c1 0-1 3 2 3l9-5q27-14 28-46c15 28 20 52 57 55 50 5 67-10 85-55 0 25 16 49 41 54 14 3 60 2 74 0 10-2 28-12 30-23l-1-380q-13-16-33-18c-38-5-101-9-123 27s-37 82-59 119l-62-124a69 69 0 0 0 -46-22v4h-107v411zm1313-411h-29q47 23 80 60v-21c-5-5-48-39-51-39m52 0h-40l40 31zm-1584 4 2 407h10v-411h-10z"/><path d="m1696 458v-48c-4-24-75-71-98-76h-13q1-1-1-5a280 280 0 0 0 -276 54c-8 7-40 41-42 50-1 7 2 20 0 28 66-134 246-170 369-93 42 27 77 63 31 108q18 5 29 21v-20l-6-6c2-4 7-9 7-13m-1583-342h209v207h-209zm57 592c-13-1-33 23-35 36l4 1c11-22 50-24 60 0h5c-1-12-23-37-34-37"/><path d="m175 738v7h16v-6c-4-6-12-5-16-1m38-404h7v411h-7zm118 622h1254v8h-1254zm1254-2v-4c-67-2-54-83-126-82-23 0-49 14-58 35l3 4c9-19 33-33 54-34 69-3 59 84 127 81"/><path d="m1585 946v-3c-37-4-39-61 0-62v-4c-14-4-51 20-53 33-1 16 38 40 53 36m-1254 0c22-1 40-15 51-33-8-21-29-34-50-36l-1 3c35 4 35 59 0 62z"/><path d="m1570 889c-9 3-7 21 6 17 10-3 7-20-6-17m-1183 31-1-4c-15 17-31 32-55 34v4c22-1 46-13 56-34m1216-175c16 0 82-50 92-67v-21c-106 141-349 124-429-37v28c0 3 20 28 24 32 71 80 194 107 295 72v-7zm16 0h30l46-38v-18q-33 33-76 56m-23 11h207v207h-207zm63-11h25l11-11v-18zm-54 285q-3-15 1-28l6 6c1-21 15-26 34-24 32 4 44 24 65 44 8 8 23 15 26 26l5-2 1-4c16 7 50 9 54-14l2 2q10-16 4-36h-2"/><path d="m1605 1030-4 2q-2-12 0-25c1-8 10-20 17-24 11-6 35-7 44 2v-6l6-1c3 10 16 15 24 23 26 25 48 58 91 43q11-9 9-21l7 4c5-8-1-21 2-27m-194-1v-3z"/><path d="m1605 1030q-11 13-27 21c6 4 16-4 18-4l10 1 7-6c4-2 6 3 13-6l8-12 6-16c19-9 18 22 10 32l-5-6c-1 15-22 21-32 9l-2 5c11 6 22 10 34 2 4-3 1-7 6-5 9-10 11-26 27-27 10 2 22 10 18 22h4l-2 7c-4 6-12 1-16-2-6-7 0-13 4-19-13-5-14 7-12 16l-12-1-9 12c11 2 13-3 19-8 39 26 41-21 10-30v-6l-4-2-18 15q0-15-14-20c-19-3-48 44-68 49m-450-6c7 5 8 10 19 8-3-10-11-17-21-11 1-6 3-15-5-17l-6 1c11 12 3 29-13 21l-2-7c7-1 2-3 3-5 3-13 18-21 30-13 5 3 15 25 17 24 1 0 0-4 1-3 6 16 26 13 37 5v-5c-11 10-30 8-33-9l-5 6c-6-11-11-31 6-34l4 3c1 9 8 14 11 19l7 12c6 4 9 1 10 1 0 0 1 6 6 7 6 2 8-1 10-1 3 0 12 7 18 4-25-12-38-39-63-50-12-1-19 10-19 21-5-7-17-6-17-15l-4 1-1 7c-31 9-29 56 10 30m-121-57-7-5c-11 5-15-5-27-3l28 20c16 14 44 55 54 10 6 6 17 6 19 15l4-3v-6c14-2 24-19 19-33l-5-4c-11-3-18 7-24 7-4 0-11-12-19-8l8 12h14l-2 12c2 4 11 8 11 3-11-12-2-28 13-21l3 8h-4c4 10-8 19-17 20l-1 2q-7-1-13-6c-7-5-8-20-17-22"/><path d="m568 988c0 4 3 0 6 1 10 4 7 9 11 15q2 0 6 4c3 5 5 27 17 14 8-9 3-25-2-34m0 0-1-2m-37 2 1-5c11-7 28-9 36 3"/><path d="m568 988c13-9 31-8 34 10 5-1 3-6 4-10m-1-2 1 2m-76 57c10 7 11 1 16 2 3 1 12 8 18 3-26-4-69-85-83-28l-21-14c-2 11-3 5-9 10-8 7-16 18-12 29 5 14 22 1 30-2 7 5 9 10 19 8-3-10-11-17-21-12l1-12-6-5-5 2c9 11 7 23-9 23l-5-9h3c-4-13 8-18 17-23 19 2 18 20 30 29v-2m35-2h2"/><path d="m529 1043v-2c-12 6-12-7-16-13-3-5-11-9-12-19l-4-3-7 3c-8 7-3 26 2 34m37 0 1 2m0 0c-5 9-21 11-30 7l-7-7m0 0-1-2"/><path d="m529 1043c-13 11-28 8-34-9l-3 3v6m37 0 1 2m829 6c11 2 16-6 27-3l6-4c4 14 37 14 38-3l-2-7h-3c0 17-23 20-32 8l11-3c4-3 3-9 5-11l5-3c4-6 7-28 18-16 10 10 0 26-2 37 2 3 14-21 16-23 10-9 27-3 31 9 2 4-3 8 3 8l-2 7c-5 7-19-1-18-9l6-12c-11-6-13 8-11 16l-12-1-10 12c11 2 13-3 20-8 9 3 21 15 30 3 6-11-7-32-20-33v-7l-5-1-17 15-8-17c-17-13-42 23-56 34zm-224-958c1 9-31 16-38 0m35-2h2"/><path d="m1132 91c-10 14-28 6-32-8l-3 3v7m38 0-1-2m-308-1-1-4-4-3c-3 16-22 20-33 8l1 7c11 7 28 8 36-5"/><path d="m826 90-1 3m310 0 5 4q8 0 11-2c1 1 12 8 17 6l-25-20c7-9 3-27-2-38l-2 3c-4-22-39-21-55-13l-4-7c-5 11-16 15-24 22-23 21-34 44-69 48-12 1-22-5-26-4-5 0-12 5-24 4-36-2-46-24-69-46-8-8-22-12-24-24l-6 1v6c-16-8-49-9-55 12l-1-2c-8 11-7 25-5 38l4-1"/><path d="m781 80 1-29 6 6c0-21 13-25 31-24 37 3 52 28 75 51 6 5 18 10 18 19l6-2v-6c12 13 31 3 43 3 5 0 14 4 20 4 5 0 20-2 23-7v6l6 2c0-9 12-14 17-19 13-12 25-29 40-38 19-13 67-26 67 11l7-5v27c-11-8-25-30-40-29-10 2-15 12-15 20-5-7-17-5-17-14l-5 1 2 9c-14-4-28 19-22 31 9 12 20-1 30-3 6 4 9 11 19 8-3-10-11-17-22-12l1-12-6-5-5 2c9 11 7 23-9 23l-5-9h3c-4-13 8-18 17-23 19 2 18 20 30 29v-2m35-2h2"/><path d="m1132 91h-6c-6-3-5-10-8-14l-6-5-6-15-5-2c-18 5-8 27-4 38m38 0-1-2m-353-11c16-15 44-54 55-10l20-14 3 4-3 6 4-2c13 5 24 22 17 35l-10 3-19-8-16 9-3-1c5-10 9-17 22-12l-1-12 7-5 4 2c-10 11-5 27 12 22l3-8c-7 1-2-4-4-10l-8-8c-21-14-28 12-39 24v-2"/><path d="m781 80q-13 12-27 21c5 2 16-5 18-6q2 2 10 2c5-1 5-6 5-6 3-2 8 3 14-6l3-9q2 1 5-2c4-7 5-21 14-19 13 7 8 25 3 35m0 0-1 3m219-60-6-5-24 8c-7-5-10-12-19-10l9 13h12l1 15 10 1-6-12 2-7q6-7 16-4l3 9h-4c4 15-16 25-29 18-8-5-10-20-18-25 1 13 12 24 3 37-13 11-14-7-18-14q-4-4-6-4l-9-14c-7 1-7 11-9 14q-2-1-5 3l-7 16-6 2c-14-6-9-22-5-32l7 4c-1-8 8-14 16-15 13 2 33-5 34 15 5 5 11-16-9-19h-34q-10 2-12 13c1-17-12 14-16 17-11 9-23 3-31-6v-10h-4l3-8c5-6 19 2 18 10l-6 12c11 4 14-8 10-16l13 1 9-14c-9-2-12 5-19 10-9-4-22-16-30-3-3 14 5 29 20 33l2 7 19-14c6 29 26 22 42 5 14 16 37 25 40-5l20 14c5-1 3-6 4-7 0-1 6-2 7-4 9-8 15-15 12-29m-288 17q4 15-1 28l-6-6c0 21-13 25-31 24-34-2-50-27-73-48-7-7-19-12-21-22l-5 2-1 5c-16-9-51-8-54 13l-2-2q-10 18-3 38l-25 19c5 2 17-5 18-6q3 2 10 2c4-1 6-6 7-6l7-1c7-3 6-10 9-13l6-5c3-5 7-30 19-12 7 12-1 20-3 31l-2-6-4-2c0 16-22 21-31 8l-2 6c11 7 31 11 37-5q0 7 4 1c9-10 8-26 28-28-3 3 6 5 10 7 4 4 10 10 5 15l5 2-3 8c-18 4-23-9-13-22l-5-2-6 7 2 10h-14l-8 12c9 4 12-4 18-8 9 2 21 14 29 5 4-5 2-16 0-21-3-6-12-14-18-13v-6l-3-3-20 14c-9-45-40-3-56 11 2-10-1-21 3-32l5 8c2-26 20-26 41-23 31 6 44 29 65 49 6 6 18 10 19 20l5-1 1-5c17 7 51 8 55-15l2 4q8-18 3-38z"/><path d="m697 93h1v2h-1zm59-43q11-13 27-21c-6-3-16 4-17 5q-3-2-11-2c-4 1-5 6-7 7-5 1-5-4-12 5l-9 13-7 16-6 1c-13-6-9-23-3-33l5 5c1-15 22-21 31-8l1-7q-13-7-28-3l-8 10-2-3c-7 17-29 41-44 17-5-8 2-10-5-12l2-7c17-8 24 9 13 21l5 2 6-5v-12c10 5 18-2 21-13-10-2-13 5-19 10l-24-9c-17 8-1 38 14 38v7l5 1c0-9 12-7 17-14 9 44 39 5 55-9m-227-12c-11-12-30-8-33 8-6 0-4-5-4-8m37 0 1-2"/><path d="m492 38c8-16 24-14 37-6l1 4m-1 2c-13-2-12 8-16 14q-2 0-6 5c-4 6-5 25-17 15-8-7-3-27 2-34m37 0 1-2"/><path d="m492 38-1-3c-13 18-23 42-46 16l1-10h-5l3-8c16-8 23 10 12 21q8 5 11-3v-12h13l8-13c-10-2-13 5-19 10l-24-8c-16 9-1 35 14 38l1 6 21-13c10 47 45-2 61-16q10-8 22-13c-2-6-17 4-18 4-8 1-4-4-16 2m-216 65c5 2 17-5 18-6 3 0 11 6 15-2 9 15 41 14 39-8l-5-2c-1 17-23 20-32 7 12 5 12-8 16-13l6-5 6-15c24-6 12 26 9 38 8-5 9-17 16-23 8-7 22-5 29 4q4 6 2 13h4c-1 15-18 10-21-1l6-13c-11-6-15 8-10 15h-14l-8 13c8 3 15-9 20-9s12 10 23 8l6-7c4-12-7-30-20-30v-8l-4-1c-2 9-13 8-18 14-12-48-43 1-59 15zm1259-65c-12-11-35-9-49-4l-1-4-5-1c-3 9-14 14-21 20-23 22-39 47-74 49-17 1-30-4-30-24l-6 5-1-25-3-4q-5 14-1 28c1 3 5 14 6 7 5 22 37 20 53 15l3-4q-3 9 5 9c1-10 14-14 20-21 27-25 58-69 100-41l5 17 6-8 1 28 4 4q2-12 1-24c-1-5-8-18-12-21"/><path d="m425 47c-7-7-19-10-21-21l-5 2v4c-15-5-37-7-49 3-3 2-8 9-6 12l-3-2q-7 17-3 36c7-1 2-10 2-15l3-16 6 7c1-39 52-23 71-9q17 16 33 34c7 7 19 10 20 21l6-2v-5c15 9 52 9 55-14l2 4q10-18 3-38c-5 0 2 25-4 30l-6-6c-1 39-52 23-71 8-11-9-22-23-33-33m1028-11c-32 5-30 60 6 62 43 2 43-70-6-62"/><path d="m1683 640c4-12 5-109 1-122-3-10-18-24-29-24h-41c20-23 76-45 44-83-53-61-168-74-241-52-241 73-166 387 91 374 53-3 152-41 175-93m39 102h62c1-34-62-32-62 0"/><path d="m1773 737c7-6 0-15-10-13-12 3-1 21 10 13m-699-592c-11 2-9 20 3 18 10-1 9-19-3-18"/><path d="m1086 137c-36 3-34 55-5 61 49 10 51-65 5-61m-14 769c10-3 7-20-6-17-9 3-7 21 6 17"/><path d="m1092 942c32-9 28-68-16-61-38 6-28 72 16 61m-524-36c10-3 7-20-6-17-9 3-7 21 6 17"/><path d="m581 943c40-2 38-70-9-62-35 5-29 64 9 62m606-40c-12 24 21 48 40 24 17-21-6-50-30-38 6 7 10 3 17 5 17 5 14 34-7 33-16-1-12-16-20-24"/><path d="m1211 943c39-2 38-70-9-62-34 5-30 64 9 62"/><path d="m1190 893c-7 7 3 17 10 12 7-7-3-19-10-12m-367-748c-12 2-10 18 0 18 12 1 12-19 0-18"/><path d="m834 137c-40 3-35 67 8 62 36-5 34-65-8-62m125 0c-35 3-33 57-3 62 48 7 49-67 3-62"/><path d="m947 148c-9 2-6 17 5 14 7-2 5-16-5-14"/><path d="m983 182c14-22-10-49-32-36 6 6 12 2 18 5 20 7 9 41-14 31-11-5-6-18-16-22-8 27 27 48 44 22m-413-37c-11 2-9 20 3 18 11-1 9-19-3-18"/><path d="m583 137c-38 3-35 57-4 62 47 7 48-66 4-62m735 769c16 5 16-21 0-17-7 2-8 15 0 17"/><path d="m1336 943c40-1 40-69-7-62-36 5-31 63 7 62m-506 0c42 1 42-69-5-62-31 5-30 60 6 62"/><path d="m814 906c16 5 16-21 0-17-7 2-8 15 0 17m512-761c-10 2-10 19 2 18 13-1 9-20-2-18"/><path d="m1338 137c-40 3-35 67 8 62 35-5 34-65-8-62m125 0c-35 3-33 57-3 62 48 7 49-67 3-62"/><path d="m1485 183c17-22-7-51-30-37 9 7 20 0 26 12 10 22-19 35-29 16-3-5-1-12-9-14-7 26 24 47 42 23"/><path d="m1451 148c-7 2-7 12-1 14 13 4 14-16 1-14m-768 755c-12 25 22 47 40 24 17-21-6-50-30-38 6 7 10 3 17 5 17 5 14 34-7 33-16-1-12-16-20-24"/><path d="m686 904c7 7 17-4 10-11-7-6-17 5-10 11"/><path d="m707 943c39-2 38-70-9-62-34 5-30 64 9 62m488-783c7 8 17-2 12-10-6-7-18 3-12 10"/><path d="m1233 184c17-21-6-51-30-38 8 7 22 0 27 13 7 16-10 31-25 21-9-6-4-16-13-21-10 25 22 48 41 25"/><path d="m1210 137c-33 4-33 55-3 61 49 10 51-67 3-61m-503 0c-38 3-35 68 10 62 34-5 33-66-10-62"/><path d="m692 150c-6 8 4 18 11 10 6-7-6-17-11-10"/><path d="m699 146c9 7 21 0 27 13 7 17-11 31-25 21-8-6-5-16-14-21-7 22 15 44 36 30 27-17 4-59-24-43m-251 16c7-2 5-16-5-14-9 2-6 17 5 14"/><path d="m435 160c-7 24 21 46 41 25 19-20-4-53-29-39 9 6 22 1 27 13 9 21-20 35-31 14-2-5 1-10-8-13"/><path d="m464 199c35-4 34-67-9-62-37 4-35 67 9 62m469 704c-7 24 20 46 40 26 21-20-3-52-28-41 7 10 21 1 27 14 7 16-9 31-24 22-11-6-4-17-15-21-10 25 22 48 41 25"/><path d="m943 906c10 0 9-15 0-15-10 1-9 16 0 15"/><path d="m955 943c43 2 43-70-6-62-31 5-29 60 6 62m-504 0c44 2 43-70-6-62-31 5-30 60 6 62"/><path d="m444 904c7-6-3-17-10-11-7 7 3 18 10 11"/><path d="m429 903c-11 43 54 43 48 4-2-15-23-29-35-17 8 6 20 0 25 11 11 21-19 36-29 17-3-6-1-11-9-15m1024-22c-32 5-30 60 6 62 43 2 43-70-6-62"/><path d="m1447 891c-13 1-6 22 5 13 5-5 1-13-5-13"/><path d="m1449 889c8 9 19-1 26 12 9 16-8 32-23 23-11-6-4-17-15-21-6 22 15 44 36 29 27-18 3-57-24-43m-1269-365c-11 2-6 18 7 13 9-3 4-15-7-13"/><path d="m164 517c-38 4-33 52 7 51 43-2 38-56-7-51m-10-65c19 12 50-2 38-26-8 8-1 18-13 23l-13 1c-10-3-16-12-9-22 7-8 15-2 21-11-22-8-49 18-24 35"/><path d="m179 419c-10 2-1 17 7 11 7-5 0-13-7-11"/><path d="m160 461c51 10 55-55 4-50-33 4-35 44-4 50m4 162c-11 1-24 8-26 20-5 39 64 39 63 4-2-19-20-26-37-24"/><path d="m179 630c-10 3-1 17 7 11 7-5 0-13-7-11"/><path d="m192 638c-6 4-3 10-6 15-3 10-20 11-27 5-9-7-6-19 4-23 6-2 10 0 15-7-20-7-47 13-28 32 17 18 54 3 42-22m1582-117c-9-9-24 6-11 11 8 3 17-5 11-11"/><path d="m1748 512c-8 1-19 6-23 13-17 38 47 49 58 19 5-24-14-34-35-32m34-67c10-25-12-38-35-36-58 8-3 81 35 36"/><path d="m1776 424c-9 7 0 17-14 22-10 4-26-1-24-15 3-13 19-7 24-17q-18-4-30 9l-4 5c-3 37 63 31 48-4"/><path d="m1762 417c-6 2-4 12 4 11 11 0 8-15-4-11m1 206c-9 2-4 14 6 10 8-3 3-13-6-10"/><path d="m1747 663c50 6 49-53 1-48-35 4-34 45-1 48"/><path d="m1756 659c14-1 30-15 20-29-7 4-4 9-6 15s-15 10-21 7c-10-3-15-13-7-22 5-5 14-3 20-9-8-5-24 0-30 6-13 17 6 33 24 32m-829-134 8 18-8 12 21-8-8 20 19-7-6 15 9-5 7 5-6-15 19 7-7-20 19 8-7-13 7-17-19 8 7-20-19 8 5-16-7 5-8-6 6 17-19-8 7 19zm-674 178q0 9 11 11c7 2 50 2 57 1l7-4 3-4 3-155 8 1 76 158c7 6 33 4 43 2l78-159 6-3 3 2 3 154q3 7 9 7c9 2 47 2 56 1q13-2 14-14v-319q0-14-13-16c-12-2-60-2-72 0q-7 1-10 5l-90 181-9-1-90-181q-3-4-8-4c-13-2-59-2-72 0q-6 0-10 4l-3 9zm1049-113c40 110 186 146 286 99 18-8 72-44 75-63 2-13 2-84 0-97l-4-8q-3-4-8-4c-47-7-112 5-161 0l-10 9c5 19-12 51 16 54 25 3 55-2 80 0 16 7-4 23-11 28-43 33-109 32-150-3-93-81 36-207 147-135 8 6 14 17 24 15 4-1 56-44 57-48 3-9-10-16-16-21-39-33-96-47-147-45-110 5-222 101-178 219"/><path d="m1568 499c-45-61-176-34-166 51 7 63 105 83 150 46h-64c-34 0-37-97 2-97z"/><path d="m1488 494h65c-35-34-109-28-136 15-41 65 53 121 109 93h-39c-41 0-43-108 1-108"/><path d="m1456 493c-37 17-49 61-12 87-1-30-7-62 12-87"/><path d="m1438 515c-13 12-14 37-1 50z"/></g></svg>

      
      <!-- üîºüîºüîº PASTE YOUR SVG PATHS HERE üîºüîºüîº -->
    </g>
  </svg>
  
  <h2>LOADING...</h2>
</div>

<!-- Fullscreen Wall Container (independent of main container) -->
<div id="wall-fullscreen"></div>
<div id="wall-click-text">click + drag</div>
<button id="backButtonWall">‚Üê Back</button>

<!-- Wall Content Area (revealed after knockdown) -->
<div id="wall-content">
  <div id="wall-content-text">work exp goes here</div>
  <button id="backButtonContent" class="backBtn">‚Üê Back to Home</button>
</div>

<div id="container">
  <video id="bgVideo" muted playsinline webkit-playsinline>
    <source src="assets/background/mog.webm" type="video/webm">
  </video>
  <canvas id="bgFreeze"></canvas>

  <!-- Home -->
  <div id="mainContent">
    <div class="icon" id="icon-art"      role="button" aria-label="Art Portfolio" tabindex="0"></div>
    <div class="icon" id="icon-edu"      role="button" aria-label="Education"     tabindex="0"></div>
    <div class="icon" id="icon-contacts" role="button" aria-label="Contacts"      tabindex="0"></div>
    <div class="icon" id="icon-work"     role="button" aria-label="Work"          tabindex="0"></div>

    <svg viewBox="0 0 1920 1080" aria-hidden="true">
      <defs>
        <mask id="eyeMask" maskUnits="userSpaceOnUse">
          <image href="assets/sprites/mask.png" x="0" y="0" width="1920" height="1080" preserveAspectRatio="none"/>
        </mask>
      </defs>
      <g id="eyeContainer" transform="translate(960,535) scale(1) translate(-960,-540)">
        <g id="eyeOffset">
          <image href="assets/sprites/White.png" x="0" y="0" width="1920" height="1080"/>
          <g mask="url(#eyeMask)">
            <g id="eyeMove">
              <image href="assets/sprites/Iris.png" x="0" y="0" width="1920" height="1080"/>
            </g>
            <g id="reflectionsMove">
              <image id="reflections" href="assets/sprites/reflections.png" x="-690" y="-487" width="3090" height="2390"/>
            </g>
            <rect id="blinkLid" x="0" y="0" width="1920" height="1080" fill="black"/>
          </g>
        </g>
      </g>
    </svg>
  </div>

  <!-- Contacts Page -->
  <div id="contactsPage">
    <!-- Canvas for eye animation -->
    <canvas class="contacts-canvas" id="contactsCanvas"></canvas>
    
    <!-- Veins overlay -->
    <div class="veins-overlay"></div>
    
    <!-- Content -->
    <div class="contacts-content">
      <div class="cards-container">
        <!-- Title Box -->
        <h1 class="contacts-title">
          <span class="title-split">
            <span class="title-top">CONTACT</span>
            <span class="title-bottom">CONTACT</span>
          </span>
        </h1>
        
        <!-- Body Box -->
        <div class="body-box">
          <div class="body-line" data-hover-pattern="email">
            <span class="label">Email:</span>
            <span class="value">mozharalfares@gmail.com</span>
          </div>
          <div class="body-line" data-hover-pattern="phone">
            <span class="label">Phone:</span>
            <span class="value">+09 542 448 4629</span>
          </div>
          <div class="body-line" data-hover-pattern="social">
            <span class="label">Socials:</span>
            <span class="value">ig @mogart6</span>
          </div>
        </div>
      </div>
      
      <button class="contacts-back-btn" id="backButtonContacts">‚Üê BACK TO HOME</button>
    </div>
  </div>

  <!-- Education Page -->
  <div id="eduPage">
    <h1>Education</h1>
    <p>This is the education page content.</p>
    <p>Coming soon!</p>
    <button class="backButton" id="backButtonEdu">‚Üê Back to Home</button>
  </div>

  <!-- Work Page moved to #wall-fullscreen (independent of container) -->

  <!-- Transition Video -->
  <video id="transitionVideo" muted playsinline webkit-playsinline>
    <source src="" type="video/webm">
  </video>
</div>

<script>
'use strict';

/* ========================================================================
   DEVICE DETECTION
   ======================================================================== */
const DeviceDetector = {
  isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
  isTouchDevice: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
  init() {
    console.log('üì± Device type:', this.isMobile ? 'Mobile' : 'Desktop');
    console.log('üëÜ Touch support:', this.isTouchDevice ? 'Yes' : 'No');
  }
};

/* ========================================================================
   CONFIG
   ======================================================================== */
const CONFIG = {
  ASSETS: {
    CRITICAL: [
      'assets/sprites/White.png','assets/sprites/Iris.png','assets/sprites/mask.png','assets/sprites/reflections.png',
      'assets/sprites/icon-art.png','assets/sprites/icon-contacts.png',
      'assets/sprites/icon-edu.png','assets/sprites/icon-work.png',
      'assets/transitions/contacts/transition.webm',
      'assets/transitions/contacts/reverse.webm',
      'assets/transitions/edu/edu_transition.webm',
      'assets/transitions/edu/edu_reverse.webm',
      'mog.png'
    ]
  },

  TIMING: {
    CONTACTS_ICON_FADE:     2168,   // ms into contacts forward video ‚Üí icons start fading
    EDU_ICON_FADE:          1006,   // ms into edu forward video ‚Üí icons start fading
    EDU_REVERSE_ICON_FADE:  725,    // ms into edu reverse video ‚Üí icons fade back in
    BLINK_AFTER_TRANSITION: 150,
    EYE_ACTIVATE_TIME:      4.037,  // seconds into bgVideo
    LOADING_DELAY:          500,
    LOADING_TIMEOUT:        5000,   // Force load after 5 seconds
    BLINK_SPEED:            150,
    DOUBLE_BLINK_DELAY:     180,
    BLINK_MIN_DELAY:        2400,
    BLINK_MAX_DELAY:        5000,
    EYE_FALLBACK_TIMEOUT:   8000
  },

  LAYOUT: { DESIGN_WIDTH: 1920, DESIGN_HEIGHT: 1080 },

  ICON_SETTINGS: {
    "icon-art":      { x: 220,  y: 810, scale: 2.5  },
    "icon-edu":      { x: 225,  y: 225, scale: 3  },
    "icon-work":     { x: 1690, y: 235, scale: 1.77 },
    "icon-contacts": { x: 1685, y: 810, scale: 2.2 }
  },

  TRANSITION: {
    OFFSET: 1,
    CONTACTS_FORWARD: 'assets/transitions/contacts/transition.webm',
    CONTACTS_REVERSE: 'assets/transitions/contacts/reverse.webm',
    EDU_FORWARD:      'assets/transitions/edu/edu_transition.webm',
    EDU_REVERSE:      'assets/transitions/edu/edu_reverse.webm'
  },

  EYE: { DOUBLE_BLINK_CHANCE: 0.3, REFLECTION_MOVEMENT: 0.1 },

  // All GSAP durations live here (in seconds)
  GSAP: {
    CONTAINER_FADE:          1.5,    // Duration for container fade-in after loading
    ICON_FADE:               0.6,
    EYE_FADE_FAST:           0.15,   // eye ‚Üî transition video hand-off
    EYE_FADE_ACTIVATE:       0.3,    // very first eye appearance
    EYE_RESET_DURATION:      0.8,    // eye gliding back to center
    PAGE_CONTENT_DURATION:   0.4,    // each child fade
    PAGE_CONTENT_STAGGER:    0.13,   // delay between children
    PAGE_CONTENT_DELAY:      0.15    // initial delay before first child
  },

  DEBUG: false
};

/* ========================================================================
   UTILS
   ======================================================================== */
const Utils = {
  log: (...args) => { if (CONFIG.DEBUG) console.log(...args); },
  wait: (ms) => new Promise(r => setTimeout(r, ms)),
  getElement: (id) => {
    const el = document.getElementById(id);
    if (!el) console.error(`Element not found: ${id}`);
    return el;
  }
};

/* ========================================================================
   PRELOADER - FIXED VERSION
   ======================================================================== */
const Preloader = {
  loadedCount: 0,
  totalAssets: CONFIG.ASSETS.CRITICAL.length,
  forceLoadTriggered: false,
  loadingComplete: false,

  init() {
    const loadingScreen = Utils.getElement('loadingScreen');
    const container = Utils.getElement('container');

    // Preload images and videos
    CONFIG.ASSETS.CRITICAL.forEach(src => {
      if (src.endsWith('.webm') || src.endsWith('.mp4')) {
        this.preloadVideo(src);
      } else {
        this.preloadImage(src);
      }
    });

    this.updateProgress = () => {
      this.loadedCount++;
      const pct = Math.round((this.loadedCount / this.totalAssets) * 100);
      console.log(`Loading assets... ${pct}%`);

      if (this.loadedCount === this.totalAssets && !this.forceLoadTriggered) {
        this.forceLoadTriggered = true; // Prevent double-call race condition
        this.completeLoading(loadingScreen, container);
      }
    };

    // Force load after timeout
    setTimeout(() => {
      if (!this.forceLoadTriggered) {
        console.warn('‚ö†Ô∏è Loading timeout - forcing page load');
        this.forceLoadTriggered = true;
        this.completeLoading(loadingScreen, container);
      }
    }, CONFIG.TIMING.LOADING_TIMEOUT);
  },

  async completeLoading(loadingScreen, container) {
    // Initialize wall FIRST (during loading) so it's ready when needed
    console.log('üéÆ [PRELOAD] Starting wall initialization...');
    await TransitionManager.initializeWall();
    console.log('‚úÖ [PRELOAD] Wall ready!');

    // Fade out loading text first
    gsap.to(loadingScreen.querySelector('h2'), {
      opacity: 0,
      duration: 0.2,
      ease: 'power2.inOut'
    });
    
    // Fade out comets
    gsap.to('#loadingSvg', { 
      opacity: 0, 
      duration: 0.3, 
      ease: 'power2.inOut'
    });
    
    // Then fade in the container after text is gone
    gsap.to(container, {
      opacity: 1,
      duration: CONFIG.GSAP.CONTAINER_FADE,
      delay: 0.25,
      ease: 'power2.inOut',
      onComplete: () => {
        LoadingCometAnimation.stop();
        loadingScreen.style.display = 'none';
        // Start the background video once loading is done
        Utils.getElement('bgVideo').play();
        // Mark loading as complete so eye can activate
        Preloader.loadingComplete = true;
      }
    });
  },

  preloadImage(src) {
    const i = new Image();
    i.onload = () => this.updateProgress();
    i.onerror = () => {
      console.warn(`Failed to load: ${src}`);
      this.updateProgress(); // Still count it to avoid infinite loading
    };
    i.src = src;
  },

  preloadVideo(src) {
    const v = document.createElement('video');
    v.preload = 'auto';
    v.onloadeddata = () => {
      console.log(`‚úÖ Video loaded: ${src}`);
      this.updateProgress();
    };
    v.onerror = () => {
      console.warn(`Failed to load video: ${src}`);
      this.updateProgress(); // Still count it to avoid infinite loading
    };
    v.src = src;
    v.load();
  }
};

/* ========================================================================
   ICON POSITIONING
   ======================================================================== */
const IconPositioner = {
  positionIcons() {
    const container = Utils.getElement('container');
    const cw = container.offsetWidth, ch = container.offsetHeight;
    for (const id in CONFIG.ICON_SETTINGS) {
      const el = Utils.getElement(id);
      if (!el) continue;
      const s = CONFIG.ICON_SETTINGS[id];
      const scale = Math.min(cw / CONFIG.LAYOUT.DESIGN_WIDTH, ch / CONFIG.LAYOUT.DESIGN_HEIGHT);
      el.style.left = (s.x / CONFIG.LAYOUT.DESIGN_WIDTH) * 100 + '%';
      el.style.top  = (s.y / CONFIG.LAYOUT.DESIGN_HEIGHT) * 100 + '%';
      el.style.transform = `translate(-50%, -50%) scale(${s.scale * scale})`;
    }
  },
  init() {
    this.positionIcons();
    window.addEventListener('resize', () => this.positionIcons());
  }
};

/* ========================================================================
   SPRITE SHEET ICON - SIMPLIFIED VERSION
   ======================================================================== */
class SpriteSheetIcon {
  constructor(element, frameCount, frameWidth, frameHeight, spriteWidth, holdFrame = null, speeds = {}) {
    this.element = element;
    this.frameCount = frameCount;
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.spriteWidth = spriteWidth;
    this.holdFrame = holdFrame;
    
    // Animation state
    this.currentFrame = 0;
    this.targetFrame = 0;
    this.isHovering = false;
    this.isHolding = false;
    this.isTouching = false;
    
    // SIMPLIFIED SPEEDS - just forward, reverse, loop
    this.forwardSpeed = speeds.forwardSpeed || 0.5;
    this.reverseSpeed = speeds.reverseSpeed || 0.3;
    this.loopSpeed = speeds.loopSpeed || 0.2;
    
    this.animationFrame = null;
    
    this.setupListeners();
    this.animate();
  }

  setupListeners() {
    this.element.addEventListener('mouseenter', () => {
      if (DeviceDetector.isTouchDevice) return;
      this.isHovering = true;
      this.element.style.filter = 'drop-shadow(0 0 10px rgba(0,0,0,1)) drop-shadow(0 0 18px rgba(0,0,0,1)) drop-shadow(0 0 28px rgba(0,0,0,1))';
      if (this.holdFrame !== null) {
        this.targetFrame = this.holdFrame;
      }
    });

    this.element.addEventListener('mouseleave', () => {
      if (DeviceDetector.isTouchDevice) return;
      this.isHovering = false;
      this.isHolding = false;
      this.targetFrame = 0;
      this.element.style.filter = 'drop-shadow(0 0 0px rgba(0,0,0,0))';
    });

    this.element.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.isTouching = this.isHovering = true;
      this.element.classList.add('touching');
      this.element.style.filter = 'drop-shadow(0 0 10px rgba(0,0,0,1)) drop-shadow(0 0 18px rgba(0,0,0,1)) drop-shadow(0 0 28px rgba(0,0,0,1))';
      if (this.holdFrame !== null) {
        this.targetFrame = this.holdFrame;
      }
    }, { passive: false });

    this.element.addEventListener('touchend', (e) => {
      e.preventDefault();
      this.element.click();
      this.isHovering = this.isHolding = this.isTouching = false;
      this.targetFrame = 0;
      this.element.style.filter = 'drop-shadow(0 0 0px rgba(0,0,0,0))';
      this.element.classList.remove('touching');
    }, { passive: false });

    this.element.addEventListener('touchcancel', () => {
      this.isHovering = this.isHolding = this.isTouching = false;
      this.targetFrame = 0;
      this.element.style.filter = 'drop-shadow(0 0 0px rgba(0,0,0,0))';
      this.element.classList.remove('touching');
    });
  }

  updateBackgroundPosition() {
    const frameIndex = Math.floor(this.currentFrame);
    const xPos = frameIndex * this.frameWidth;
    this.element.style.backgroundPosition = `-${xPos}px 0`;
  }

  animate() {
    if (this.isHovering) {
      // Forward animation
      if (this.holdFrame === null) {
        // Loop continuously (work icon)
        this.currentFrame += this.loopSpeed;
        if (this.currentFrame >= this.frameCount - 1) {
          this.currentFrame = 0;
        }
      } else {
        // Animate to hold frame (art, contacts, edu)
        if (!this.isHolding && Math.abs(this.currentFrame - this.holdFrame) < 0.5) {
          this.isHolding = true;
          this.currentFrame = this.holdFrame;
          this.targetFrame = this.holdFrame;
        }
        
        if (!this.isHolding) {
          const distance = Math.abs(this.targetFrame - this.currentFrame);
          const speed = distance < 2 ? 0.3 : this.forwardSpeed;
          this.currentFrame += (this.targetFrame - this.currentFrame) * speed;
          
          if (distance < 0.1) {
            this.currentFrame = this.targetFrame;
          }
        }
      }
    } else {
      // Reverse animation
      if (this.currentFrame > 0) {
        this.currentFrame -= this.reverseSpeed;
        if (this.currentFrame < 0) {
          this.currentFrame = 0;
        }
      }
    }

    this.updateBackgroundPosition();
    this.animationFrame = requestAnimationFrame(() => this.animate());
  }

  reset() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    this.isHovering = this.isHolding = this.isTouching = false;
    this.targetFrame = this.currentFrame = 0;
    this.element.style.filter = 'drop-shadow(0 0 0px rgba(0,0,0,0))';
    this.element.classList.remove('touching');
    this.updateBackgroundPosition();
    this.animate();
  }
}

/* ========================================================================
   TRANSITION MANAGER
   ======================================================================== */
const TransitionManager = {
  isTransitioning: false,
  transitionVideo: null,
  contactsPage: null,
  eduPage: null,
  mainContent: null,
  wallInstance: null,

  init() {
    this.transitionVideo = Utils.getElement('transitionVideo');
    this.contactsPage    = Utils.getElement('contactsPage');
    this.eduPage         = Utils.getElement('eduPage');
    this.mainContent     = Utils.getElement('mainContent');
    
    console.log('üé¨ [TRANSITION MANAGER] Initialized with paths:', {
      CONTACTS_FORWARD: CONFIG.TRANSITION.CONTACTS_FORWARD,
      CONTACTS_REVERSE: CONFIG.TRANSITION.CONTACTS_REVERSE,
      EDU_FORWARD: CONFIG.TRANSITION.EDU_FORWARD,
      EDU_REVERSE: CONFIG.TRANSITION.EDU_REVERSE
    });
    
    this.setupContactsTransition();
    this.setupEduTransition();
    this.setupWorkTransition();
    this.setupReverseTransition(Utils.getElement('backButtonContacts'), 'contacts');
    this.setupReverseTransition(Utils.getElement('backButtonEdu'),      'edu');
    // Wall back button is set up in initializeWall() - not here
    this.setupContentBackButton();
  },

  setupContentBackButton() {
    const backButton = Utils.getElement('backButtonContent');
    if (!backButton) return;
    
    backButton.addEventListener('click', async () => {
      if (this.isTransitioning) return;
      this.isTransitioning = true;
      try {
        // Fade out content
        const wallContent = Utils.getElement('wall-content');
        await new Promise(resolve => {
          gsap.to(wallContent, {
            opacity: 0,
            duration: 0.6,
            ease: 'power2.in',
            onComplete: resolve
          });
        });

        wallContent.classList.remove('visible');

        // Show home page
        this.mainContent.style.display = 'flex';
        const bg = Utils.getElement('bgVideo');
        const eyeOffset = Utils.getElement('eyeOffset');
        const icons = document.querySelectorAll('.icon');
        
        bg.style.display = 'block';
        gsap.set([bg, eyeOffset, ...icons], { opacity: 0 });
        
        await new Promise(resolve => {
          gsap.to([bg, eyeOffset, ...icons], {
            opacity: 1,
            duration: 0.6,
            ease: 'power2.out',
            onComplete: resolve
          });
          icons.forEach(i => i.classList.remove('icon-hidden'));
        });

        // Reset icon animations
        setTimeout(() => {
          Object.values(window.iconInstances).forEach(inst => inst.reset());
        }, 100);

        console.log('‚úÖ [WALL CONTENT] Back to home');
      } catch (e) {
        console.error('Content back transition error:', e);
      } finally { this.isTransitioning = false; }
    });
  },

  // NOTE: setupWorkBackButton removed - was dead code for unused #backButtonWork element
  // The actual wall back button (#backButtonWall) is handled in initializeWall()

  loadLibrary(url, globalName) {
    return new Promise((resolve, reject) => {
      // Check if library is already loaded
      if (window[globalName]) {
        console.log(`‚úÖ Library already cached: ${globalName}`);
        resolve(window[globalName]);
        return;
      }

      const script = document.createElement('script');
      script.src = url;
      script.onload = () => {
        console.log(`‚úÖ Script loaded: ${url}`);
        setTimeout(() => {
          const lib = window[globalName];
          if (lib) {
            console.log(`‚úÖ Library available as window.${globalName}`);
            resolve(lib);
          } else {
            reject(new Error(`Library ${globalName} not found after loading ${url}`));
          }
        }, 100);
      };
      script.onerror = () => reject(new Error(`Failed to load ${url}`));
      document.head.appendChild(script);
    });
  },

  async playTransitionVideo(path) {
    console.log('üé¨ [TRANSITION] Attempting to load video:', path);
    const v = this.transitionVideo, src = v.querySelector('source');
    
    v.style.transform = `translateY(${CONFIG.TRANSITION.OFFSET}px)`;
    src.src = path;
    
    console.log('üé¨ [TRANSITION] Video element src set to:', src.src);
    console.log('üé¨ [TRANSITION] Full resolved URL:', new URL(src.src, window.location.href).href);
    
    // Add error listener
    v.onerror = (e) => {
      console.error('‚ùå [TRANSITION] Video error:', e);
      console.error('‚ùå [TRANSITION] Video error details:', {
        error: v.error,
        networkState: v.networkState,
        readyState: v.readyState
      });
    };
    
    src.onerror = (e) => {
      console.error('‚ùå [TRANSITION] Source error:', e);
    };
    
    v.onloadstart = () => console.log('‚è≥ [TRANSITION] Video load started');
    v.onloadedmetadata = () => console.log('‚úÖ [TRANSITION] Video metadata loaded');
    v.oncanplay = () => console.log('‚úÖ [TRANSITION] Video can play');
    
    v.load();
    v.style.display = 'block';
    v.currentTime = 0;
    
    try {
      await v.play();
      console.log('‚ñ∂Ô∏è [TRANSITION] Video playing successfully');
    } catch (error) {
      console.error('‚ùå [TRANSITION] Play failed:', error);
      throw error;
    }
    
    return v.play();
  },

  waitForVideoEnd() {
    return new Promise(resolve => { this.transitionVideo.onended = resolve; });
  },

  fadeInPageContent(page) {
    const kids = Array.from(page.children);
    gsap.set(kids, { opacity: 0, y: 12 });
    gsap.to(kids, {
      opacity: 1, y: 0,
      duration: CONFIG.GSAP.PAGE_CONTENT_DURATION,
      stagger:  CONFIG.GSAP.PAGE_CONTENT_STAGGER,
      delay:    CONFIG.GSAP.PAGE_CONTENT_DELAY,
      ease:     'power2.out'
    });
  },

  fadeIconsOut() {
    const icons = document.querySelectorAll('.icon');
    icons.forEach(i => i.classList.add('icon-hidden'));
    gsap.to(icons, { opacity: 0, duration: CONFIG.GSAP.ICON_FADE, ease: 'power2.in' });
  },

  fadeIconsIn(delaySeconds = 0) {
    const icons = document.querySelectorAll('.icon');
    gsap.to(icons, {
      opacity: 1,
      duration: CONFIG.GSAP.ICON_FADE,
      delay:    delaySeconds,
      ease:     'power2.out',
      onStart:  () => icons.forEach(i => i.classList.remove('icon-hidden'))
    });
  },

  setupContactsTransition() {
    Utils.getElement('icon-contacts').addEventListener('click', async () => {
      console.log('üëÜ [CONTACTS] Icon clicked');
      if (this.isTransitioning) {
        console.log('‚ö†Ô∏è [CONTACTS] Already transitioning, ignoring click');
        return;
      }
      this.isTransitioning = true;
      console.log('üöÄ [CONTACTS] Starting transition');
      try {
        EyeSystem.blinkOnce();
        await Utils.wait(CONFIG.TIMING.BLINK_AFTER_TRANSITION);
        await EyeSystem.resetToCenter();

        await this.playTransitionVideo(CONFIG.TRANSITION.CONTACTS_FORWARD);
        setTimeout(() => this.fadeIconsOut(), CONFIG.TIMING.CONTACTS_ICON_FADE);
        await this.waitForVideoEnd();

        this.mainContent.style.display      = 'none';
        this.transitionVideo.style.display  = 'none';
        this.contactsPage.style.display     = 'flex';
        Utils.getElement('bgFreeze').style.display = 'block';

        this.fadeInPageContent(this.contactsPage);
        ContactsEyeSystem.start();
      } catch (e) {
        console.error('Contacts transition error:', e);
        this.handleTransitionError('contacts');
      } finally { this.isTransitioning = false; }
    });
  },

  setupEduTransition() {
    Utils.getElement('icon-edu').addEventListener('click', async () => {
      console.log('üëÜ [EDU] Icon clicked');
      if (this.isTransitioning) {
        console.log('‚ö†Ô∏è [EDU] Already transitioning, ignoring click');
        return;
      }
      this.isTransitioning = true;
      console.log('üöÄ [EDU] Starting transition');
      try {
        EyeSystem.blinkOnce();
        await Utils.wait(CONFIG.TIMING.BLINK_AFTER_TRANSITION);
        await EyeSystem.resetToCenter();

        Utils.getElement('bgFreeze').style.display = 'none';
        gsap.to(Utils.getElement('eyeOffset'), { opacity: 0, duration: CONFIG.GSAP.EYE_FADE_FAST, ease: 'power2.in' });

        this.transitionVideo.classList.add('under-icons');
        await this.playTransitionVideo(CONFIG.TRANSITION.EDU_FORWARD);
        setTimeout(() => this.fadeIconsOut(), CONFIG.TIMING.EDU_ICON_FADE);
        await this.waitForVideoEnd();

        this.transitionVideo.classList.remove('under-icons');
        this.mainContent.style.display     = 'none';
        this.transitionVideo.style.display = 'none';
        this.eduPage.style.display         = 'flex';

        this.fadeInPageContent(this.eduPage);
      } catch (e) {
        console.error('Edu transition error:', e);
        this.handleTransitionError('edu');
      } finally { this.isTransitioning = false; }
    });
  },

  setupWorkTransition() {
    Utils.getElement('icon-work').addEventListener('click', async () => {
      console.log('üëÜ [WORK] Icon clicked');
      if (this.isTransitioning) {
        console.log('‚ö†Ô∏è [WORK] Already transitioning, ignoring click');
        return;
      }
      this.isTransitioning = true;
      console.log('üöÄ [WORK] Starting transition');
      try {
        EyeSystem.blinkOnce();
        await Utils.wait(CONFIG.TIMING.BLINK_AFTER_TRANSITION);
        await EyeSystem.resetToCenter();

        // Fade out home elements + fade in wall simultaneously
        const eyeOffset = Utils.getElement('eyeOffset');
        const icons = document.querySelectorAll('.icon');
        const bg = Utils.getElement('bgVideo');
        const wallFullscreen = Utils.getElement('wall-fullscreen');
        const clickText = Utils.getElement('wall-click-text');
        const backBtn = Utils.getElement('backButtonWall');
        
        // Enable wall interactions (visibility only - physics stays off until animation completes)
        wallFullscreen.style.pointerEvents = 'auto';
        backBtn.style.pointerEvents = 'auto';
        backBtn.style.visibility = 'visible';
        clickText.style.visibility = 'visible';
        
        // Show wall immediately at full opacity (underneath home page)
        gsap.set(wallFullscreen, { opacity: 1 });
        gsap.set([backBtn, clickText], { opacity: 0 });
        
        await new Promise(resolve => {
          // Fade out home elements to reveal wall underneath
          gsap.to([eyeOffset, ...icons, bg], {
            opacity: 0,
            duration: 0.6,
            ease: 'power2.in'
          });
          // Fade in UI elements on top of wall
          gsap.to([clickText, backBtn], {
            opacity: 1,
            duration: 0.6,
            ease: 'power2.in',
            onComplete: () => {
              // NOW enable wall physics after animation is done
              console.log('üîç [WORK] Checking wallInstance:', this.wallInstance);
              console.log('üîç [WORK] setActive function:', this.wallInstance?.setActive);
              if (this.wallInstance?.setActive) {
                this.wallInstance.setActive(true);
                this.wallInstance.resetDragState?.();
                console.log('‚úÖ Wall physics now active');
              } else {
                console.error('‚ùå wallInstance.setActive not found!');
              }
              resolve();
            }
          });
          icons.forEach(i => i.classList.add('icon-hidden'));
        });

        this.mainContent.style.display = 'none';
        bg.style.display = 'none';

        console.log('‚úÖ [WORK] Work page ready');
      } catch (e) {
        console.error('Work transition error:', e);
        this.handleTransitionError('work');
      } finally { this.isTransitioning = false; }
    });
  },

  async drawGridTransition() {
    const cols = 16;
    const rows = 9;
    const gridOverlay = document.createElement('canvas');
    gridOverlay.width = window.innerWidth;
    gridOverlay.height = window.innerHeight;
    gridOverlay.style.position = 'fixed';
    gridOverlay.style.top = '0';
    gridOverlay.style.left = '0';
    gridOverlay.style.zIndex = '999';
    gridOverlay.style.cursor = 'pointer';
    document.body.appendChild(gridOverlay);

    const ctx = gridOverlay.getContext('2d');
    const cellWidth = gridOverlay.width / cols;
    const cellHeight = gridOverlay.height / rows;

    // Animate grid drawing
    const totalCells = cols * rows;
    let drawnCells = 0;
    const drawSpeed = 8; // cells per frame

    return new Promise((resolve) => {
      const animate = () => {
        ctx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 2;

        // Draw cells that are currently being animated
        for (let i = 0; i < drawnCells && i < totalCells; i++) {
          const col = i % cols;
          const row = Math.floor(i / cols);
          const x = col * cellWidth;
          const y = row * cellHeight;

          ctx.strokeRect(x, y, cellWidth, cellHeight);
        }

        drawnCells += drawSpeed;

        if (drawnCells < totalCells) {
          requestAnimationFrame(animate);
        } else {
          // Grid fully drawn, fade it out with the background
          gsap.to(gridOverlay, {
            opacity: 0,
            duration: 1,
            ease: 'power2.in',
            onComplete: () => {
              document.body.removeChild(gridOverlay);
              resolve();
            }
          });
        }
      };
      animate();
    });
  },

  async initializeWall() {
    // Prevent double initialization
    if (this.wallInstance) {
      console.warn('‚ö†Ô∏è [WALL] Already initialized, skipping');
      return;
    }
    
    console.log('üéÆ [WALL] Initializing THREE.js wall...');
    const wallContainer = Utils.getElement('wall-fullscreen');
    
    // Dynamically import the ES6 modules (same as WALL.html uses)
    const THREE = await import('https://unpkg.com/three@0.152.2/build/three.module.js');
    const CANNON = await import('https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js');
    
    console.log('‚úÖ Libraries loaded via dynamic import');
    
    // Scene setup
    const scene = new THREE.Scene();
    const aspect = window.innerWidth / window.innerHeight;
    const frustumHeight = 27.20;
    const frustumWidth = frustumHeight * aspect;
    
    const camera = new THREE.OrthographicCamera(
      -frustumWidth / 2, frustumWidth / 2,
      frustumHeight / 2, -frustumHeight / 2,
      0.1, 1000
    );
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.setClearColor(0x000000, 1);
    wallContainer.appendChild(renderer.domElement);
    
    // Ensure canvas stays below UI elements
    renderer.domElement.style.zIndex = '1';
    
    console.log('üé• Renderer initialized and appended to container');
    
    scene.add(new THREE.AmbientLight(0x888888));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 10, 10);
    scene.add(light);

    // Create text behind the wall (visible when wall is knocked down)
    const textCanvas = document.createElement('canvas');
    textCanvas.width = 2048;
    textCanvas.height = 512;
    const textCtx = textCanvas.getContext('2d');
    textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
    textCtx.fillStyle = 'white';
    textCtx.font = 'bold 120px Arial';
    textCtx.textAlign = 'center';
    textCtx.textBaseline = 'middle';
    textCtx.shadowColor = 'rgba(0,0,0,0.7)';
    textCtx.shadowBlur = 12;
    textCtx.fillText('work exp goes here', textCanvas.width / 2, textCanvas.height / 2);

    const textTexture = new THREE.CanvasTexture(textCanvas);
    textTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    textTexture.minFilter = THREE.LinearFilter;
    textTexture.magFilter = THREE.LinearFilter;
    textTexture.needsUpdate = true;
    const textMat = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true });
    const textGeo = new THREE.PlaneGeometry(30, 8, 1, 1);
    const textMesh = new THREE.Mesh(textGeo, textMat);
    textMesh.position.set(0, 13.5, -10); // Centered at wall height, behind the wall
    scene.add(textMesh);
    console.log('üìù Text mesh added at position:', textMesh.position);


    // Physics world - exactly like WALL.html
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.81, 0) });
    world.solver.iterations = 20;

    const cubeMaterial = new CANNON.Material('cube');
    const floorMaterial = new CANNON.Material('floor');

    const glueContactMaterial = new CANNON.ContactMaterial(cubeMaterial, floorMaterial, {
      friction: 0.8,
      restitution: 0.05
    });
    world.addContactMaterial(glueContactMaterial);

    const cubeToCuteMaterial = new CANNON.ContactMaterial(cubeMaterial, cubeMaterial, {
      friction: 0.8,
      restitution: 0.05
    });
    world.addContactMaterial(cubeToCuteMaterial);

    // Track all wall blocks
    const objects = [];

    // Floor - exactly like WALL.html
    const floorGeo = new THREE.BoxGeometry(50, 1, 50);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
    const floorMesh = new THREE.Mesh(floorGeo, floorMat);
    floorMesh.position.y = -0.5;
    scene.add(floorMesh);

    const floorShape = new CANNON.Box(new CANNON.Vec3(25, 0.5, 25));
    const floorBody = new CANNON.Body({ mass: 0, material: floorMaterial });
    floorBody.position.y = -0.5;
    floorBody.addShape(floorShape);
    world.addBody(floorBody);

    // Wall setup - exactly like WALL.html
    const wallRows = 9;
    const wallCols = 16;
    const cubeSize = 3;

    const wallLoaded = new Promise((resolve, reject) => {
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load('assets/background/mog.png', (baseTexture) => {
        console.log('üì∏ Texture loaded, creating wall cubes...');
        try {
          // Create cubes with mosaic texture
          for (let y = 0; y < wallRows; y++) {
            for (let x = 0; x < wallCols; x++) {
              const geo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
              
              // Create a custom canvas texture for this cube's section
              const canvas = document.createElement('canvas');
              canvas.width = 256;
              canvas.height = 256;
              const ctx = canvas.getContext('2d');
              
              // Draw the corresponding section of the mosaic
              const imgWidth = baseTexture.image.width;
              const imgHeight = baseTexture.image.height;
              
              const srcX = (x / wallCols) * imgWidth;
              const srcY = ((wallRows - 1 - y) / wallRows) * imgHeight;
              const srcW = imgWidth / wallCols;
              const srcH = imgHeight / wallRows;
              
              ctx.drawImage(baseTexture.image, srcX, srcY, srcW, srcH, 0, 0, 256, 256);
              
              const texture = new THREE.CanvasTexture(canvas);
              texture.colorSpace = THREE.SRGBColorSpace;
              const frontMat = new THREE.MeshLambertMaterial({ map: texture });
              const sideMat = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
              // Cube face order: +X, -X, +Y, -Y, +Z (front), -Z (back)
              const materials = [sideMat, sideMat, sideMat, sideMat, frontMat, sideMat];
              const mesh = new THREE.Mesh(geo, materials);
              mesh.position.set((x - (wallCols / 2)) * cubeSize, y * cubeSize + cubeSize / 2, -(cubeSize / 2));
              scene.add(mesh);

              const boxShape = new CANNON.Box(new CANNON.Vec3(cubeSize / 2, cubeSize / 2, cubeSize / 2));
              const body = new CANNON.Body({ mass: 1 });
              body.position.set((x - (wallCols / 2)) * cubeSize, y * cubeSize + cubeSize / 2, -(cubeSize / 2));
              body.addShape(boxShape);
              body.material = cubeMaterial;
              world.addBody(body);

              objects.push({ mesh: mesh, body: body });
            }
          }
          console.log('üß± Wall created with', objects.length, 'cubes');
          resolve();
        } catch (e) {
          console.error('‚ùå Error creating wall:', e);
          reject(e);
        }
      }, undefined, (error) => {
        console.error('‚ùå Failed to load texture:', error);
        reject(error);
      });
    });

    await wallLoaded;

    camera.position.z = 10.01;
    camera.position.y = 13.61;
    camera.position.x = -1.42;

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedBody = null;
    let hasDragged = false;
    let dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    let dragPoint = new THREE.Vector3();

    // Handle resize
    const onWindowResize = () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      const aspect = window.innerWidth / window.innerHeight;
      const frustumHeight = 27.20;
      const frustumWidth = frustumHeight * aspect;
      camera.left = -frustumWidth / 2;
      camera.right = frustumWidth / 2;
      camera.top = frustumHeight / 2;
      camera.bottom = -frustumHeight / 2;
      camera.updateProjectionMatrix();
    };
    window.addEventListener('resize', onWindowResize, false);

    // Mouse down - select cube for dragging - exactly like WALL.html
    document.addEventListener('mousedown', (event) => {
      // Only interact when wall is active
      if (!wallActive) {
        console.log('üö´ [WALL] mousedown ignored - wallActive is', wallActive);
        return;
      }
      console.log('üëÜ [WALL] mousedown - wallActive is', wallActive);
      
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      
      const intersects = raycaster.intersectObjects(scene.children);

      for (let intersection of intersects) {
        const clickedMesh = intersection.object;
        const objectData = objects.find(obj => obj.mesh === clickedMesh);
        
        if (objectData) {
          selectedBody = objectData.body;
          dragPlane.setFromNormalAndCoplanarPoint(
            camera.position.clone().normalize(),
            selectedBody.position
          );
          raycaster.ray.intersectPlane(dragPlane, dragPoint);
          break;
        }
      }
    }, false);

    // Mouse move - drag cube - exactly like WALL.html
    document.addEventListener('mousemove', (event) => {
      if (!selectedBody || !wallActive) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      raycaster.ray.intersectPlane(dragPlane, dragPoint);

      const force = dragPoint.clone().sub(selectedBody.position).multiplyScalar(5);
      selectedBody.velocity.copy(force);
      
      // Hide click text on first drag
      if (!hasDragged) {
        hasDragged = true;
        const clickTextEl = Utils.getElement('wall-click-text');
        if (clickTextEl) {
          clickTextEl.style.animation = 'none';
          clickTextEl.style.transition = 'opacity 0.5s';
          clickTextEl.style.opacity = '0';
        }
      }
    }, false);

    // Mouse up - release cube - exactly like WALL.html
    document.addEventListener('mouseup', (event) => {
      selectedBody = null;
    }, false);

    // Click - apply impulse - exactly like WALL.html
    document.addEventListener('click', (event) => {
      // Only interact when wall is active
      if (!wallActive) {
        console.log('üö´ [WALL] click ignored - wallActive is', wallActive);
        return;
      }
      
      // Don't apply impulse if clicking UI elements
      if (event.target.id === 'backButtonWall' || event.target.id === 'wall-click-text') {
        return;
      }
      
      console.log('üëÜ [WALL] click - applying impulse');
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      
      const intersects = raycaster.intersectObjects(scene.children);

      for (let intersection of intersects) {
        const clickedMesh = intersection.object;
        const objectData = objects.find(obj => obj.mesh === clickedMesh);
        
        if (objectData) {
          const impulse = new CANNON.Vec3(Math.random() * 1 - 0.5, Math.random() * 1.5 + 1.5, Math.random() * 1 - 0.5);
          objectData.body.applyImpulse(impulse, objectData.body.position);
          break;
        }
      }
    }, false);

    // Store initial body states for reset BEFORE animation starts
    console.log('üì¶ Storing initial states for', objects.length, 'objects');
    const initialStates = objects.map(obj => ({
      position: obj.body.position.clone(),
      quaternion: obj.body.quaternion.clone()
    }));

    // Flag to pause physics during reset animation
    let isResetting = false;
    
    // Flag to track if wall is currently active/shown - prevents click propagation issues
    let wallActive = false;

    // Animation loop - physics only runs when wall is active and not resetting
    function animate() {
      requestAnimationFrame(animate);

      // Only run physics when wall is active AND not resetting
      if (wallActive && !isResetting) {
        world.step(1 / 60);

        for (const { mesh, body } of objects) {
          mesh.position.copy(body.position);
          mesh.quaternion.copy(body.quaternion);
        }
      }

      renderer.render(scene, camera);
    }

    console.log('‚ñ∂Ô∏è Starting animation loop...');
    animate();

    // Wall is preloaded but hidden - pointer events disabled until work transition
    wallContainer.style.pointerEvents = 'none';
    const clickText = Utils.getElement('wall-click-text');
    const backBtn = Utils.getElement('backButtonWall');
    // Keep UI hidden initially - will be shown when entering work page
    clickText.style.visibility = 'hidden';
    backBtn.style.visibility = 'hidden';
    backBtn.style.pointerEvents = 'none';

    // Store wall instance with reset method BEFORE setting up button
    const RESET_DURATION = 1.5; // seconds - adjustable

    this.wallInstance = {
      renderer, scene, camera, objects, world, CANNON,
      setActive: (active) => { 
        console.log('üéØ [WALL] setActive called with:', active, '(was:', wallActive, ')');
        wallActive = active; 
        console.log('üéØ [WALL] wallActive now:', wallActive);
      },
      resetDragState: () => {
        hasDragged = false;
        const clickTextEl = Utils.getElement('wall-click-text');
        if (clickTextEl) {
          clickTextEl.style.animation = 'fadeInOut 2s infinite';
          clickTextEl.style.opacity = '1';
        }
      },
      resetPhysics: () => {
        console.log('üîÑ Resetting physics bodies...');
        objects.forEach((obj, i) => {
          const state = initialStates[i];
          obj.body.position.copy(state.position);
          obj.body.quaternion.copy(state.quaternion);
          obj.body.velocity.set(0, 0, 0);
          obj.body.angularVelocity.set(0, 0, 0);
          obj.mesh.position.copy(obj.body.position);
          obj.mesh.quaternion.copy(obj.body.quaternion);
        });
      },
      // Animated reset - smoothly moves cubes back to original positions
      animateReset: () => {
        return new Promise(resolve => {
          console.log('üé¨ Animating cubes back to wall...', objects.length, 'objects');
          console.log('üì¶ Initial states:', initialStates.length);
          
          // PAUSE physics - let GSAP control meshes
          isResetting = true;
          
          // Stop all body movement
          objects.forEach(obj => {
            obj.body.velocity.set(0, 0, 0);
            obj.body.angularVelocity.set(0, 0, 0);
            obj.body.sleep();
          });
          
          // Animate each mesh back to original position using GSAP
          const timeline = gsap.timeline({
            onComplete: () => {
              // Restore physics bodies to exact positions
              objects.forEach((obj, i) => {
                const state = initialStates[i];
                obj.body.position.copy(state.position);
                obj.body.quaternion.copy(state.quaternion);
                obj.body.velocity.set(0, 0, 0);
                obj.body.angularVelocity.set(0, 0, 0);
                obj.body.wakeUp();
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
              });
              // RESUME physics
              isResetting = false;
              console.log('‚úÖ Cube reset animation complete');
              resolve();
            }
          });
          
          // Animate all meshes positions
          objects.forEach((obj, i) => {
            const target = initialStates[i];
            timeline.to(obj.mesh.position, {
              x: target.position.x,
              y: target.position.y,
              z: target.position.z,
              duration: RESET_DURATION,
              ease: 'power2.inOut'
            }, 0);
            timeline.to(obj.mesh.quaternion, {
              x: target.quaternion.x,
              y: target.quaternion.y,
              z: target.quaternion.z,
              w: target.quaternion.w,
              duration: RESET_DURATION,
              ease: 'power2.inOut'
            }, 0);
          });
        });
      }
    };

    // Setup back button - use arrow function to preserve 'this' context
    const handleWallBackClick = async () => {
      console.log('üîô [BACK BUTTON] Click detected!'); // DEBUG
      if (TransitionManager.isTransitioning) {
        console.log('üîô [BACK BUTTON] Blocked - already transitioning');
        return;
      }
      TransitionManager.isTransitioning = true;
      try {
        const wallFullscreen = Utils.getElement('wall-fullscreen');
        const clickTextEl = Utils.getElement('wall-click-text');
        const backBtnEl = Utils.getElement('backButtonWall');
        
        // Deactivate wall physics immediately to prevent further interaction
        wallActive = false;
        
        // First: fade out back button and click text
        await new Promise(resolve => {
          gsap.to([backBtnEl, clickTextEl], {
            opacity: 0,
            duration: 0.3,
            ease: 'power2.in',
            onComplete: () => {
              backBtnEl.style.visibility = 'hidden';
              clickTextEl.style.visibility = 'hidden';
              resolve();
            }
          });
        });

        // Second: animate cubes back to original positions
        console.log('üîÑ [WALL EXIT] Animating reset');
        await TransitionManager.wallInstance.animateReset();
        
        // Brief pause to show completed wall before fading
        await new Promise(r => setTimeout(r, 300));
        
        // Third: fade home page ON TOP of wall (don't fade wall out)
        TransitionManager.mainContent.style.display = 'flex';
        const bg = Utils.getElement('bgVideo');
        const eyeOffset = Utils.getElement('eyeOffset');
        const icons = document.querySelectorAll('.icon');
        
        bg.style.display = 'block';
        gsap.set([bg, eyeOffset, ...icons], { opacity: 0 });
        
        await new Promise(resolve => {
          gsap.to([bg, eyeOffset, ...icons], {
            opacity: 1,
            duration: 0.6,
            ease: 'power2.out',
            onComplete: resolve
          });
          icons.forEach(i => i.classList.remove('icon-hidden'));
        });

        // NOW hide the wall (it's behind home page anyway)
        gsap.set(wallFullscreen, { opacity: 0 });
        wallFullscreen.style.pointerEvents = 'none';

        setTimeout(() => {
          Object.values(window.iconInstances).forEach(inst => inst.reset());
        }, 100);

        console.log('‚úÖ [WALL EXIT] Back to home from wall');
      } catch (e) {
        console.error('Wall back transition error:', e);
      } finally { TransitionManager.isTransitioning = false; }
    };

    backBtn.addEventListener('click', handleWallBackClick);

    // DEBUG: Track any style changes to the back button
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'style') {
          const opacity = backBtn.style.opacity;
          const visibility = backBtn.style.visibility;
          console.log('üîç [BUTTON STYLE CHANGED]', { opacity, visibility, trace: new Error().stack });
        }
      });
    });
    observer.observe(backBtn, { attributes: true, attributeFilter: ['style'] });

    console.log('‚úÖ [WALL] Wall fully initialized and running!');
    console.log('üîç [WALL] this.wallInstance:', this.wallInstance);
    console.log('üîç [WALL] TransitionManager.wallInstance:', TransitionManager.wallInstance);
  },

  setupReverseTransition(backButton, pageType) {
    backButton.addEventListener('click', async () => {
      if (this.isTransitioning) return;
      this.isTransitioning = true;
      try {
        const targetPage    = pageType === 'contacts' ? this.contactsPage : this.eduPage;
        const reverseVideo   = pageType === 'contacts' ? CONFIG.TRANSITION.CONTACTS_REVERSE : CONFIG.TRANSITION.EDU_REVERSE;

        // Stop contacts eye animation when leaving
        if (pageType === 'contacts') {
          ContactsEyeSystem.stop();
        }

        if (reverseVideo) {
          const video = this.transitionVideo, source = video.querySelector('source');
          video.style.transform = `translateY(${CONFIG.TRANSITION.OFFSET}px)`;
          source.src = reverseVideo;
          video.load();
          video.currentTime = 0;
          if (pageType === 'edu') video.classList.add('under-icons');

          video.style.display = 'block';
          await video.play();

          requestAnimationFrame(() => {
            targetPage.style.display = 'none';
            this.mainContent.style.display = 'block';
            Utils.getElement('bgFreeze').style.display = 'block';
          });

          Object.values(window.iconInstances).forEach(inst => inst.reset());

          if (pageType === 'contacts') {
            gsap.set(Utils.getElement('eyeOffset'), { opacity: 1 });
          }

          const iconDelay = (pageType === 'edu' ? CONFIG.TIMING.EDU_REVERSE_ICON_FADE : 300) / 1000;
          this.fadeIconsIn(iconDelay);

          await this.waitForVideoEnd();

          if (pageType === 'edu') {
            gsap.to(Utils.getElement('eyeOffset'), { opacity: 1, duration: CONFIG.GSAP.EYE_FADE_FAST, ease: 'power2.out' });
          }

          video.classList.remove('under-icons');
          video.style.display = 'none';
        } else {
          targetPage.style.display = 'none';
          this.mainContent.style.display = 'block';
          Utils.getElement('bgFreeze').style.display = 'block';
          Object.values(window.iconInstances).forEach(inst => inst.reset());
          this.fadeIconsIn(0.3);
          gsap.set(Utils.getElement('eyeOffset'), { opacity: 1 });
        }

        setTimeout(() => EyeSystem.blinkOnce(), 100);
      } catch (e) {
        console.error('Reverse transition error:', e);
        this.handleTransitionError(null);
      } finally { this.isTransitioning = false; }
    });
  },

  handleTransitionError(pageType) {
    this.transitionVideo.style.display = 'none';
    if (pageType === 'contacts') {
      this.mainContent.style.display   = 'none';
      this.contactsPage.style.display  = 'flex';
      this.eduPage.style.display       = 'none';
    } else if (pageType === 'edu') {
      this.mainContent.style.display   = 'none';
      this.eduPage.style.display       = 'flex';
      this.contactsPage.style.display  = 'none';
    } else {
      this.contactsPage.style.display  = 'none';
      this.eduPage.style.display       = 'none';
      this.mainContent.style.display   = 'block';
      Utils.getElement('bgFreeze').style.display = 'block';
      gsap.set(Utils.getElement('eyeOffset'), { opacity: 1 });
      Object.values(window.iconInstances).forEach(inst => inst.reset());
      this.fadeIconsIn(0);
    }
  }
};

/* ========================================================================
   EYE SYSTEM
   ======================================================================== */
const EyeSystem = {
  eyeMove: null, eyeOffset: null, blinkLid: null,
  bgVideo: null, bgFreeze: null, ctx: null,
  eyeActive: false, eyeActivationTriggered: false,
  reflectionsMove: null,

  init() {
    this.eyeMove         = Utils.getElement('eyeMove');
    this.eyeOffset       = Utils.getElement('eyeOffset');
    this.blinkLid        = Utils.getElement('blinkLid');
    this.bgVideo         = Utils.getElement('bgVideo');
    this.bgFreeze        = Utils.getElement('bgFreeze');
    this.reflectionsMove = Utils.getElement('reflectionsMove');
    this.ctx             = this.bgFreeze.getContext('2d');
    this.setupVideoListeners();
    this.setupTracking();
    this.setupFallback();
  },

  setupVideoListeners() {
    this.bgVideo.addEventListener('timeupdate', () => {
      // Don't activate eye if loading hasn't completed yet
      if (!Preloader.loadingComplete) return;
      if (this.eyeActivationTriggered || this.eyeActive) return;
      if (this.bgVideo.currentTime >= CONFIG.TIMING.EYE_ACTIVATE_TIME) this.activateEye();
    });
    this.bgVideo.addEventListener('ended', () => {
      if (!Preloader.loadingComplete) return;
      if (this.eyeActivationTriggered || this.eyeActive) return;
      this.activateEye();
    });
  },

  activateEye() {
    this.eyeActivationTriggered = true;
    this.bgFreeze.width  = this.bgVideo.videoWidth;
    this.bgFreeze.height = this.bgVideo.videoHeight;
    if (this.bgFreeze.width > 0 && this.bgFreeze.height > 0) {
      try {
        this.ctx.drawImage(this.bgVideo, 0, 0, this.bgFreeze.width, this.bgFreeze.height);
        this.bgVideo.style.display  = 'none';
        this.bgFreeze.style.display = 'block';
        gsap.to(this.eyeOffset, { opacity: 1, duration: CONFIG.GSAP.EYE_FADE_ACTIVATE, ease: 'power2.out' });
        this.eyeActive = true;
        setTimeout(() => this.blinkOnce(), 100);
        this.startBlinking();
        Utils.log('‚úÖ Eye activated!');
      } catch (e) { console.error('Failed to draw video to canvas:', e); }
    }
  },

  setupTracking() {
    document.addEventListener('mousemove', (e) => {
      if (this.eyeActive && !DeviceDetector.isTouchDevice) this.updateEyePosition(e.clientX, e.clientY);
    });
    document.addEventListener('touchmove', (e) => {
      if (this.eyeActive && e.touches.length) this.updateEyePosition(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: true });
    document.addEventListener('touchstart', (e) => {
      if (this.eyeActive && e.touches.length) this.updateEyePosition(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: true });
  },

  updateEyePosition(cx, cy) {
    const x = (cx / window.innerWidth  - 0.5) * 120;
    const y = (cy / window.innerHeight - 0.5) * 60;
    this.eyeMove.setAttribute('transform', `translate(${x}, ${y})`);
    this.reflectionsMove.setAttribute('transform',
      `translate(${x * CONFIG.EYE.REFLECTION_MOVEMENT}, ${y * CONFIG.EYE.REFLECTION_MOVEMENT})`);
  },

  setupFallback() {
    const checkFallback = () => {
      // If loading isn't complete yet, check again later
      if (!Preloader.loadingComplete) {
        setTimeout(checkFallback, 1000);
        return;
      }
      // If eye is already active, no need for fallback
      if (this.eyeActive) return;
      
      // Wait for the normal eye activation time after loading, then trigger fallback
      setTimeout(() => {
        if (!this.eyeActive) {
          console.warn('‚ö†Ô∏è Eye fallback triggered');
          gsap.to(this.eyeOffset, { opacity: 1, duration: CONFIG.GSAP.EYE_FADE_ACTIVATE });
          this.eyeActive = true;
          this.startBlinking();
        }
      }, CONFIG.TIMING.EYE_FALLBACK_TIMEOUT);
    };
    checkFallback();
  },

  blinkOnce() {
    if (!this.eyeActive) return;
    this.blinkLid.style.animation = `blink ${CONFIG.TIMING.BLINK_SPEED}ms ease-in-out`;
    this.blinkLid.addEventListener('animationend', () => { this.blinkLid.style.animation = ''; }, { once: true });
  },
  
  blink() {
    this.blinkOnce();
    if (Math.random() < CONFIG.EYE.DOUBLE_BLINK_CHANCE)
      setTimeout(() => this.blinkOnce(), CONFIG.TIMING.DOUBLE_BLINK_DELAY);
  },
  
  startBlinking() {
    const loop = () => {
      this.blink();
      setTimeout(loop, CONFIG.TIMING.BLINK_MIN_DELAY + Math.random() * (CONFIG.TIMING.BLINK_MAX_DELAY - CONFIG.TIMING.BLINK_MIN_DELAY));
    };
    loop();
  },

  resetToCenter() {
    if (!this.eyeActive) return Promise.resolve();

    const attr = this.eyeMove.getAttribute('transform') || 'translate(0,0)';
    const m    = attr.match(/translate\(([-\d.]+),\s*([-\d.]+)\)/);
    const sx   = m ? parseFloat(m[1]) : 0;
    const sy   = m ? parseFloat(m[2]) : 0;
    if (sx === 0 && sy === 0) return Promise.resolve();

    const proxy = { x: sx, y: sy };
    return new Promise(resolve => {
      gsap.to(proxy, {
        x: 0, y: 0,
        duration: CONFIG.GSAP.EYE_RESET_DURATION,
        ease: 'power3.out',
        onUpdate: () => {
          this.eyeMove.setAttribute('transform', `translate(${proxy.x}, ${proxy.y})`);
          this.reflectionsMove.setAttribute('transform',
            `translate(${proxy.x * CONFIG.EYE.REFLECTION_MOVEMENT}, ${proxy.y * CONFIG.EYE.REFLECTION_MOVEMENT})`);
        },
        onComplete: resolve
      });
    });
  }
};

/* ========================================================================
   CONTACTS EYE SYSTEM - Animated eye background for contacts page
   ======================================================================== */
const ContactsEyeSystem = {
  canvas: null,
  ctx: null,
  eyes: [],
  isActive: false,
  animationId: null,
  lastTime: 0,
  lastRandomBlink: 0,
  mouseX: 0,
  mouseY: 0,
  activeHoverPattern: null,
  eyeCache: { open: null, closed: [], openRed: null, closedRed: [], openRainbow: [], closedRainbow: [] },
  
  // Easter egg state
  lastEnterTime: 0,
  easterEggInput: null,
  easterEggBuffer: '',
  rainbowMode: false,
  rainbowHue: 0,

  // Eye dimensions and scale
  EYE_WIDTH: 60,
  EYE_HEIGHT: 43,
  EYE_SCALE: 0.85,
  
  // Hover patterns - flat indices exactly like contacts-optimized.html
  hoverPatterns: {
    email: [90,91,92,93,94,95,96,120,146,171,197,117,144,170,116,168,220,272,273,274,275,276,277,148,200,252,142,194,246,225,173,121,300,352,404,456,482,483,484,485,486,487,488,489,490,230,229,227,226,228,256,281,307,332,358,383,409,434,408,381,355,328,302,413,465,361,309,257,326,378,430,282,334,386,438],
    phone: [221,171,174,201,227,254,173,172,225,224,250,251,277,276,301,304,330,326,352,377,404,430,457,458,459,460,461,358,384,410,435,383,357,382,409,355,354,378,405,431,380,433,434,408,432,247,195,170,228,202,275,332,359,403,429,456,223,148,147,146,145,253,279,280,255,248,273,196,220,246,272,351,324,350,376,328,402,428,455,411,462,436,175,169,427,454,437,463],
    social: [123,149,175,150,176,202,227,201,174,254,280,307,333,359,253,278,304,384,410,435,409,382,356,329,279,305,330,357,383,358,332,306,331,355,381,408,434,461,487,462,436,411,385,360,198,223,250,224,276,303,275,301,326,302,328,327,354,380,353,379,406,352,378,405,431,458,432,407,118,144,169,143,145,119,93,170,196,117,91,116,230,229,256,273,272,299]
  },
  
  init() {
    this.canvas = document.getElementById('contactsCanvas');
    if (!this.canvas) {
      console.warn('ContactsEyeSystem: Canvas not found');
      return;
    }
    this.ctx = this.canvas.getContext('2d', { alpha: false });
    this.createEyeCache();
    this.setupEventListeners();
    this.setupHoverPatterns();
    this.setupTextCarousel();
    console.log('‚úÖ ContactsEyeSystem initialized');
  },
  
  createEyeCache() {
    const padding = 4;
    const w = Math.floor((64 + padding * 2) * this.EYE_SCALE);
    const h = Math.floor((42 + padding * 2) * this.EYE_SCALE);
    
    // Create open eye sprite
    const openCanvas = document.createElement('canvas');
    openCanvas.width = w;
    openCanvas.height = h;
    const openCtx = openCanvas.getContext('2d');
    
    openCtx.translate(w / 2, h / 2);
    openCtx.scale(this.EYE_SCALE, this.EYE_SCALE);
    openCtx.beginPath();
    openCtx.moveTo(-30, 0);
    openCtx.quadraticCurveTo(-15, -18, 0, -19);
    openCtx.quadraticCurveTo(15, -18, 30, 0);
    openCtx.quadraticCurveTo(15, 18, 0, 19);
    openCtx.quadraticCurveTo(-15, 18, -30, 0);
    openCtx.closePath();
    openCtx.fillStyle = '#4a4a4a';
    openCtx.fill();
    
    this.eyeCache.open = openCanvas;
    
    // Create red version of open eye
    const openRedCanvas = document.createElement('canvas');
    openRedCanvas.width = w;
    openRedCanvas.height = h;
    const openRedCtx = openRedCanvas.getContext('2d');
    openRedCtx.translate(w / 2, h / 2);
    openRedCtx.scale(this.EYE_SCALE, this.EYE_SCALE);
    openRedCtx.beginPath();
    openRedCtx.moveTo(-30, 0);
    openRedCtx.quadraticCurveTo(-15, -18, 0, -19);
    openRedCtx.quadraticCurveTo(15, -18, 30, 0);
    openRedCtx.quadraticCurveTo(15, 18, 0, 19);
    openRedCtx.quadraticCurveTo(-15, 18, -30, 0);
    openRedCtx.closePath();
    openRedCtx.fillStyle = 'rgb(120, 0, 0)';
    openRedCtx.fill();
    this.eyeCache.openRed = openRedCanvas;
    
    // Create darker variations for closing animation
    for (let i = 0; i <= 10; i++) {
      const closedCanvas = document.createElement('canvas');
      closedCanvas.width = w;
      closedCanvas.height = h;
      const closedCtx = closedCanvas.getContext('2d');
      
      closedCtx.translate(w / 2, h / 2);
      closedCtx.scale(this.EYE_SCALE, this.EYE_SCALE);
      closedCtx.beginPath();
      closedCtx.moveTo(-30, 0);
      closedCtx.quadraticCurveTo(-15, -18, 0, -19);
      closedCtx.quadraticCurveTo(15, -18, 30, 0);
      closedCtx.quadraticCurveTo(15, 18, 0, 19);
      closedCtx.quadraticCurveTo(-15, 18, -30, 0);
      closedCtx.closePath();
      
      const grayValue = Math.floor(74 - (i / 10) * 32);
      closedCtx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
      closedCtx.fill();
      
      this.eyeCache.closed.push(closedCanvas);
      
      // Create red version
      const closedRedCanvas = document.createElement('canvas');
      closedRedCanvas.width = w;
      closedRedCanvas.height = h;
      const closedRedCtx = closedRedCanvas.getContext('2d');
      closedRedCtx.translate(w / 2, h / 2);
      closedRedCtx.scale(this.EYE_SCALE, this.EYE_SCALE);
      closedRedCtx.beginPath();
      closedRedCtx.moveTo(-30, 0);
      closedRedCtx.quadraticCurveTo(-15, -18, 0, -19);
      closedRedCtx.quadraticCurveTo(15, -18, 30, 0);
      closedRedCtx.quadraticCurveTo(15, 18, 0, 19);
      closedRedCtx.quadraticCurveTo(-15, 18, -30, 0);
      closedRedCtx.closePath();
      const redValue = Math.floor(120 - (i / 10) * 60);
      closedRedCtx.fillStyle = `rgb(${redValue}, 0, 0)`;
      closedRedCtx.fill();
      this.eyeCache.closedRed.push(closedRedCanvas);
    }
    
    // Create rainbow sprites (12 hues for smooth cycling)
    for (let hueIdx = 0; hueIdx < 12; hueIdx++) {
      const hue = hueIdx * 30; // 0, 30, 60, 90... 330
      
      // Open rainbow
      const openRainbow = document.createElement('canvas');
      openRainbow.width = w;
      openRainbow.height = h;
      const orCtx = openRainbow.getContext('2d');
      orCtx.translate(w / 2, h / 2);
      orCtx.scale(this.EYE_SCALE, this.EYE_SCALE);
      orCtx.beginPath();
      orCtx.moveTo(-30, 0);
      orCtx.quadraticCurveTo(-15, -18, 0, -19);
      orCtx.quadraticCurveTo(15, -18, 30, 0);
      orCtx.quadraticCurveTo(15, 18, 0, 19);
      orCtx.quadraticCurveTo(-15, 18, -30, 0);
      orCtx.closePath();
      orCtx.fillStyle = `hsl(${hue}, 100%, 45%)`;
      orCtx.fill();
      this.eyeCache.openRainbow.push(openRainbow);
      
      // Closed rainbow (array of 11 darkness levels per hue)
      const closedForHue = [];
      for (let i = 0; i <= 10; i++) {
        const closedRainbow = document.createElement('canvas');
        closedRainbow.width = w;
        closedRainbow.height = h;
        const crCtx = closedRainbow.getContext('2d');
        crCtx.translate(w / 2, h / 2);
        crCtx.scale(this.EYE_SCALE, this.EYE_SCALE);
        crCtx.beginPath();
        crCtx.moveTo(-30, 0);
        crCtx.quadraticCurveTo(-15, -18, 0, -19);
        crCtx.quadraticCurveTo(15, -18, 30, 0);
        crCtx.quadraticCurveTo(15, 18, 0, 19);
        crCtx.quadraticCurveTo(-15, 18, -30, 0);
        crCtx.closePath();
        const lightness = 45 - (i / 10) * 20;
        crCtx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
        crCtx.fill();
        closedForHue.push(closedRainbow);
      }
      this.eyeCache.closedRainbow.push(closedForHue);
    }
  },
  
  resizeCanvas() {
    if (!this.canvas) return;
    
    // Use window dimensions like contacts-optimized.html
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    
    this.createEyeGrid();
  },
  
  createEyeGrid() {
    this.eyes.length = 0;
    
    const horizontalSpacing = this.EYE_WIDTH * 0.88;
    const verticalSpacing = this.EYE_HEIGHT * 0.68;
    
    const cols = Math.ceil(this.canvas.width / horizontalSpacing) + 1;
    const rows = Math.ceil(this.canvas.height / verticalSpacing) + 1;
    
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const offsetX = (row % 2 === 0) ? 0 : horizontalSpacing / 2;
        const x = col * horizontalSpacing - offsetX;
        const y = row * verticalSpacing;
        
        this.eyes.push({
          x: x + this.EYE_WIDTH / 2,
          y: y + this.EYE_HEIGHT / 2,
          blinkState: 0,
          blinkProgress: 0,
          permanentlyClosed: false,
          closeProgress: 1,
          hoverClosed: false,
          hoverCloseProgress: 0,
          hoverBlinkState: 0,
          hoverBlinkProgress: 0
        });
      }
    }
    
    console.log(`üëÅÔ∏è Created eye grid: ${cols}√ó${rows} = ${this.eyes.length} eyes (canvas: ${this.canvas.width}√ó${this.canvas.height})`);
  },
  
  setupEventListeners() {
    // Mouse tracking - direct screen coords since canvas is fixed to viewport
    document.addEventListener('mousemove', (e) => {
      if (this.isActive) {
        this.mouseX = e.clientX;
        this.mouseY = e.clientY;
      }
    });
    
    // Click wave effect
    document.addEventListener('click', (e) => {
      if (!this.isActive) return;
      
      const clickX = e.clientX;
      const clickY = e.clientY;
      const maxDistance = Math.sqrt(this.canvas.width ** 2 + this.canvas.height ** 2);
      const TOTAL_WAVE_TIME = 1200;
      
      this.eyes.forEach(eye => {
        if (eye.permanentlyClosed) return;
        
        const dx = eye.x - clickX;
        const dy = eye.y - clickY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const delay = (distance / maxDistance) * TOTAL_WAVE_TIME + Math.random() * 60;
        
        setTimeout(() => {
          if (eye.blinkState === 0 && !eye.permanentlyClosed) {
            eye.blinkState = 1;
            eye.blinkProgress = 0;
          }
        }, delay);
      });
    });
    
    // Easter egg: double-tap Enter to show input, type "AWS" for rainbow mode
    this.createEasterEggInput();
    document.addEventListener('keydown', (e) => {
      if (!this.isActive) return;
      
      if (e.key === 'Enter') {
        const now = Date.now();
        if (now - this.lastEnterTime < 300) {
          // Double-tap detected - show/focus input
          this.easterEggInput.style.opacity = '1';
          this.easterEggInput.focus();
          this.easterEggBuffer = '';
          this.easterEggInput.value = '';
        }
        this.lastEnterTime = now;
      }
    });
  },
  
  createEasterEggInput() {
    const input = document.createElement('input');
    input.type = 'text';
    input.id = 'easterEggInput';
    input.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      font-size: 18px;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #666;
      border-radius: 8px;
      color: #fff;
      outline: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 9999;
      text-transform: uppercase;
    `;
    
    // Simple hash function to hide secret words
    const hashCode = (s) => {
      let h = 0;
      for (let i = 0; i < s.length; i++) h = ((h << 5) - h) + s.charCodeAt(i) | 0;
      return h;
    };
    
    input.addEventListener('input', (e) => {
      this.easterEggBuffer = e.target.value.toUpperCase();
      const h = hashCode(this.easterEggBuffer);
      
      if (h === 65245) { // secret activate code
        this.rainbowMode = true;
        input.style.borderColor = 'hsl(' + this.rainbowHue + ', 100%, 50%)';
        input.style.boxShadow = '0 0 20px hsl(' + this.rainbowHue + ', 100%, 50%)';
      } else if (h === 76517) { // secret deactivate code
        this.rainbowMode = false;
        input.style.borderColor = '#666';
        input.style.boxShadow = 'none';
      }
    });
    
    input.addEventListener('blur', () => {
      input.style.opacity = '0';
    });
    
    document.body.appendChild(input);
    this.easterEggInput = input;
  },
  
  setupHoverPatterns() {
    const self = this;
    
    const elements = document.querySelectorAll('#contactsPage [data-hover-pattern]');
    console.log(`üîç setupHoverPatterns: Found ${elements.length} pattern elements`);
    
    elements.forEach(element => {
      const patternName = element.getAttribute('data-hover-pattern');
      const pattern = self.hoverPatterns[patternName];
      
      console.log(`üìã Pattern ${patternName}: ${pattern ? pattern.length + ' eyes' : 'NOT FOUND'}`);
      
      if (!pattern) return;
      
      element.addEventListener('mouseenter', () => {
        console.log(`üñ±Ô∏è mouseenter: ${patternName}, isActive=${self.isActive}, eyes.length=${self.eyes.length}`);
        if (!self.isActive) return;
        
        // Clear old pattern
        if (self.activeHoverPattern && self.activeHoverPattern !== patternName) {
          const oldPattern = self.hoverPatterns[self.activeHoverPattern];
          if (oldPattern) {
            oldPattern.forEach(idx => self.resetEyeHoverState(idx));
          }
        }
        
        self.activeHoverPattern = patternName;
        
        pattern.forEach(eyeIndex => {
          if (self.eyes[eyeIndex]) {
            self.eyes[eyeIndex].hoverBlinkState = 0;
            self.eyes[eyeIndex].hoverBlinkProgress = 0;
            self.eyes[eyeIndex].hoverCloseProgress = 0;
            self.eyes[eyeIndex].hoverClosed = true;
          }
        });
      });
      
      element.addEventListener('mouseleave', () => {
        if (self.activeHoverPattern === patternName) {
          self.activeHoverPattern = null;
          pattern.forEach(idx => self.resetEyeHoverState(idx));
        }
      });
    });
  },
  
  resetEyeHoverState(eyeIndex) {
    if (this.eyes[eyeIndex]) {
      this.eyes[eyeIndex].hoverClosed = false;
      this.eyes[eyeIndex].hoverBlinkState = 0;
      this.eyes[eyeIndex].hoverBlinkProgress = 0;
      this.eyes[eyeIndex].hoverCloseProgress = 0;
    }
  },
  
  setupTextCarousel() {
    // Split text into characters for carousel effect
    document.querySelectorAll('#contactsPage .body-line .value').forEach(valueElement => {
      const text = valueElement.textContent;
      valueElement.innerHTML = '';
      
      for (let char of text) {
        const charWrapper = document.createElement('span');
        charWrapper.className = 'char';
        
        const charInner = document.createElement('span');
        charInner.className = 'char-inner';
        charInner.textContent = char;
        charInner.setAttribute('data-char', char);
        
        charWrapper.appendChild(charInner);
        valueElement.appendChild(charWrapper);
      }
    });
    
    // Add hover listeners to trigger animation
    document.querySelectorAll('#contactsPage .body-line').forEach(line => {
      line.addEventListener('mouseenter', function() {
        this.classList.add('animating');
        const totalAnimationTime = 1750;
        
        setTimeout(() => {
          this.classList.remove('animating');
          void this.offsetWidth;
        }, totalAnimationTime);
      });
    });
  },
  
  easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
  },
  
  drawEye(eye) {
    const { x, y, blinkProgress, permanentlyClosed, closeProgress, hoverClosed, hoverCloseProgress, hoverBlinkState, hoverBlinkProgress } = eye;
    
    const imgW = this.eyeCache.open.width;
    const imgH = this.eyeCache.open.height;
    
    // Calculate hover blink scale
    let hoverBlinkScale = 1;
    let isInBlinkSequence = hoverBlinkState >= 1 && hoverBlinkState <= 4;
    
    if (hoverBlinkState === 1 || hoverBlinkState === 3) {
      hoverBlinkScale = 1 - hoverBlinkProgress * 0.92;
    } else if (hoverBlinkState === 2 || hoverBlinkState === 4) {
      hoverBlinkScale = 0.08 + hoverBlinkProgress * 0.92;
    }
    
    const effectiveCloseProgress = Math.max(closeProgress > 0 ? closeProgress : 0, hoverCloseProgress || 0);
    const isClosed = permanentlyClosed || effectiveCloseProgress > 0 || hoverBlinkState > 0;
    
    // Determine if we should show red flash (during any blink animation)
    let redFlashIntensity = 0;
    if (blinkProgress > 0) {
      // Regular blink / wave blink - peak red at middle of blink
      if (blinkProgress < 0.5) {
        redFlashIntensity = blinkProgress * 2; // 0 -> 1
      } else {
        redFlashIntensity = (1 - blinkProgress) * 2; // 1 -> 0
      }
    }
    if (isInBlinkSequence) {
      // Hover blink sequence - flash red during closing phases
      if (hoverBlinkState === 1 || hoverBlinkState === 3) {
        redFlashIntensity = Math.max(redFlashIntensity, hoverBlinkProgress);
      } else if (hoverBlinkState === 2 || hoverBlinkState === 4) {
        redFlashIntensity = Math.max(redFlashIntensity, 1 - hoverBlinkProgress);
      }
    }
    
    if (isClosed) {
      let scaleY;
      if (isInBlinkSequence) {
        scaleY = hoverBlinkScale;
      } else {
        scaleY = 1 - (effectiveCloseProgress * 0.95);
      }
      if (scaleY < 0.05) scaleY = 0.05;
      
      let darkProgress = effectiveCloseProgress;
      if (isInBlinkSequence) {
        if (hoverBlinkState === 1 || hoverBlinkState === 3) {
          darkProgress = hoverBlinkProgress;
        } else {
          darkProgress = 1 - hoverBlinkProgress;
        }
      }
      const darkIndex = Math.min(10, Math.floor(darkProgress * 10));
      const sprite = this.eyeCache.closed[darkIndex];
      
      this.ctx.save();
      this.ctx.translate(x, y);
      this.ctx.scale(1, scaleY);
      
      // Crossfade between gray and colored sprite
      if (redFlashIntensity > 0) {
        // Each eye gets its own hue based on position for rainbow gradient effect
        const eyeHueOffset = (x / this.canvas.width + y / this.canvas.height) * 180;
        const hueIndex = Math.floor(((this.rainbowHue + eyeHueOffset) % 360 / 360) * 12) % 12;
        const colorSprite = this.rainbowMode 
          ? this.eyeCache.closedRainbow[hueIndex][darkIndex]
          : this.eyeCache.closedRed[darkIndex];
        this.ctx.globalAlpha = 1 - redFlashIntensity;
        this.ctx.drawImage(sprite, -imgW / 2, -imgH / 2);
        this.ctx.globalAlpha = redFlashIntensity;
        this.ctx.drawImage(colorSprite, -imgW / 2, -imgH / 2);
        this.ctx.globalAlpha = 1;
      } else {
        this.ctx.drawImage(sprite, -imgW / 2, -imgH / 2);
      }
      
      this.ctx.restore();
      
      if (scaleY > 0.3) {
        const dx = this.mouseX - x;
        const dy = this.mouseY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        const MAX_MOVE_X = 20 * this.EYE_SCALE;
        const MAX_MOVE_Y = 10 * this.EYE_SCALE;
        const moveX = Math.cos(angle) * Math.min(distance / 8, MAX_MOVE_X);
        const moveY = Math.sin(angle) * Math.min(distance / 8, MAX_MOVE_Y);
        
        this.ctx.beginPath();
        this.ctx.arc(x + moveX, y + moveY, 14 * this.EYE_SCALE, 0, Math.PI * 2);
        this.ctx.fillStyle = '#000000';
        this.ctx.fill();
        
        this.ctx.beginPath();
        this.ctx.arc(x + moveX - 3 * this.EYE_SCALE, y + moveY - 3 * this.EYE_SCALE, 3 * this.EYE_SCALE, 0, Math.PI * 2);
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        this.ctx.fill();
      }
      return;
    }
    
    // Calculate blink scale
    let scaleY = 1;
    if (blinkProgress > 0) {
      if (blinkProgress < 0.35) {
        const t = blinkProgress / 0.35;
        const eased = this.easeInOutCubic(t);
        scaleY = 1 - eased * 0.92;
      } else if (blinkProgress < 0.5) {
        scaleY = 0.08;
      } else if (blinkProgress < 0.85) {
        const t = (blinkProgress - 0.5) / 0.35;
        const eased = this.easeInOutCubic(t);
        scaleY = 0.08 + eased * 0.92;
      } else {
        const t = (blinkProgress - 0.85) / 0.15;
        scaleY = 1 - (1 - t) * 0.02;
      }
    }
    
    this.ctx.save();
    this.ctx.translate(x, y);
    this.ctx.scale(1, scaleY);
    
    // Crossfade between gray and colored sprite
    if (redFlashIntensity > 0) {
      // Each eye gets its own hue based on position for rainbow gradient effect
      const eyeHueOffset = (x / this.canvas.width + y / this.canvas.height) * 180;
      const hueIndex = Math.floor(((this.rainbowHue + eyeHueOffset) % 360 / 360) * 12) % 12;
      const colorSprite = this.rainbowMode 
        ? this.eyeCache.openRainbow[hueIndex]
        : this.eyeCache.openRed;
      this.ctx.globalAlpha = 1 - redFlashIntensity;
      this.ctx.drawImage(this.eyeCache.open, -imgW / 2, -imgH / 2);
      this.ctx.globalAlpha = redFlashIntensity;
      this.ctx.drawImage(colorSprite, -imgW / 2, -imgH / 2);
      this.ctx.globalAlpha = 1;
    } else {
      this.ctx.drawImage(this.eyeCache.open, -imgW / 2, -imgH / 2);
    }
    
    this.ctx.restore();
    
    // Calculate pupil position
    const dx = this.mouseX - x;
    const dy = this.mouseY - y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    
    const MAX_MOVE_X = 20 * this.EYE_SCALE;
    const MAX_MOVE_Y = 10 * this.EYE_SCALE;
    
    const moveX = Math.cos(angle) * Math.min(distance / 8, MAX_MOVE_X);
    const moveY = Math.sin(angle) * Math.min(distance / 8, MAX_MOVE_Y);
    
    if (scaleY > 0.3) {
      this.ctx.beginPath();
      this.ctx.arc(x + moveX, y + moveY, 14 * this.EYE_SCALE, 0, Math.PI * 2);
      this.ctx.fillStyle = '#000000';
      this.ctx.fill();
      
      this.ctx.beginPath();
      this.ctx.arc(x + moveX - 3 * this.EYE_SCALE, y + moveY - 3 * this.EYE_SCALE, 3 * this.EYE_SCALE, 0, Math.PI * 2);
      this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      this.ctx.fill();
    }
  },
  
  animate(currentTime) {
    if (!this.isActive) return;
    
    const deltaTime = currentTime - this.lastTime;
    this.lastTime = currentTime;
    
    // Update rainbow hue for easter egg
    if (this.rainbowMode) {
      this.rainbowHue = (this.rainbowHue + deltaTime * 0.2) % 360;
      // Update input glow color
      if (this.easterEggInput) {
        this.easterEggInput.style.borderColor = `hsl(${this.rainbowHue}, 100%, 50%)`;
        this.easterEggInput.style.boxShadow = `0 0 20px hsl(${this.rainbowHue}, 100%, 50%)`;
      }
    }
    
    // Trigger random blinks
    if (currentTime - this.lastRandomBlink > Math.random() * 4000 + 1000) {
      const numBlinks = Math.floor(Math.random() * 3) + 2;
      for (let i = 0; i < numBlinks; i++) {
        const randomEye = this.eyes[Math.floor(Math.random() * this.eyes.length)];
        if (randomEye && randomEye.blinkState === 0 && !randomEye.permanentlyClosed) {
          randomEye.blinkState = 1;
          randomEye.blinkProgress = 0;
        }
      }
      this.lastRandomBlink = currentTime;
    }
    
    // Clear canvas
    this.ctx.fillStyle = '#000000';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Update and draw all eyes
    this.eyes.forEach(eye => {
      // Update blink animation
      if (eye.blinkState !== 0 && !eye.permanentlyClosed) {
        eye.blinkProgress += deltaTime / 350;
        if (eye.blinkProgress >= 1) {
          eye.blinkState = 0;
          eye.blinkProgress = 0;
        }
      }
      
      // Animate permanent close
      if (eye.permanentlyClosed && eye.closeProgress < 1) {
        eye.closeProgress += deltaTime / 300;
        if (eye.closeProgress > 1) eye.closeProgress = 1;
      } else if (!eye.permanentlyClosed && eye.closeProgress > 0) {
        eye.closeProgress -= deltaTime / 300;
        if (eye.closeProgress < 0) eye.closeProgress = 0;
      }
      
      // Animate hover blink sequence
      if (eye.hoverClosed) {
        switch (eye.hoverBlinkState) {
          case 0:
            eye.hoverBlinkState = 1;
            eye.hoverBlinkProgress = 0;
            break;
          case 1:
            eye.hoverBlinkProgress += deltaTime / 60;
            if (eye.hoverBlinkProgress >= 1) {
              eye.hoverBlinkState = 2;
              eye.hoverBlinkProgress = 0;
            }
            break;
          case 2:
            eye.hoverBlinkProgress += deltaTime / 60;
            if (eye.hoverBlinkProgress >= 1) {
              eye.hoverBlinkState = 3;
              eye.hoverBlinkProgress = 0;
            }
            break;
          case 3:
            eye.hoverBlinkProgress += deltaTime / 60;
            if (eye.hoverBlinkProgress >= 1) {
              eye.hoverBlinkState = 4;
              eye.hoverBlinkProgress = 0;
            }
            break;
          case 4:
            eye.hoverBlinkProgress += deltaTime / 60;
            if (eye.hoverBlinkProgress >= 1) {
              eye.hoverBlinkState = 5;
              eye.hoverBlinkProgress = 0;
            }
            break;
          case 5:
            eye.hoverCloseProgress += deltaTime / 150;
            if (eye.hoverCloseProgress >= 1) {
              eye.hoverCloseProgress = 1;
              eye.hoverBlinkState = 6;
            }
            break;
          case 6:
            break;
        }
      } else {
        if (eye.hoverBlinkState !== 0 || eye.hoverCloseProgress > 0) {
          eye.hoverCloseProgress -= deltaTime / 200;
          if (eye.hoverCloseProgress <= 0) {
            eye.hoverCloseProgress = 0;
            eye.hoverBlinkState = 0;
            eye.hoverBlinkProgress = 0;
          }
        }
      }
      
      this.drawEye(eye);
    });
    
    this.animationId = requestAnimationFrame((t) => this.animate(t));
  },
  
  start() {
    if (this.isActive) return;
    
    console.log('‚ñ∂Ô∏è ContactsEyeSystem starting...');
    this.isActive = true;
    this.mouseX = window.innerWidth / 2;
    this.mouseY = window.innerHeight / 2;
    this.resizeCanvas();
    this.lastTime = performance.now();
    this.lastRandomBlink = 0;
    this.activeHoverPattern = null;
    
    // Reset all eyes
    this.eyes.forEach(eye => {
      eye.blinkState = 0;
      eye.blinkProgress = 0;
      eye.hoverClosed = false;
      eye.hoverCloseProgress = 0;
      eye.hoverBlinkState = 0;
      eye.hoverBlinkProgress = 0;
    });
    
    this.animationId = requestAnimationFrame((t) => this.animate(t));
    console.log('‚úÖ ContactsEyeSystem started');
  },
  
  stop() {
    if (!this.isActive) return;
    
    console.log('‚èπÔ∏è ContactsEyeSystem stopping...');
    this.isActive = false;
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    this.activeHoverPattern = null;
    console.log('‚úÖ ContactsEyeSystem stopped');
  }
};

/* ========================================================================
   LOADING SCREEN COMET ANIMATION
   ======================================================================== */
const LoadingCometAnimation = {
  // üéÆ CONFIGURATION
  ANIMATION_SPEED: 200,
  COMET_LENGTH: 200,
  COMET_SPACING: 600,
  GRADIENT_LAYERS: 8,
  STROKE_THICKNESS: 1,
  TIP_COLOR: '#FF000D',
  TAIL_COLOR: '#000000',
  TIP_OPACITY: 1,
  TAIL_OPACITY: 1,
  RANDOM_START: true,
  COMETS_PER_PATH: 1,

  allAnimatedPaths: [],
  lastTime: performance.now(),
  animationFrame: null,

  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  },

  interpolateColor(color1, color2, factor) {
    const c1 = this.hexToRgb(color1);
    const c2 = this.hexToRgb(color2);
    const r = Math.round(c1.r + factor * (c2.r - c1.r));
    const g = Math.round(c1.g + factor * (c2.g - c1.g));
    const b = Math.round(c1.b + factor * (c2.b - c1.b));
    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
  },

  generateGradient() {
    const colors = [];
    for (let i = 0; i < this.GRADIENT_LAYERS; i++) {
      const factor = i / (this.GRADIENT_LAYERS - 1);
      colors.push(this.interpolateColor(this.TIP_COLOR, this.TAIL_COLOR, factor));
    }
    return colors;
  },

  init() {
    const svg = document.getElementById("loadingSvg");
    const originalGroup = document.getElementById("loading-original-paths");
    const originalPaths = originalGroup.querySelectorAll("path, line, polyline, polygon");

    if (originalPaths.length === 0) {
      console.log('‚ö†Ô∏è No SVG paths found for loading animation');
      return;
    }

    const gradientColors = this.generateGradient();

    originalPaths.forEach((originalPath) => {
      const pathD = originalPath.getAttribute('d');
      const strokeWidth = parseFloat(originalPath.getAttribute('stroke-width')) || this.STROKE_THICKNESS;

      for (let cometIndex = 0; cometIndex < this.COMETS_PER_PATH; cometIndex++) {
        const layerGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svg.appendChild(layerGroup);

        const patternLength = this.COMET_LENGTH + this.COMET_SPACING;
        let baseOffset;

        if (this.RANDOM_START) {
          baseOffset = Math.random() * patternLength;
        } else {
          baseOffset = (cometIndex / this.COMETS_PER_PATH) * patternLength;
        }

        for (let layer = this.GRADIENT_LAYERS - 1; layer >= 0; layer--) {
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          path.setAttribute('d', pathD);
          path.setAttribute('stroke', gradientColors[layer]);
          path.setAttribute('stroke-width', strokeWidth);
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke-linecap', 'round');
          path.setAttribute('stroke-linejoin', 'round');

          const opacityFactor = layer / (this.GRADIENT_LAYERS - 1);
          const opacity = this.TIP_OPACITY + (this.TAIL_OPACITY - this.TIP_OPACITY) * opacityFactor;
          path.setAttribute('opacity', opacity);

          path.style.strokeDasharray = `${this.COMET_LENGTH} ${this.COMET_SPACING}`;

          const layerOffset = (layer / this.GRADIENT_LAYERS) * this.COMET_LENGTH;

          path.dataset.patternLength = patternLength;
          path.dataset.offset = baseOffset;
          path.dataset.layerOffset = layerOffset;
          path.style.strokeDashoffset = baseOffset + layerOffset;

          layerGroup.appendChild(path);
          this.allAnimatedPaths.push(path);
        }
      }
    });

    originalGroup.style.display = 'none';
    this.animate();

    console.log(`‚ú® Loading comet animation initialized: ${originalPaths.length} paths, ${this.allAnimatedPaths.length} total elements`);
  },

  animate() {
    const now = performance.now();
    const delta = (now - this.lastTime) / 1000;
    this.lastTime = now;

    this.allAnimatedPaths.forEach(path => {
      let offset = parseFloat(path.dataset.offset);
      const patternLength = parseFloat(path.dataset.patternLength);
      const layerOffset = parseFloat(path.dataset.layerOffset);

      offset -= this.ANIMATION_SPEED * delta;
      offset %= patternLength;

      path.dataset.offset = offset;
      path.style.strokeDashoffset = offset + layerOffset;
    });

    this.animationFrame = requestAnimationFrame(() => this.animate());
  },

  stop() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
  }
};

/* ========================================================================
   INIT
   ======================================================================== */
document.addEventListener('DOMContentLoaded', () => {
  DeviceDetector.init();
  LoadingCometAnimation.init();
  Preloader.init();
  IconPositioner.init();

  // Create sprite sheet icons with SIMPLIFIED SPEEDS
  window.iconInstances = {};
  const iconIds = ['art', 'contacts', 'edu', 'work'];
  
  iconIds.forEach(id => {
    try {
      const el = Utils.getElement(`icon-${id}`);
      if (!el) {
        console.error(`\u274c Icon element not found: icon-${id}`);
        return;
      }
      console.log(`‚úÖ Found icon-${id}:`, el);
      
      // Create icon instance based on ID
      if (id === 'art') {
        window.iconInstances.art = new SpriteSheetIcon(el, 48, 180, 169, 8640, 18, { forwardSpeed: 0.1, reverseSpeed: 0.3 });
      } else if (id === 'contacts') {
        window.iconInstances.contacts = new SpriteSheetIcon(el, 30, 180, 203, 5400, 17, { forwardSpeed: 0.03, reverseSpeed: 0.3 });
      } else if (id === 'edu') {
        window.iconInstances.edu = new SpriteSheetIcon(el, 73, 180, 105, 13136, 45, { forwardSpeed: 0.035, reverseSpeed: 0.5 });
      } else if (id === 'work') {
        window.iconInstances.work = new SpriteSheetIcon(el, 29, 180, 226, 5220, null, { loopSpeed: 0.2, reverseSpeed: 0.3 });
      }
      console.log(`\u2714\ufe0f Icon ${id} created successfully`);
    } catch (e) {
      console.error(`\u274c Error creating icon ${id}:`, e);
    }
  });

  console.log('‚úÖ All icon instances created:', window.iconInstances);

  TransitionManager.init();
  EyeSystem.init();
  ContactsEyeSystem.init();
  
  // Handle window resize for contacts canvas
  window.addEventListener('resize', () => {
    if (ContactsEyeSystem.isActive) {
      ContactsEyeSystem.resizeCanvas();
    }
  });
  
  Utils.log('‚úÖ Application initialized with sprite sheets!');
});
</script>
</body>
</html>

