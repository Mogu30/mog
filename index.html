<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MOG - Portfolio</title>

<style>
/* ========================================================================
   CSS VARIABLES - Easy theming and maintenance
   ======================================================================== */
:root {
  /* Z-index layers */
  --z-background: 0;
  --z-content: 1;
  --z-icons: 2;
  --z-transition: 999;
  --z-loading: 9999;
  
  /* Colors */
  --color-bg: black;
  --color-text: white;
  --color-accent: #333;
  
  /* Timing */
  --transition-fast: 0.1s;
  --transition-normal: 0.3s;
  --transition-slow: 0.5s;
  --transition-eye: 0.8s;
  
  /* Spacing */
  --space-sm: 1rem;
  --space-md: 2rem;
  --space-lg: 3rem;
}

/* ========================================================================
   BASE STYLES
   ======================================================================== */
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: var(--color-bg);
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ========================================================================
   LOADING SCREEN
   ======================================================================== */
#loadingScreen {
  position: fixed;
  inset: 0;
  background: var(--color-bg);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: var(--z-loading);
  color: var(--color-text);
  font-family: Arial, sans-serif;
}

#loadingScreen h2 {
  font-size: 2rem;
  margin-bottom: var(--space-sm);
}

#loadingProgress {
  font-size: 1.2rem;
  opacity: 0.7;
}

/* ========================================================================
   MAIN CONTAINER
   ======================================================================== */
#container {
  position: relative;
  width: 100vw;
  height: 100vh;
  max-width: calc(100vh * 16 / 9);
  max-height: calc(100vw * 9 / 16);
  background: var(--color-bg);
  opacity: 0;
  transition: opacity var(--transition-slow) ease;
}

#container.loaded {
  opacity: 1;
}

/* ========================================================================
   BACKGROUND VIDEO & FREEZE
   ======================================================================== */
#bgVideo,
#bgFreeze {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  z-index: var(--z-background);
}

#bgFreeze {
  display: none;
}

/* ========================================================================
   CONTENT LAYERS
   ======================================================================== */
#mainContent {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-content);
}

#contactsPage {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  background: var(--color-bg);
  color: var(--color-text);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: var(--z-content);
  font-family: Arial, sans-serif;
}

/* ========================================================================
   TRANSITION VIDEO OVERLAY
   ======================================================================== */
#transitionVideo {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  z-index: var(--z-transition);
  display: none;
  pointer-events: none;
}

/* ========================================================================
   SVG & EYE SYSTEM
   ======================================================================== */
svg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-content);
  will-change: transform;
  transform: translateZ(0);
}

#eyeOffset {
  opacity: 0;
  transition: opacity var(--transition-eye) ease;
}

#blinkLid {
  transform-origin: 50% 50%;
  transform: scaleY(0);
  pointer-events: none;
}

/* Moved inline style to CSS */
#reflections {
  mix-blend-mode: screen;
}

@keyframes blink {
  0%   { transform: scaleY(0) translateY(-50%); }
  45%  { transform: scaleY(1) translateY(0%); }
  55%  { transform: scaleY(1) translateY(0%); }
  100% { transform: scaleY(0) translateY(-50%); }
}

/* ========================================================================
   ICONS
   ======================================================================== */
.icon {
  position: absolute;
  width: 180px;
  height: 180px;
  transform-origin: center center;
  z-index: var(--z-icons);
  pointer-events: auto;
  cursor: pointer;
  filter: drop-shadow(0 0 0px rgba(0,0,0,0));
  opacity: 1;
  transition: filter var(--transition-fast) ease, opacity var(--transition-normal) ease;
  will-change: transform;
  transform: translateZ(0);
  backface-visibility: hidden;
}

.icon.hidden {
  opacity: 0;
  pointer-events: none;
}

.icon img {
  width: 100%;
  height: 100%;
  display: block;
  object-fit: contain;
  pointer-events: none;
}

/* ========================================================================
   CONTACTS PAGE
   ======================================================================== */
#contactsPage h1 {
  font-size: 4rem;
  margin-bottom: var(--space-md);
  text-transform: uppercase;
  letter-spacing: 0.5rem;
}

#contactsPage p {
  font-size: 1.5rem;
  margin-bottom: var(--space-lg);
  opacity: 0.7;
}

#backButton {
  padding: var(--space-sm) var(--space-lg);
  font-size: 1.2rem;
  background: var(--color-text);
  color: var(--color-bg);
  border: none;
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 0.2rem;
  transition: all var(--transition-normal) ease;
}

#backButton:hover {
  background: var(--color-accent);
  color: var(--color-text);
  transform: scale(1.05);
}
</style>
</head>

<body>

<!-- Loading Screen -->
<div id="loadingScreen">
  <h2>Loading...</h2>
  <p id="loadingProgress">Preparing assets...</p>
</div>

<div id="container">
  <video id="bgVideo" autoplay muted playsinline>
    <source src="mog.mov">
  </video>
  <canvas id="bgFreeze"></canvas>
  
  <!-- Main home page with eye and icons -->
  <div id="mainContent">
    <!-- Icons with accessibility labels -->
    <div class="icon" id="icon-art" role="button" aria-label="Art Portfolio" tabindex="0">
      <img src="frames/art/Frame_00000.png" alt="Art Portfolio Icon">
    </div>
    <div class="icon" id="icon-edu" role="button" aria-label="Education" tabindex="0">
      <img src="frames/edu/Frame_00000.png" alt="Education Icon">
    </div>
    <div class="icon" id="icon-contacts" role="button" aria-label="Contacts" tabindex="0">
      <img src="frames/contacts/Frame_00000.png" alt="Contacts Icon">
    </div>
    <div class="icon" id="icon-work" role="button" aria-label="Work" tabindex="0">
      <img src="frames/work/Frame_00000.png" alt="Work Icon">
    </div>

    <svg viewBox="0 0 1920 1080" aria-hidden="true">
      <defs>
        <mask id="eyeMask" maskUnits="userSpaceOnUse">
          <image href="mask.png" x="0" y="0" width="1920" height="1080" preserveAspectRatio="none"/>
        </mask>
      </defs>

      <g id="eyeContainer" transform="translate(960,535) scale(1) translate(-960,-540)">
        <g id="eyeOffset">
          <image href="White.png" x="0" y="0" width="1920" height="1080"/>
          <g mask="url(#eyeMask)">
            <g id="eyeMove">
              <image href="Iris.png" x="0" y="0" width="1920" height="1080"/>
            </g>
            <!-- Moved inline style to CSS -->
            <image id="reflections" href="reflections.png" x="-690" y="-487" width="3090" height="2390" />
            <rect id="blinkLid" x="0" y="0" width="1920" height="1080" fill="black"/>
          </g>
        </g>
      </g>
    </svg>
  </div>
  
  <!-- Contacts Page -->
  <div id="contactsPage">
    <h1>Contacts</h1>
    <p>This is the contacts page content.</p>
    <p>You can add your contact information here!</p>
    <button id="backButton">‚Üê Back to Home</button>
  </div>
  
  <!-- Transition Video overlay -->
  <video id="transitionVideo" muted playsinline>
    <source src="" type="video/webm">
  </video>
</div>

<!-- In production, this would be: <script src="main.js"></script> -->
<script>
'use strict';

/* ========================================================================
   CONFIGURATION CONSTANTS - All magic numbers in one place!
   ======================================================================== */
const CONFIG = {
  // Asset paths
  ASSETS: {
    CRITICAL: [
      'mog.mov',
      'White.png',
      'Iris.png',
      'mask.png',
      'reflections.png',
      'transition.webm',
      'reverse.webm'
    ]
  },
  
  // Timing constants
  TIMING: {
    ICON_FADE_DELAY: 2168,
    BLINK_AFTER_TRANSITION: 150,
    EYE_ACTIVATE_TIME: 4.037,
    RESET_EYE_DURATION: 800,
    LOADING_DELAY: 500,
    BLINK_SPEED: 150,
    DOUBLE_BLINK_DELAY: 180,
    BLINK_MIN_DELAY: 2400,
    BLINK_MAX_DELAY: 5000,
    EYE_FALLBACK_TIMEOUT: 8000
  },
  
  // Icon animation speeds
  ICON_SPEEDS: {
    CHARGE_TIME: 500,
    ART_FORWARD: 2,
    ART_REVERSE: 0.3,
    EDU_FORWARD: 0.3,
    EDU_REVERSE: 0.3,
    CONTACTS_FORWARD: 0.85,
    CONTACTS_REVERSE: 0.3,
    WORK_LOOP: 0.2,
    WORK_REVERSE: 0.3
  },
  
  // Layout
  LAYOUT: {
    DESIGN_WIDTH: 1920,
    DESIGN_HEIGHT: 1080
  },
  
  // Icon positions
  ICON_SETTINGS: {
    "icon-art":      { x: 220,  y: 810, scale: 2.5 },
    "icon-edu":      { x: 230,  y: 225, scale: 2.5 },
    "icon-work":     { x: 1690, y: 235, scale: 2.25 },
    "icon-contacts": { x: 1690, y: 810, scale: 2.35 }
  },
  
  // Transition
  TRANSITION: {
    OFFSET: 1, // Vertical offset for transition video
    FORWARD_PATH: 'transition.webm',
    REVERSE_PATH: 'reverse.webm'
  },
  
  // Eye animation
  EYE: {
    DOUBLE_BLINK_CHANCE: 0.3
  },
  
  // Debug mode
  DEBUG: false // Set to true to enable console logs
};

/* ========================================================================
   UTILITY FUNCTIONS
   ======================================================================== */
const Utils = {
  /**
   * Safely log to console if debug mode is enabled
   */
  log: (...args) => {
    if (CONFIG.DEBUG) console.log(...args);
  },
  
  /**
   * Delay execution
   * @param {number} ms - Milliseconds to wait
   * @returns {Promise}
   */
  wait: (ms) => new Promise(resolve => setTimeout(resolve, ms)),
  
  /**
   * Get element by ID with error checking
   * @param {string} id - Element ID
   * @returns {HTMLElement}
   */
  getElement: (id) => {
    const el = document.getElementById(id);
    if (!el) console.error(`Element not found: ${id}`);
    return el;
  }
};

/* ========================================================================
   PRELOADER MODULE
   ======================================================================== */
const Preloader = {
  loadedCount: 0,
  totalAssets: CONFIG.ASSETS.CRITICAL.length,
  
  /**
   * Initialize and run the preloader
   */
  init() {
    const loadingScreen = Utils.getElement('loadingScreen');
    const loadingProgress = Utils.getElement('loadingProgress');
    const container = Utils.getElement('container');
    
    CONFIG.ASSETS.CRITICAL.forEach(src => {
      const ext = src.split('.').pop();
      
      if (['mp4', 'mov', 'webm'].includes(ext)) {
        this.preloadVideo(src);
      } else {
        this.preloadImage(src);
      }
    });
    
    /**
     * Update loading progress
     */
    const updateProgress = () => {
      this.loadedCount++;
      const percent = Math.round((this.loadedCount / this.totalAssets) * 100);
      loadingProgress.textContent = `Loading assets... ${percent}%`;
      
      if (this.loadedCount === this.totalAssets) {
        setTimeout(() => {
          loadingScreen.style.display = 'none';
          container.classList.add('loaded');
        }, CONFIG.TIMING.LOADING_DELAY);
      }
    };
    
    this.updateProgress = updateProgress;
  },
  
  /**
   * Preload a video file
   * @param {string} src - Video source path
   */
  preloadVideo(src) {
    const video = document.createElement('video');
    video.onloadeddata = () => this.updateProgress();
    video.onerror = () => this.updateProgress();
    video.src = src;
  },
  
  /**
   * Preload an image file
   * @param {string} src - Image source path
   */
  preloadImage(src) {
    const img = new Image();
    img.onload = () => this.updateProgress();
    img.onerror = () => this.updateProgress();
    img.src = src;
  }
};

/* ========================================================================
   ICON POSITIONING MODULE
   ======================================================================== */
const IconPositioner = {
  /**
   * Position all icons based on viewport size
   */
  positionIcons() {
    const container = Utils.getElement('container');
    const containerWidth = container.offsetWidth;
    const containerHeight = container.offsetHeight;
    
    for (const id in CONFIG.ICON_SETTINGS) {
      const el = Utils.getElement(id);
      if (!el) continue;
      
      const s = CONFIG.ICON_SETTINGS[id];
      const scaleX = containerWidth / CONFIG.LAYOUT.DESIGN_WIDTH;
      const scaleY = containerHeight / CONFIG.LAYOUT.DESIGN_HEIGHT;
      const scale = Math.min(scaleX, scaleY);

      el.style.left = (s.x / CONFIG.LAYOUT.DESIGN_WIDTH) * 100 + "%";
      el.style.top  = (s.y / CONFIG.LAYOUT.DESIGN_HEIGHT) * 100 + "%";
      el.style.transform = `translate(-50%, -50%) scale(${s.scale * scale})`;
    }
  },
  
  /**
   * Initialize icon positioning with resize listener
   */
  init() {
    this.positionIcons();
    window.addEventListener('resize', () => this.positionIcons());
  }
};

/* ========================================================================
   SEQUENCE ICON CLASS - Handles frame-by-frame icon animations
   ======================================================================== */
/* ========================================================================
   SEQUENCE ICON CLASS - Handles frame-by-frame icon animations
   ======================================================================== */
/**
 * Animates an icon using frame sequences
 * @class
 */
class SequenceIcon {
  /**
   * @param {HTMLElement} element - The icon container element
   * @param {number} frameCount - Total number of frames in the sequence
   * @param {string} folder - Folder name containing frame images
   * @param {number|null} holdFrame - Frame to hold on when charged (null for looping)
   * @param {number} speed - Base animation speed
   * @param {number} forwardSpeed - Speed multiplier for forward animation
   * @param {number} reverseSpeed - Speed multiplier for reverse animation
   * @param {number} loopSpeed - Speed multiplier for looping animation
   */
  constructor(element, frameCount, folder, holdFrame = null, speed = 0.04, forwardSpeed = 0.5, reverseSpeed = 0.3, loopSpeed = 0.2) {
    this.element = element;
    this.img = element.querySelector('img');
    this.frameCount = frameCount;
    this.folder = folder;
    this.holdFrame = holdFrame;
    this.speed = speed;
    this.forwardSpeed = forwardSpeed;
    this.reverseSpeed = reverseSpeed;
    this.loopSpeed = loopSpeed;
    this.currentFrame = 0;
    this.targetFrame = 0;
    this.isHovering = false;
    this.isHolding = false;
    this.isCharged = false;
    this.chargeTimer = null;
    this.isClickable = true;
    
    this.preloadFrames();
    this.setupListeners();
    this.animate();
  }
  
  /**
   * Preload all frame images
   */
  preloadFrames() {
    this.frames = [];
    for (let i = 0; i < this.frameCount; i++) {
      const img = new Image();
      const frameNum = String(i).padStart(5, '0');
      img.src = `frames/${this.folder}/Frame_${frameNum}.png`;
      this.frames.push(img);
    }
  }
  
  /**
   * Reset icon to initial state
   */
  reset() {
    this.isHovering = false;
    this.isHolding = false;
    this.isCharged = false;
    this.isClickable = true;
    this.targetFrame = 0;
    this.element.style.filter = "drop-shadow(0 0 0px rgba(0,0,0,0))";
    if (this.chargeTimer) {
      clearTimeout(this.chargeTimer);
      this.chargeTimer = null;
    }
  }
  
  /**
   * Setup mouse event listeners
   */
  setupListeners() {
    this.element.addEventListener('mouseenter', () => {
      // Don't respond if icon is hidden
      if (this.element.classList.contains('hidden')) return;
      
      this.isHovering = true;
      this.isCharged = false;
      this.isClickable = true;
      this.element.style.filter =
        "drop-shadow(0 0 10px rgba(0,0,0,1)) drop-shadow(0 0 18px rgba(0,0,0,1)) drop-shadow(0 0 28px rgba(0,0,0,1))";
      this.chargeTimer = setTimeout(() => {
        this.isCharged = true;
        if (this.holdFrame !== null) this.targetFrame = this.holdFrame;
      }, CONFIG.ICON_SPEEDS.CHARGE_TIME);
    });
    
    this.element.addEventListener('mouseleave', () => {
      this.reset();
    });
  }
  
  /**
   * Animation loop
   */
  animate() {
    if (this.isCharged) {
      if (this.holdFrame === null) {
        // Looping animation
        this.currentFrame += this.speed * this.frameCount * this.loopSpeed;
        if (this.currentFrame >= this.frameCount - 1) this.currentFrame = 0;
      } else {
        // Hold frame animation
        if (this.isHovering && !this.isHolding && Math.abs(this.currentFrame - this.holdFrame) < 0.5) {
          this.isHolding = true;
          this.isClickable = true;
          this.currentFrame = this.holdFrame;
          this.targetFrame = this.holdFrame;
        }
        if (!this.isHolding) {
          const distance = Math.abs(this.targetFrame - this.currentFrame);
          let easingSpeed = this.speed * this.forwardSpeed;
          if (distance < 2) easingSpeed = 0.5;
          this.currentFrame += (this.targetFrame - this.currentFrame) * easingSpeed;
          if (distance < 0.1) this.currentFrame = this.targetFrame;
        }
      }
    } else {
      // Reverse animation
      if (this.currentFrame > 0) {
        this.currentFrame -= this.speed * this.frameCount * this.reverseSpeed;
        if (this.currentFrame < 0) this.currentFrame = 0;
      }
    }
    
    // Update image
    const frameIndex = Math.round(this.currentFrame);
    if (this.frames[frameIndex] && this.frames[frameIndex].complete) {
      this.img.src = this.frames[frameIndex].src;
    }
    
    requestAnimationFrame(() => this.animate());
  }
}
/* ========================================================================
   TRANSITION MANAGER - Handles page transitions
   ======================================================================== */
const TransitionManager = {
  isTransitioning: false,
  transitionVideo: null,
  contactsPage: null,
  mainContent: null,
  
  /**
   * Initialize transition manager
   */
  init() {
    this.transitionVideo = Utils.getElement('transitionVideo');
    this.contactsPage = Utils.getElement('contactsPage');
    this.mainContent = Utils.getElement('mainContent');
    const backButton = Utils.getElement('backButton');
    
    // Setup click handlers
    this.setupForwardTransition();
    this.setupReverseTransition(backButton);
  },
  
  /**
   * Setup video for transition
   * @param {string} videoPath - Path to transition video
   * @returns {Promise}
   */
  async setupTransitionVideo(videoPath) {
    const video = this.transitionVideo;
    const source = video.querySelector('source');
    
    video.style.transform = `translateY(${CONFIG.TRANSITION.OFFSET}px)`;
    source.src = videoPath;
    video.load();
    video.style.display = 'block';
    video.currentTime = 0;
    
    return video.play();
  },
  
  /**
   * Setup forward transition (Home ‚Üí Contacts)
   */
  setupForwardTransition() {
    const contactsIcon = window.iconInstances.contacts;
    
    Utils.getElement('icon-contacts').addEventListener('click', async () => {
      if (this.isTransitioning || !contactsIcon.isClickable) return;
      
      this.isTransitioning = true;
      
      try {
        EyeSystem.blinkOnce();
        await Utils.wait(CONFIG.TIMING.BLINK_AFTER_TRANSITION);
        await EyeSystem.resetToCenter();
        
        await this.setupTransitionVideo(CONFIG.TRANSITION.FORWARD_PATH);
        
        // Fade out icons
        setTimeout(() => {
          document.querySelectorAll('.icon').forEach(icon => {
            icon.classList.add('hidden');
          });
        }, CONFIG.TIMING.ICON_FADE_DELAY);
        
        // Wait for video to end
        await new Promise(resolve => {
          this.transitionVideo.onended = resolve;
        });
        
        // Switch pages
        this.mainContent.style.display = 'none';
        this.contactsPage.style.display = 'flex';
        this.transitionVideo.style.display = 'none';
        
        Utils.getElement('bgFreeze').style.display = 'block';
        
      } catch (error) {
        console.error('Forward transition error:', error);
        this.handleTransitionError(true);
      } finally {
        this.isTransitioning = false;
      }
    });
  },
  
  /**
   * Setup reverse transition (Contacts ‚Üí Home)
   * @param {HTMLElement} backButton - Back button element
   */
  setupReverseTransition(backButton) {
    backButton.addEventListener('click', async () => {
      if (this.isTransitioning) return;
      
      this.isTransitioning = true;
      
      try {
        this.contactsPage.style.display = 'none';
        Utils.getElement('bgFreeze').style.display = 'block';
        this.mainContent.style.display = 'block';
        
        // Show icons immediately
        document.querySelectorAll('.icon').forEach(icon => {
          icon.classList.remove('hidden');
          icon.style.opacity = '1';
        });
        
        // Reset eye opacity
        const eyeOffset = Utils.getElement('eyeOffset');
        eyeOffset.style.transition = 'none';
        eyeOffset.style.opacity = '1';
        void eyeOffset.offsetHeight;
        eyeOffset.style.transition = 'opacity 0.8s ease';
        
        // Play reverse video
        await this.setupTransitionVideo(CONFIG.TRANSITION.REVERSE_PATH);
        
        await new Promise(resolve => {
          this.transitionVideo.onended = resolve;
        });
        
        this.transitionVideo.style.display = 'none';
        
        // Blink after transition
        setTimeout(() => {
          EyeSystem.blinkOnce();
        }, 100);
        
        Utils.log('‚úÖ Reverse transition complete');
        
      } catch (error) {
        console.error('Reverse transition error:', error);
        this.handleTransitionError(false);
      } finally {
        this.isTransitioning = false;
      }
    });
  },
  
  /**
   * Handle transition errors
   * @param {boolean} showContacts - Whether to show contacts page on error
   */
  handleTransitionError(showContacts) {
    this.transitionVideo.style.display = 'none';
    
    if (showContacts) {
      this.mainContent.style.display = 'none';
      this.contactsPage.style.display = 'flex';
    } else {
      this.contactsPage.style.display = 'none';
      this.mainContent.style.display = 'block';
      Utils.getElement('eyeOffset').style.opacity = '1';
      
      document.querySelectorAll('.icon').forEach(icon => {
        icon.classList.remove('hidden');
        icon.style.opacity = '1';
      });
    }
  }
};

/* ========================================================================
   EYE SYSTEM - Handles eye tracking and blinking
   ======================================================================== */
const EyeSystem = {
  eyeMove: null,
  eyeOffset: null,
  blinkLid: null,
  bgVideo: null,
  bgFreeze: null,
  ctx: null,
  eyeActive: false,
  eyeActivationTriggered: false,
  
  /**
   * Initialize the eye system
   */
  init() {
    this.eyeMove = Utils.getElement("eyeMove");
    this.eyeOffset = Utils.getElement("eyeOffset");
    this.blinkLid = Utils.getElement("blinkLid");
    this.bgVideo = Utils.getElement("bgVideo");
    this.bgFreeze = Utils.getElement("bgFreeze");
    this.ctx = this.bgFreeze.getContext("2d");
    
    this.setupVideoListeners();
    this.setupMouseTracking();
    this.setupFallback();
  },
  
  /**
   * Setup video event listeners for eye activation
   */
  setupVideoListeners() {
    this.bgVideo.addEventListener('loadeddata', () => {
      Utils.log('üé• Background video loaded!');
    });
    
    this.bgVideo.addEventListener('timeupdate', () => {
      if (this.eyeActivationTriggered || this.eyeActive) return;
      
      if (this.bgVideo.currentTime >= CONFIG.TIMING.EYE_ACTIVATE_TIME) {
        this.activateEye();
      }
    });
    
    this.bgVideo.addEventListener('ended', () => {
      if (this.eyeActivationTriggered || this.eyeActive) return;
      this.activateEye();
    });
  },
  
  /**
   * Activate the eye (freeze video and start blinking)
   */
  activateEye() {
    this.eyeActivationTriggered = true;
    
    this.bgFreeze.width = this.bgVideo.videoWidth;
    this.bgFreeze.height = this.bgVideo.videoHeight;
    
    Utils.log('üñºÔ∏è Freezing at:', this.bgFreeze.width, 'x', this.bgFreeze.height);
    
    if (this.bgFreeze.width > 0 && this.bgFreeze.height > 0) {
      try {
        this.ctx.drawImage(this.bgVideo, 0, 0, this.bgFreeze.width, this.bgFreeze.height);
        
        this.bgVideo.style.display = "none";
        this.bgFreeze.style.display = "block";
        
        this.eyeOffset.style.opacity = "1";
        this.eyeActive = true;
        
        setTimeout(() => {
          this.blinkOnce();
        }, 100);
        
        this.startBlinking();
        Utils.log('‚úÖ Eye activated!');
      } catch (error) {
        console.error('Failed to draw video to canvas:', error);
      }
    }
  },
  
  /**
   * Setup mouse tracking for eye movement
   */
  setupMouseTracking() {
    document.addEventListener("mousemove", (e) => {
      if (this.eyeActive) {
        const x = (e.clientX / window.innerWidth  - 0.5) * 120;
        const y = (e.clientY / window.innerHeight - 0.5) * 60;
        this.eyeMove.setAttribute("transform", `translate(${x}, ${y})`);
      }
    });
  },
  
  /**
   * Setup fallback in case video doesn't load
   */
  setupFallback() {
    setTimeout(() => {
      if (!this.eyeActive) {
        console.warn('‚ö†Ô∏è Activating eye without background video');
        this.eyeOffset.style.opacity = "1";
        this.eyeActive = true;
        this.startBlinking();
      }
    }, CONFIG.TIMING.EYE_FALLBACK_TIMEOUT);
  },
  
  /**
   * Perform a single blink
   */
  blinkOnce() {
    this.blinkLid.style.animation = `blink ${CONFIG.TIMING.BLINK_SPEED}ms ease-in-out`;
    this.blinkLid.addEventListener("animationend", () => {
      this.blinkLid.style.animation = "";
    }, { once: true });
  },
  
  /**
   * Perform a blink (with chance of double blink)
   */
  blink() {
    this.blinkOnce();
    if (Math.random() < CONFIG.EYE.DOUBLE_BLINK_CHANCE) {
      setTimeout(() => this.blinkOnce(), CONFIG.TIMING.DOUBLE_BLINK_DELAY);
    }
  },
  
  /**
   * Start the blinking loop
   */
  startBlinking() {
    const loop = () => {
      this.blink();
      const delay = CONFIG.TIMING.BLINK_MIN_DELAY + 
                    Math.random() * (CONFIG.TIMING.BLINK_MAX_DELAY - CONFIG.TIMING.BLINK_MIN_DELAY);
      setTimeout(loop, delay);
    };
    loop();
  },
  
  /**
   * Reset eye to center position
   * @returns {Promise}
   */
  resetToCenter() {
    return new Promise((resolve) => {
      const transformAttr = this.eyeMove.getAttribute('transform') || 'translate(0, 0)';
      const matches = transformAttr.match(/translate\(([-\d.]+),\s*([-\d.]+)\)/);
      
      const startX = matches ? parseFloat(matches[1]) : 0;
      const startY = matches ? parseFloat(matches[2]) : 0;
      
      const startTime = performance.now();
      
      const animate = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / CONFIG.TIMING.RESET_EYE_DURATION, 1);
        const eased = 1 - Math.pow(1 - progress, 3);
        
        const currentX = startX * (1 - eased);
        const currentY = startY * (1 - eased);
        
        this.eyeMove.setAttribute('transform', `translate(${currentX}, ${currentY})`);
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };
      
      requestAnimationFrame(animate);
    });
  }
};

/* ========================================================================
   INITIALIZATION - Start everything when DOM is ready
   ======================================================================== */
document.addEventListener('DOMContentLoaded', () => {
  // Initialize preloader
  Preloader.init();
  
  // Initialize icon positioning
  IconPositioner.init();
  
  // Create icon instances
  window.iconInstances = {
    art: new SequenceIcon(
      Utils.getElement('icon-art'),
      28, 'art', 20, 0.028,
      CONFIG.ICON_SPEEDS.ART_FORWARD,
      CONFIG.ICON_SPEEDS.ART_REVERSE
    ),
    edu: new SequenceIcon(
      Utils.getElement('icon-edu'),
      21, 'edu', 24, 0.025,
      CONFIG.ICON_SPEEDS.EDU_FORWARD,
      CONFIG.ICON_SPEEDS.EDU_REVERSE
    ),
    contacts: new SequenceIcon(
      Utils.getElement('icon-contacts'),
      30, 'contacts', 12, 0.030,
      CONFIG.ICON_SPEEDS.CONTACTS_FORWARD,
      CONFIG.ICON_SPEEDS.CONTACTS_REVERSE
    ),
    work: new SequenceIcon(
      Utils.getElement('icon-work'),
      29, 'work', null, 0.029,
      null,
      CONFIG.ICON_SPEEDS.WORK_REVERSE,
      CONFIG.ICON_SPEEDS.WORK_LOOP
    )
  };
  
  // Initialize transition manager
  TransitionManager.init();
  
  // Initialize eye system
  EyeSystem.init();
  
  Utils.log('‚úÖ Application initialized!');
});
</script>

</body>
</html>
