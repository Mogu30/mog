<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MOG </title>

<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: black;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Loading screen */
#loadingScreen {
  position: fixed;
  inset: 0;
  background: black;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  color: white;
  font-family: Arial, sans-serif;
}

#loadingScreen h2 {
  font-size: 2rem;
  margin-bottom: 1rem;
}

#loadingProgress {
  font-size: 1.2rem;
  opacity: 0.7;
}

#container {
  position: relative;
  width: 100vw;
  height: 100vh;
  max-width: calc(100vh * 16 / 9);
  max-height: calc(100vw * 9 / 16);
  background: black;
  opacity: 0;
  transition: opacity 0.5s ease;
}

#container.loaded {
  opacity: 1;
}

#bgGif,
#bgFreeze {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  z-index: 0;
}

#bgFreeze {
  display: none;
}

/* Main home page content */
#mainContent {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

/* Contacts Page - same level as main content */
#contactsPage {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  background: black;
  color: white;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1;
  font-family: Arial, sans-serif;
}

/* Transition GIF - plays ON TOP of everything as an overlay */
#transitionGif {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  z-index: 999;
  display: none;
  pointer-events: none;
}

svg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

.icon {
  position: absolute;
  width: 180px;
  height: 180px;
  transform-origin: center center;
  z-index: 2;
  pointer-events: auto;
  cursor: pointer;
  filter: drop-shadow(0 0 0px rgba(0,0,0,0));
  transition: filter 0.1s ease;
}

.icon img {
  width: 100%;
  height: 100%;
  display: block;
  object-fit: contain;
  pointer-events: none;
}

#eyeOffset {
  opacity: 0;
  transition: opacity 0.8s ease;
}

#blinkLid {
  transform-origin: 50% 50%;
  transform: scaleY(0);
  pointer-events: none;
}

@keyframes blink {
  0%   { transform: scaleY(0); }
  45%  { transform: scaleY(1); }
  55%  { transform: scaleY(1); }
  100% { transform: scaleY(0); }
}

#contactsPage h1 {
  font-size: 4rem;
  margin-bottom: 2rem;
  text-transform: uppercase;
  letter-spacing: 0.5rem;
}

#contactsPage p {
  font-size: 1.5rem;
  margin-bottom: 3rem;
  opacity: 0.7;
}

#backButton {
  padding: 1rem 3rem;
  font-size: 1.2rem;
  background: white;
  color: black;
  border: none;
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 0.2rem;
  transition: all 0.3s ease;
}

#backButton:hover {
  background: #333;
  color: white;
  transform: scale(1.05);
}
</style>
</head>

<body>

<!-- Loading Screen -->
<div id="loadingScreen">
  <h2>Loading...</h2>
  <p id="loadingProgress">Preparing assets...</p>
</div>

<div id="container">
  <img id="bgGif" src="mog.gif" alt="">
  <canvas id="bgFreeze"></canvas>
  
  <!-- Main home page with eye and icons -->
  <div id="mainContent">
    <div class="icon" id="icon-art"><img src="frames/art/Frame_00000.png" alt="Art"></div>
    <div class="icon" id="icon-edu"><img src="frames/edu/Frame_00000.png" alt="Education"></div>
    <div class="icon" id="icon-contacts"><img src="frames/contacts/Frame_00000.png" alt="Contacts"></div>
    <div class="icon" id="icon-work"><img src="frames/work/Frame_00000.png" alt="Work"></div>

    <svg viewBox="0 0 1920 1080">
      <defs>
        <mask id="eyeMask" maskUnits="userSpaceOnUse">
          <image href="mask.png" x="0" y="0" width="1920" height="1080" preserveAspectRatio="none"/>
        </mask>
      </defs>

      <g id="eyeContainer" transform="translate(960,535) scale(1) translate(-960,-540)">
        <g id="eyeOffset">
          <image href="White.png" x="0" y="0" width="1920" height="1080"/>
          <g mask="url(#eyeMask)">
            <g id="eyeMove">
              <image href="Iris.png" x="0" y="0" width="1920" height="1080"/>
            </g>
            <image href="reflections.png" x="-690" y="-487" width="3090" height="2390" style="mix-blend-mode: screen;" />
            <rect id="blinkLid" x="0" y="0" width="1920" height="1080" fill="black"/>
          </g>
        </g>
      </g>
    </svg>
  </div>
  
  <!-- Contacts Page (hidden by default) -->
  <div id="contactsPage">
    <h1>Contacts</h1>
    <p>This is the contacts page content.</p>
    <p>You can add your contact information here!</p>
    <button id="backButton">‚Üê Back to Home</button>
  </div>
  
  <!-- Transition GIF overlay (plays on top of current page) -->
  <img id="transitionGif" src="" alt="">
</div>

<script>
/* ======================================================================== */
/* PRELOADER */
/* ======================================================================== */

const loadingScreen = document.getElementById('loadingScreen');
const loadingProgress = document.getElementById('loadingProgress');
const container = document.getElementById('container');

const criticalAssets = [
  'mog.gif',
  'White.png',
  'Iris.png',
  'mask.png',
  'reflections.png',
  'transition.gif',
  'reverse.gif'
];

let loadedCount = 0;
const totalAssets = criticalAssets.length;

function updateProgress() {
  loadedCount++;
  const percent = Math.round((loadedCount / totalAssets) * 100);
  loadingProgress.textContent = `Loading assets... ${percent}%`;
  
  if (loadedCount === totalAssets) {
    setTimeout(() => {
      loadingScreen.style.display = 'none';
      container.classList.add('loaded');
    }, 500);
  }
}

criticalAssets.forEach(src => {
  const img = new Image();
  img.onload = () => updateProgress();
  img.onerror = () => updateProgress();
  img.src = src;
});

/* ======================================================================== */
/* ICON SYSTEM */
/* ======================================================================== */

const CHARGE_TIME = 500;
const ART_FORWARD_SPEED = 2;
const ART_REVERSE_SPEED = 0.3;
const EDU_FORWARD_SPEED = 0.3;
const EDU_REVERSE_SPEED = 0.3;
const CONTACTS_FORWARD_SPEED = 0.85;
const CONTACTS_REVERSE_SPEED = 0.3;
const WORK_LOOP_SPEED = 0.2;
const WORK_REVERSE_SPEED = 0.3;

const DESIGN_WIDTH = 1920;
const DESIGN_HEIGHT = 1080;

const iconSettings = {
  "icon-art":      { x: 220,  y: 810, scale: 2.5 },
  "icon-edu":      { x: 230,  y: 225, scale: 2.5 },
  "icon-work":     { x: 1690, y: 235, scale: 2.25 },
  "icon-contacts": { x: 1690, y: 810, scale: 2.35 }
};

function positionIcons() {
  const container = document.getElementById('container');
  const containerWidth = container.offsetWidth;
  const containerHeight = container.offsetHeight;
  
  for (const id in iconSettings) {
    const el = document.getElementById(id);
    const s = iconSettings[id];
    const scaleX = containerWidth / DESIGN_WIDTH;
    const scaleY = containerHeight / DESIGN_HEIGHT;
    const scale = Math.min(scaleX, scaleY);

    el.style.left = (s.x / DESIGN_WIDTH) * 100 + "%";
    el.style.top  = (s.y / DESIGN_HEIGHT) * 100 + "%";
    el.style.transform = `translate(-50%, -50%) scale(${s.scale * scale})`;
  }
}
positionIcons();
window.addEventListener('resize', positionIcons);

class SequenceIcon {
  constructor(element, frameCount, folder, holdFrame = null, speed = 0.04, forwardSpeed = 0.5, reverseSpeed = 0.3, loopSpeed = 0.2) {
    this.element = element;
    this.img = element.querySelector('img');
    this.frameCount = frameCount;
    this.folder = folder;
    this.holdFrame = holdFrame;
    this.speed = speed;
    this.forwardSpeed = forwardSpeed;
    this.reverseSpeed = reverseSpeed;
    this.loopSpeed = loopSpeed;
    this.currentFrame = 0;
    this.targetFrame = 0;
    this.isHovering = false;
    this.isHolding = false;
    this.isCharged = false;
    this.chargeTimer = null;
    this.isClickable = false;
    this.preloadFrames();
    this.setupListeners();
    this.animate();
  }
  
  preloadFrames() {
    this.frames = [];
    for (let i = 0; i < this.frameCount; i++) {
      const img = new Image();
      const frameNum = String(i).padStart(5, '0');
      img.src = `frames/${this.folder}/Frame_${frameNum}.png`;
      this.frames.push(img);
    }
  }
  
  setupListeners() {
    this.element.addEventListener('mouseenter', () => {
      this.isHovering = true;
      this.isCharged = false;
      this.isClickable = true;
      this.element.style.filter =
        "drop-shadow(0 0 10px rgba(0,0,0,1)) drop-shadow(0 0 18px rgba(0,0,0,1)) drop-shadow(0 0 28px rgba(0,0,0,1))";
      this.chargeTimer = setTimeout(() => {
        this.isCharged = true;
        if (this.holdFrame !== null) this.targetFrame = this.holdFrame;
      }, CHARGE_TIME);
    });
    
    this.element.addEventListener('mouseleave', () => {
      this.isHovering = false;
      this.isHolding = false;
      this.isCharged = false;
      this.isClickable = true;
      this.targetFrame = 0;
      this.element.style.filter = "drop-shadow(0 0 0px rgba(0,0,0,0))";
      clearTimeout(this.chargeTimer);
    });
  }
  
  animate() {
    if (this.isCharged) {
      if (this.holdFrame === null) {
        this.currentFrame += this.speed * this.frameCount * this.loopSpeed;
        if (this.currentFrame >= this.frameCount - 1) this.currentFrame = 0;
      } else {
        if (this.isHovering && !this.isHolding && Math.abs(this.currentFrame - this.holdFrame) < 0.5) {
          this.isHolding = true;
          this.isClickable = true;
          this.currentFrame = this.holdFrame;
          this.targetFrame = this.holdFrame;
        }
        if (!this.isHolding) {
          const distance = Math.abs(this.targetFrame - this.currentFrame);
          let easingSpeed = this.speed * this.forwardSpeed;
          if (distance < 2) easingSpeed = 0.5;
          this.currentFrame += (this.targetFrame - this.currentFrame) * easingSpeed;
          if (distance < 0.1) this.currentFrame = this.targetFrame;
        }
      }
    } else {
      if (this.currentFrame > 0) {
        this.currentFrame -= this.speed * this.frameCount * this.reverseSpeed;
        if (this.currentFrame < 0) this.currentFrame = 0;
      }
    }
    
    const frameIndex = Math.round(this.currentFrame);
    if (this.frames[frameIndex] && this.frames[frameIndex].complete) {
      this.img.src = this.frames[frameIndex].src;
    }
    requestAnimationFrame(() => this.animate());
  }
}

const artIcon = new SequenceIcon(document.getElementById('icon-art'),28,'art',20,0.028,ART_FORWARD_SPEED,ART_REVERSE_SPEED);
const eduIcon = new SequenceIcon(document.getElementById('icon-edu'),21,'edu',24,0.025,EDU_FORWARD_SPEED,EDU_REVERSE_SPEED);
const contactsIcon = new SequenceIcon(document.getElementById('icon-contacts'),30,'contacts',12,0.030,CONTACTS_FORWARD_SPEED,CONTACTS_REVERSE_SPEED);
const workIcon = new SequenceIcon(document.getElementById('icon-work'),29,'work',null,0.029,null,WORK_REVERSE_SPEED,WORK_LOOP_SPEED);

/* ======================================================================== */
/* TRANSITION SYSTEM - WITH AGGRESSIVE GIF CACHING */
/* ======================================================================== */

const transitionGif = document.getElementById('transitionGif');
const contactsPage = document.getElementById('contactsPage');
const mainContent = document.getElementById('mainContent');
const backButton = document.getElementById('backButton');
let isTransitioning = false;

const GIF_CONFIG = {
  forward: {
    path: 'transition.gif',
    duration: 2670
  },
  reverse: {
    path: 'reverse.gif',
    duration: 750
  }
};

/* ===== AGGRESSIVE GIF PRELOAD - PREVENTS LAG ON GITHUB PAGES ===== */
const forwardGifPreload = document.createElement('img');
forwardGifPreload.src = GIF_CONFIG.forward.path;
forwardGifPreload.style.display = 'none';
forwardGifPreload.style.position = 'absolute';
forwardGifPreload.style.pointerEvents = 'none';
document.body.appendChild(forwardGifPreload);

const reverseGifPreload = document.createElement('img');
reverseGifPreload.src = GIF_CONFIG.reverse.path;
reverseGifPreload.style.display = 'none';
reverseGifPreload.style.position = 'absolute';
reverseGifPreload.style.pointerEvents = 'none';
document.body.appendChild(reverseGifPreload);

console.log('üåô Luna says: Transition GIFs force-cached in DOM!');
/* ================================================================= */

function resetEyeToCenter() {
  return new Promise((resolve) => {
    const transformAttr = eyeMove.getAttribute('transform') || 'translate(0, 0)';
    const matches = transformAttr.match(/translate\(([-\d.]+),\s*([-\d.]+)\)/);
    
    const startX = matches ? parseFloat(matches[1]) : 0;
    const startY = matches ? parseFloat(matches[2]) : 0;
    
    const duration = 800;
    const startTime = performance.now();
    
    function animate(currentTime) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const eased = 1 - Math.pow(1 - progress, 3);
      
      const currentX = startX * (1 - eased);
      const currentY = startY * (1 - eased);
      
      eyeMove.setAttribute('transform', `translate(${currentX}, ${currentY})`);
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        resolve();
      }
    }
    
    requestAnimationFrame(animate);
  });
}

/* FORWARD TRANSITION: Home ‚Üí Contacts */
document.getElementById('icon-contacts').addEventListener('click', async () => {
  if (isTransitioning || !contactsIcon.isClickable) return;
  
  isTransitioning = true;
  
  try {
    await resetEyeToCenter();
    
    // Use preloaded GIF directly - no cache buster needed!
    transitionGif.src = GIF_CONFIG.forward.path;
    transitionGif.style.display = 'block';
    
    await new Promise(resolve => setTimeout(resolve, GIF_CONFIG.forward.duration));
    
    mainContent.style.display = 'none';
    contactsPage.style.display = 'flex';
    transitionGif.style.display = 'none';
    
  } catch (error) {
    console.error('Forward transition error:', error);
    transitionGif.style.display = 'none';
    mainContent.style.display = 'none';
    contactsPage.style.display = 'flex';
  } finally {
    isTransitioning = false;
  }
});

/* REVERSE TRANSITION: Contacts ‚Üí Home */
backButton.addEventListener('click', async () => {
  if (isTransitioning) return;
  
  isTransitioning = true;
  
  try {
    mainContent.style.display = 'block';
    eyeOffset.style.transition = 'none';
    eyeOffset.style.opacity = '1';
    void eyeOffset.offsetHeight;
    eyeOffset.style.transition = 'opacity 0.8s ease';
    
    // Use preloaded GIF directly - no cache buster needed!
    transitionGif.src = GIF_CONFIG.reverse.path;
    transitionGif.style.display = 'block';
    
    await new Promise(resolve => setTimeout(resolve, 16));
    
    contactsPage.style.display = 'none';
    
    await new Promise(resolve => setTimeout(resolve, GIF_CONFIG.reverse.duration));
    transitionGif.style.display = 'none';
    
  } catch (error) {
    console.error('Reverse transition error:', error);
    transitionGif.style.display = 'none';
    contactsPage.style.display = 'none';
    mainContent.style.display = 'block';
    eyeOffset.style.opacity = '1';
  } finally {
    isTransitioning = false;
  }
});

/* ======================================================================== */
/* EYE SYSTEM WITH GIF FREEZE */
/* ======================================================================== */

const BLINK_SPEED = 240;
const DOUBLE_BLINK_CHANCE = 0.3;
const DOUBLE_BLINK_DELAY = 180;
const BLINK_MIN_DELAY = 2400;
const BLINK_MAX_DELAY = 5000;

const eyeMove   = document.getElementById("eyeMove");
const eyeOffset = document.getElementById("eyeOffset");
const blinkLid  = document.getElementById("blinkLid");

const bgGif = document.getElementById("bgGif");
const bgFreeze = document.getElementById("bgFreeze");
const ctx = bgFreeze.getContext("2d");

let eyeActive = false;

bgGif.addEventListener('load', () => {
  setTimeout(() => {
    if (eyeActive) return;

    if (!bgGif.complete || bgGif.naturalWidth === 0 || bgGif.naturalHeight === 0) {
      setTimeout(() => bgGif.dispatchEvent(new Event('load')), 100);
      return;
    }

    bgFreeze.width = bgGif.naturalWidth;
    bgFreeze.height = bgGif.naturalHeight;
    
    if (bgFreeze.width > 0 && bgFreeze.height > 0) {
      try {
        ctx.drawImage(bgGif, 0, 0, bgFreeze.width, bgFreeze.height);
        
        bgGif.style.display = "none";
        bgFreeze.style.display = "block";

        eyeOffset.style.opacity = "1";
        eyeActive = true;
        startBlinking();
      } catch (error) {
        console.error('Failed to draw GIF to canvas:', error);
      }
    }
  }, 4078);
});

setTimeout(() => {
  if (!eyeActive && bgGif.complete) {
    bgGif.dispatchEvent(new Event('load'));
  }
}, 200);

function moveEye(clientX, clientY) {
  if (!eyeActive) return;
  const x = (clientX / window.innerWidth  - 0.5) * 120;
  const y = (clientY / window.innerHeight - 0.5) * 60;
  eyeMove.setAttribute("transform", `translate(${x}, ${y})`);
}

document.addEventListener("mousemove", (e) => moveEye(e.clientX, e.clientY));

function blinkOnce() {
  blinkLid.style.animation = `blink ${BLINK_SPEED}ms ease-in-out`;
  blinkLid.addEventListener("animationend", () => blinkLid.style.animation = "", { once: true });
}

function blink() {
  blinkOnce();
  if (Math.random() < DOUBLE_BLINK_CHANCE) {
    setTimeout(blinkOnce, DOUBLE_BLINK_DELAY);
  }
}

function startBlinking() {
  (function loop() {
    blink();
    const delay = BLINK_MIN_DELAY + Math.random() * (BLINK_MAX_DELAY - BLINK_MIN_DELAY);
    setTimeout(loop, delay);
  })();
}
</script>

</body>
</html>
