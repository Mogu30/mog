<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>MOG</title>

<!-- GSAP from cdnjs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<style>
/* ========================================================================
   CSS VARIABLES
   ======================================================================== */
:root {
  --z-background: 0;
  --z-content: 1;
  --z-icons: 2;
  --z-transition: 999;
  --z-loading: 9999;

  --color-bg: black;
  --color-text: white;
  --color-accent: #333;

  --transition-fast: 0.1s;
  --transition-normal: 0.3s;

  --space-sm: 1rem;
  --space-md: 2rem;
  --space-lg: 3rem;
}

/* ========================================================================
   BASE
   ======================================================================== */
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: var(--color-bg);
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  overscroll-behavior: none;
  -webkit-overflow-scrolling: touch;
}

/* ========================================================================
   LOADING SCREEN
   ======================================================================== */
#loadingScreen {
  position: fixed;
  inset: 0;
  background: transparent;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: var(--z-loading);
  color: var(--color-text);
  font-family: Arial, sans-serif;
  pointer-events: none;
}
#loadingScreen h2 {
  font-size: 2rem;
  margin-bottom: var(--space-sm);
  pointer-events: auto;
  font-family: 'Arial Black', 'Helvetica Neue', sans-serif;
  font-weight: 900;
  letter-spacing: -1px;
  color: black;
  text-shadow: -1px -1px 0 #ff0000, 1px -1px 0 #ff0000, -1px 1px 0 #ff0000, 1px 1px 0 #ff0000;
  animation: smokeOut 1s ease-in-out infinite alternate;
}
@keyframes smokeOut {
  100% { opacity: 0.08; filter: blur(3px); letter-spacing: 1px; }
}

/* Comet animation SVG */
#loadingSvg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  pointer-events: none;
}
#loadingScreen h2 {
  position: relative;
  z-index: 1;
}
#loadingSvg path,
#loadingSvg line,
#loadingSvg polyline,
#loadingSvg polygon {
  fill: none;
  stroke-linecap: round;
  stroke-linejoin: round;
}

/* ========================================================================
   CONTAINER  ‚Äî starts invisible, fades in after loading
   ======================================================================== */
#container {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 1920px;
  height: 1080px;
  transform: translate(-50%, -50%);
  background: var(--color-bg);
  opacity: 0;
  -webkit-tap-highlight-color: transparent;
  touch-action: none;
}

/* ========================================================================
   BACKGROUND VIDEO & FREEZE
   ======================================================================== */
#bgVideo, #bgFreeze {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  z-index: var(--z-background);
}
#bgFreeze { display: none; }

/* ========================================================================
   FULLSCREEN WALL (independent layer, not in container)
   ======================================================================== */
#wall-fullscreen {
  position: fixed;
  inset: 0;
  z-index: 500;
  opacity: 0;
  pointer-events: none;
  background: black;
  display: flex;
  align-items: center;
  justify-content: center;
}
#wall-fullscreen .wallContainer {
  aspect-ratio: 16/9;
  width: 100vw;
  max-width: 100vw;
  max-height: 100vh;
  height: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}
#wall-fullscreen canvas {
  display: block;
  width: 100%;
  height: 100%;
  position: absolute;
  inset: 0;
  z-index: 1;
}
@media (min-aspect-ratio: 16/9) {
  #wall-fullscreen .wallContainer {
    width: auto;
    height: 100vh;
  }
}
@media (max-aspect-ratio: 16/9) {
  #wall-fullscreen .wallContainer {
    width: 100vw;
    height: auto;
  }
}
#wall-click-text {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 2.2rem;
  color: rgba(255,255,255,0.7);
  font-family: 'Inter', 'Segoe UI', 'Arial', sans-serif;
  font-weight: 300;
  letter-spacing: -0.04em;
  animation: fadeInOut 2s infinite;
  pointer-events: none;
  z-index: 9999 !important; /* High z-index to be above WebGL canvas */
  visibility: hidden;
  isolation: isolate;
  text-shadow: 0 1px 4px rgba(0,0,0,0.12);
}
@keyframes fadeInOut {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 1; }
}
#backButtonWall {
  position: fixed;
  top: 2rem;
  right: 2rem;
  padding: 0.8rem 1.5rem;
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: 2px solid white;
  border-radius: 0.5rem;
  font-size: 1rem;
  font-family: Arial, sans-serif;
  cursor: pointer;
  z-index: 10000 !important; /* Very high to ensure on top of WebGL canvas */
  visibility: hidden;
  pointer-events: none;
  opacity: 0;
  /* Prevent any transform/filter that could affect stacking */
  isolation: isolate;
}
#backButtonWall:hover {
  background: rgba(255, 255, 255, 0.4);
  transform: scale(1.05);
}
#wall-content {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
  background: black;
  color: white;
  z-index: 499;
  opacity: 0;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 2rem;
  overflow-y: auto;
}
#wall-content.visible {
  opacity: 1;
  pointer-events: auto;
}
#wall-content-text {
  max-width: 800px;
  font-size: 1.2rem;
  line-height: 1.6;
  font-family: Arial, sans-serif;
  margin-bottom: 2rem;
}
#backButtonContent {
  padding: 0.8rem 1.5rem;
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: 2px solid white;
  border-radius: 0.5rem;
  font-size: 1rem;
  font-family: Arial, sans-serif;
  cursor: pointer;
  transition: all 0.3s ease;
}
#backButtonContent:hover {
  background: rgba(255, 255, 255, 0.4);
  transform: scale(1.05);
}

/* ========================================================================
   CONTENT LAYERS
   ======================================================================== */
#mainContent {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-content);
}

/* Pages ‚Äî opacity / children animated entirely by GSAP */
#contactsPage, #eduPage {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  background: var(--color-bg);
  color: var(--color-text);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: var(--z-content);
  font-family: Arial, sans-serif;
}

/* ========================================================================
   TRANSITION VIDEO
   ======================================================================== */
#transitionVideo {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  z-index: var(--z-transition);
  display: none;
  pointer-events: none;
}
/* Edu: video behind icons so their fade is visible */
#transitionVideo.under-icons { z-index: 0; }

/* ========================================================================
   SVG / EYE  ‚Äî opacity managed by GSAP
   ======================================================================== */
svg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-content);
  will-change: transform;
  transform: translateZ(0);
}
#eyeOffset { opacity: 0; }   /* GSAP sets this */

#blinkLid {
  transform-origin: 50% 50%;
  transform: scaleY(0);
  pointer-events: none;
}
#reflections { mix-blend-mode: screen; }

@keyframes blink {
  0%   { transform: scaleY(0) translateY(-50%); }
  45%  { transform: scaleY(1) translateY(0%); }
  55%  { transform: scaleY(1) translateY(0%); }
  100% { transform: scaleY(0) translateY(-50%); }
}

/* ========================================================================
   SPRITE SHEET ICONS
   ======================================================================== */
.icon {
  position: absolute;
  transform-origin: center center;
  z-index: var(--z-icons);
  pointer-events: auto;
  cursor: pointer;
  filter: drop-shadow(0 0 0px rgba(0,0,0,0));
  opacity: 1;
  transition: filter var(--transition-fast) ease;
  will-change: background-position, transform;
  transform: translateZ(0);
  backface-visibility: hidden;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
  -webkit-user-select: none;
  background-repeat: no-repeat;
  image-rendering: -webkit-optimize-contrast;
  image-rendering: crisp-edges;
}

/* Flag class ‚Äî pointer-events only; GSAP handles the opacity */
.icon.icon-hidden { pointer-events: none; }
.icon.touching { filter: drop-shadow(0 0 10px rgba(255,255,255,0.5)); }

/* Individual icon sprite settings - base size 180px like original */
#icon-art {
  width: 180px;
  height: 169px; /* maintain aspect ratio: 180 * (425/453) */
  background-image: url('assets/sprites/icon-art.png');
  background-size: 8640px 169px; /* scale proportionally: 21744 * (180/453) */
  background-position: 0 0;
}

#icon-contacts {
  width: 180px;
  height: 203px; /* maintain aspect ratio: 180 * (436/386) */
  background-image: url('assets/sprites/icon-contacts.png');
  background-size: 5400px 203px; /* scale proportionally: 11580 * (180/386) */
  background-position: 0 0;
}

#icon-edu {
  width: 180px;
  height: 105px; /* maintain aspect ratio: 180 * (320/456) */
  background-image: url('assets/sprites/icon-edu.png');
  background-size: 13136px 105px; /* scale proportionally: 40150 * (180/456) */
  background-position: 0 0;
}

#icon-work {
  width: 180px;
  height: 226px; /* maintain aspect ratio: 180 * (397/316) */
  background-image: url('assets/sprites/icon-work.png');
  background-size: 5220px 226px; /* scale proportionally: 9164 * (180/316) */
  background-position: 0 0;
}

/* ========================================================================
   PAGE CONTENT STYLES
   ======================================================================== */
#contactsPage h1, #eduPage h1 {
  font-size: 4rem;
  margin-bottom: var(--space-md);
  text-transform: uppercase;
  letter-spacing: 0.5rem;
}
#contactsPage p, #eduPage p {
  font-size: 1.5rem;
  margin-bottom: var(--space-lg);
  opacity: 0.7;
}
.backButton {
  padding: var(--space-sm) var(--space-lg);
  font-size: 1.2rem;
  background: var(--color-text);
  color: var(--color-bg);
  border: none;
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 0.2rem;
  transition: all var(--transition-normal) ease;
  -webkit-tap-highlight-color: transparent;
}
.backButton:hover { background: var(--color-accent); color: var(--color-text); transform: scale(1.05); }
.backButton:active { transform: scale(0.95); }

/* ========================================================================
   RESPONSIVE
   ======================================================================== */
@media (max-width: 768px) {
  #contactsPage h1, #eduPage h1 { font-size: 2.5rem; letter-spacing: 0.3rem; }
  #contactsPage p, #eduPage p   { font-size: 1.2rem; }
  .backButton { font-size: 1rem; padding: 0.8rem 2rem; }
}

/* ========================================================================
   CONTACTS PAGE - Animated Eye Background
   ======================================================================== */

/* üéõÔ∏è SIZE CONTROL PANEL - Change values here to adjust sizes */
#contactsPage {
  /* --- TITLE BOX --- */
  --title-text-size: 2.5rem;       /* Size of "CONTACT" text */
  --title-letter-spacing: 0.8rem;  /* Space between letters */
  --title-box-padding-v: 1.2rem;   /* Top/Bottom padding of title box */
  --title-box-padding-h: 2.5rem;   /* Left/Right padding of title box */
  --title-box-radius: 16px;        /* Rounded corners of title box */

  /* --- BODY BOX (Email/Phone/Socials) --- */
  --body-box-width: 500px;         /* Max width of the content boxes */
  --body-box-padding: 2rem 2.5rem; /* Padding inside the body box */
  --body-box-radius: 13px;         /* Rounded corners of body box */
  --body-box-gap: 21px;            /* Space between items */

  /* --- BODY TEXT --- */
  --body-text-size: 2rem;          /* Size of the contact info text */
  --body-label-size: 1rem;      /* Size of labels (Email:, Phone:) */
  --body-line-padding: 0.4rem 0.6rem; /* Padding around each line */

  /* --- BUTTON --- */
  --button-padding: 1.2rem 2rem;   /* Padding (Size) of the button */
  --button-text-size: 0.85rem;     /* Size of button text */
  --button-radius: 8px;            /* Rounded corners of button */
  --button-margin-top: 150px;      /* Space above the button */
}

/* Canvas for contacts eyes */
#contactsPage .contacts-canvas {
  position: fixed;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

/* Contacts content - Golden ratio layout */
#contactsPage .contacts-content {
  position: relative;
  position: absolute;
  top: var(--pos-y, 50%);
  left: var(--pos-x, 50%);
  z-index: 2;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: center;
  width: auto;
  height: auto;
  padding: 0;
  gap: 34px;
}

/* Title - Elegant thin typography */
#contactsPage .contacts-title {
  font-size: var(--title-text-size);
  font-weight: 200;
  letter-spacing: var(--title-letter-spacing);
  text-transform: uppercase , bold;
  color: #fff;
  position: relative;
  display: inline-block;
  line-height: 1.2em;
  margin: 0;
  padding: 0;
  font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
}

/* Split effect container with box */
#contactsPage .title-split {
  position: relative;
  display: inline-block;
  cursor: pointer;
  background: rgba(255, 255, 255, 0.05);
  border: 5px solid rgba(255, 0, 0, 0.1);
  border-radius: var(--title-box-radius);
  padding: var(--title-box-padding-v) var(--title-box-padding-h);
  backdrop-filter: blur(12px);
  transition: all 0.3s ease;
}

#contactsPage .title-split:hover {
  background: linear-gradient(135deg, rgba(139, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0.3) 70%);
  border-color: rgba(255, 0, 0, 0.6);
  box-shadow: 0 0 20px rgba(139, 0, 0, 0.3);
}

#contactsPage .title-top {
  position: absolute;
  color: #fff;
  top: var(--title-box-padding-v);
  left: var(--title-box-padding-h);
  display: inline-block;
  clip-path: polygon(0% 66%, 0% 0%, 100% 0%, 100% 40%);
  transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1) 0.25s;
}

#contactsPage .title-bottom {
  display: inline-block;
  clip-path: polygon(0% 65%, 100% 40%, 100% 110%, 0% 110%);
  color: #fff;
  transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1) 0.25s;
}

#contactsPage .title-split:hover .title-top {
  transform: translateY(-0.4em);
  transition: transform 0.5s cubic-bezier(.12,.8,.57,1.00) 0.42s;
}

#contactsPage .title-split:hover .title-bottom {
  transform: translateY(0.4em);
  transition: transform 0.5s cubic-bezier(.12,.8,.57,1.00) 0.42s;
}

/* Contacts cards container */
#contactsPage .cards-container {
  display: flex;
  flex-direction: column;
  gap: var(--body-box-gap);
  align-items: flex-start;
  max-width: var(--body-box-width);
  width: 100%;
}

/* Body box */
#contactsPage .body-box {
  width: 100%;
  max-width: var(--body-box-width);
  background: rgba(255, 255, 255, 0.05);
  border: 5px solid rgba(255, 255, 255, 0.1);
  border-radius: var(--body-box-radius);
  padding: var(--body-box-padding);
  backdrop-filter: blur(12px);
  transition: all 0.3s ease;
  display: flex;
  flex-direction: column;
  gap: var(--body-box-gap);
  position: relative;
  overflow: hidden;
}

#contactsPage .body-box::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(45deg, transparent, rgba(139, 0, 0, 0.4), transparent);
  transform: translateX(-100%);
  transition: transform 0.6s ease;
}

#contactsPage .body-box:hover::before {
  transform: translateX(100%);
}

#contactsPage .body-box:hover {
  background: linear-gradient(135deg, rgba(139, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0.3) 70%);
  border-color: rgba(255, 0, 0, 0.6);
  box-shadow: 0 0 20px rgba(139, 0, 0, 0.3);
}

/* Body text lines */
#contactsPage .body-line {
  display: flex;
  gap: 13px;
  align-items: baseline;
  font-size: var(--body-text-size);
  font-weight: 300;
  font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
  color: #fff;
  cursor: pointer;
  transition: all 0.3s ease;
  padding: var(--body-line-padding);
  border-radius: 8px;
  letter-spacing: 0.05rem;
}

#contactsPage .body-line:hover {
  background: rgba(139, 0, 0, 0.15);
}

#contactsPage .body-line .label {
  min-width: 80px;
  color: rgba(255, 255, 255, 0.5);
  text-transform: uppercase;
  letter-spacing: 0.15rem;
  font-weight: 400;
  font-size: var(--body-label-size);
}

#contactsPage .body-line .value {
  overflow: hidden;
  height: 1.5em;
  position: relative;
  font-weight: 300;
}

/* Character animation for carousel effect */
#contactsPage .body-line .value .char {
  display: inline-block;
  position: relative;
  overflow: hidden;
  height: 1.5em;
  vertical-align: top;
}

#contactsPage .body-line .value .char .char-inner {
  display: block;
  transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
  position: relative;
}

#contactsPage .body-line.animating .value .char .char-inner {
  transform: translateY(-1.5em);
}

#contactsPage .body-line .value .char .char-inner::before {
  content: attr(data-char);
  position: absolute;
  top: -1.5em;
  left: 0;
}

#contactsPage .body-line .value .char .char-inner::after {
  content: attr(data-char);
  position: absolute;
  top: 1.5em;
  left: 0;
}

/* Stagger animation delays */
#contactsPage .body-line.animating .value .char:nth-child(1) .char-inner { transition-delay: 0s; }
#contactsPage .body-line.animating .value .char:nth-child(2) .char-inner { transition-delay: 0.05s; }
#contactsPage .body-line.animating .value .char:nth-child(3) .char-inner { transition-delay: 0.1s; }
#contactsPage .body-line.animating .value .char:nth-child(4) .char-inner { transition-delay: 0.15s; }
#contactsPage .body-line.animating .value .char:nth-child(5) .char-inner { transition-delay: 0.2s; }
#contactsPage .body-line.animating .value .char:nth-child(6) .char-inner { transition-delay: 0.25s; }
#contactsPage .body-line.animating .value .char:nth-child(7) .char-inner { transition-delay: 0.3s; }
#contactsPage .body-line.animating .value .char:nth-child(8) .char-inner { transition-delay: 0.35s; }
#contactsPage .body-line.animating .value .char:nth-child(9) .char-inner { transition-delay: 0.4s; }
#contactsPage .body-line.animating .value .char:nth-child(10) .char-inner { transition-delay: 0.45s; }
#contactsPage .body-line.animating .value .char:nth-child(11) .char-inner { transition-delay: 0.5s; }
#contactsPage .body-line.animating .value .char:nth-child(12) .char-inner { transition-delay: 0.55s; }
#contactsPage .body-line.animating .value .char:nth-child(13) .char-inner { transition-delay: 0.6s; }
#contactsPage .body-line.animating .value .char:nth-child(14) .char-inner { transition-delay: 0.65s; }
#contactsPage .body-line.animating .value .char:nth-child(15) .char-inner { transition-delay: 0.7s; }
#contactsPage .body-line.animating .value .char:nth-child(16) .char-inner { transition-delay: 0.75s; }
#contactsPage .body-line.animating .value .char:nth-child(17) .char-inner { transition-delay: 0.8s; }
#contactsPage .body-line.animating .value .char:nth-child(18) .char-inner { transition-delay: 0.85s; }
#contactsPage .body-line.animating .value .char:nth-child(19) .char-inner { transition-delay: 0.9s; }
#contactsPage .body-line.animating .value .char:nth-child(20) .char-inner { transition-delay: 0.95s; }
#contactsPage .body-line.animating .value .char:nth-child(21) .char-inner { transition-delay: 1s; }
#contactsPage .body-line.animating .value .char:nth-child(22) .char-inner { transition-delay: 1.05s; }
#contactsPage .body-line.animating .value .char:nth-child(23) .char-inner { transition-delay: 1.1s; }
#contactsPage .body-line.animating .value .char:nth-child(24) .char-inner { transition-delay: 1.15s; }
#contactsPage .body-line.animating .value .char:nth-child(25) .char-inner { transition-delay: 1.2s; }

/* Veins overlay effect */
#contactsPage .veins-overlay {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 10;
  opacity: 0.15;
  background-image: 
    radial-gradient(ellipse at 20% 30%, transparent 0%, transparent 40%, rgba(139, 0, 0, 0.1) 40%, transparent 41%),
    radial-gradient(ellipse at 80% 70%, transparent 0%, transparent 40%, rgba(139, 0, 0, 0.1) 40%, transparent 41%),
    radial-gradient(ellipse at 50% 50%, transparent 0%, transparent 50%, rgba(139, 0, 0, 0.05) 50%, transparent 51%);
  animation: contactsVeinsPulse 4s ease-in-out infinite;
}

@keyframes contactsVeinsPulse {
  0%, 100% { opacity: 0.1; }
  50% { opacity: 0.2; }
}

/* Contacts back button - Elegant thin style */
#contactsPage .contacts-back-btn {
  padding: var(--button-padding);
  font-size: var(--button-text-size);
  background: rgba(255, 255, 255, 0.05);
  color: rgba(255, 255, 255, 0.7);
  border: 2.5px solid rgba(139, 0, 0, 0.4);
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 0.2rem;
  font-weight: 300;
  font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
  border-radius: var(--button-radius);
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  backdrop-filter: blur(12px);
  margin-top: var(--button-margin-top);
}

#contactsPage .contacts-back-btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(45deg, transparent, rgba(139, 0, 0, 0.4), transparent);
  transform: translateX(-100%);
  transition: transform 0.6s ease;
}

#contactsPage .contacts-back-btn:hover::before {
  transform: translateX(100%);
}

#contactsPage .contacts-back-btn:hover {
  color: #fff;
  border-color: rgba(139, 0, 0, 0.7);
  background: linear-gradient(135deg, rgba(139, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.3) 70%);
}

#contactsPage .contacts-back-btn:active {
  transform: scale(0.98);
}

/* White shine loop animation */
@keyframes whiteShineLoop {
  0% { transform: translateX(-150%) skewX(-25deg); }
  100% { transform: translateX(150%) skewX(-25deg); }
}

#contactsPage .body-box::after,
#contactsPage .contacts-back-btn::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(120deg, transparent 30%, rgba(255, 255, 255, 0.08) 50%, transparent 70%);
  pointer-events: none;
  z-index: 1;
  animation: whiteShineLoop 6s ease-in-out infinite alternate;
}

#contactsPage .contacts-back-btn::after {
  animation-delay: 2s; /* Offset the button animation */
}

/* Breathing animation for contacts content */
@keyframes contactsBreathe {
  0%, 100% { transform: scale(var(--base-scale, 1)); }
  50% { transform: scale(calc(var(--base-scale, 1) * 1.02)); }
  0%, 100% { transform: translateY(-50%) scale(var(--base-scale, 1)); }
  50% { transform: translateY(-50%) scale(calc(var(--base-scale, 1) * 1.02)); }
}

#contactsPage .contacts-content {
  --base-scale: 1.2; /* ‚¨ÖÔ∏è CHANGE THIS NUMBER to resize everything (e.g. 0.8 or 1.2) */
  --base-scale: 1.2;  /* üìè SIZE: 1 = normal, 1.2 = 20% bigger */
  --pos-x: 200px;    /* ‚ÜîÔ∏è MOVE LEFT/RIGHT: 0px is left edge, 1920px is right edge */
  --pos-y: 55%;       /* ‚ÜïÔ∏è MOVE UP/DOWN: 50% is dead center */
  animation: contactsBreathe 8s ease-in-out infinite;
}
</style>
</head>
<body>

<!-- Loading Screen -->
<div id="loadingScreen">
  <!-- üåü COMET ANIMATION SVG üåü -->
  <svg id="loadingSvg" viewBox="0 0 1920 1080" xmlns="http://www.w3.org/2000/svg">
    <defs id="loading-gradient-defs"></defs>
    
    <g id="loading-original-paths">
      <!-- üîΩüîΩüîΩ PASTE YOUR SVG PATHS HERE üîΩüîΩüîΩ -->

      <!-- üîºüîºüîº PASTE YOUR SVG PATHS HERE üîºüîºüîº -->
    </g>
  </svg>
  
  <h2>LOADING...</h2>
</div>

<!-- Fullscreen Wall Container (independent of main container) -->
<div id="wall-fullscreen"></div>
<div id="wall-click-text">click + drag</div>
<button id="backButtonWall">‚Üê Back</button>

<!-- Wall Content Area (revealed after knockdown) -->
<div id="wall-content">
  <div id="wall-content-text">work exp goes here</div>
  <button id="backButtonContent" class="backBtn">‚Üê Back to Home</button>
</div>

<div id="container">
  <video id="bgVideo" muted playsinline webkit-playsinline>
    <source src="assets/background/mog.webm" type="video/webm">
  </video>
  <canvas id="bgFreeze"></canvas>

  <!-- Home -->
  <div id="mainContent">
    <div class="icon" id="icon-art"      role="button" aria-label="Art Portfolio" tabindex="0"></div>
    <div class="icon" id="icon-edu"      role="button" aria-label="Education"     tabindex="0"></div>
    <div class="icon" id="icon-contacts" role="button" aria-label="Contacts"      tabindex="0"></div>
    <div class="icon" id="icon-work"     role="button" aria-label="Work"          tabindex="0"></div>

    <svg viewBox="0 0 1920 1080" aria-hidden="true">
      <defs>
        <mask id="eyeMask" maskUnits="userSpaceOnUse">
          <image href="assets/sprites/mask.png" x="0" y="0" width="1920" height="1080" preserveAspectRatio="none"/>
        </mask>
      </defs>
      <g id="eyeContainer" transform="translate(960,535) scale(1) translate(-960,-540)">
        <g id="eyeOffset">
          <image href="assets/sprites/White.png" x="0" y="0" width="1920" height="1080"/>
          <g mask="url(#eyeMask)">
            <g id="eyeMove">
              <image href="assets/sprites/Iris.png" x="0" y="0" width="1920" height="1080"/>
            </g>
            <g id="reflectionsMove">
              <image id="reflections" href="assets/sprites/reflections.png" x="-690" y="-487" width="3090" height="2390"/>
            </g>
            <rect id="blinkLid" x="0" y="0" width="1920" height="1080" fill="black"/>
          </g>
        </g>
      </g>
    </svg>
  </div>

  <!-- Contacts Page -->
  <div id="contactsPage">
    <!-- Canvas for eye animation -->
    <canvas class="contacts-canvas" id="contactsCanvas"></canvas>
    
    <!-- Veins overlay -->
    <div class="veins-overlay"></div>
    
    <!-- Content -->
    <div class="contacts-content">
      <div class="cards-container">
        <!-- Title Box -->
        <h1 class="contacts-title">
          <span class="title-split">
            <span class="title-top">CONTACT</span>
            <span class="title-bottom">CONTACT</span>
          </span>
        </h1>
        
        <!-- Body Box -->
        <div class="body-box">
          <div class="body-line" data-hover-pattern="email">
            <span class="label">Email:</span>
            <span class="value">mozharalfares@gmail.com</span>
          </div>
          <div class="body-line" data-hover-pattern="phone">
            <span class="label">Phone:</span>
            <span class="value">+09 542 448 4629</span>
          </div>
          <div class="body-line" data-hover-pattern="social">
            <span class="label">Socials:</span>
            <span class="value">ig @mogart6</span>
          </div>
        </div>
      </div>
      
      <button class="contacts-back-btn" id="backButtonContacts">‚Üê BACK TO HOME</button>
    </div>
  </div>

  <!-- Education Page -->
  <div id="eduPage">
    <h1>Education</h1>
    <p>This is the education page content.</p>
    <p>Coming soon!</p>
    <button class="backButton" id="backButtonEdu">‚Üê Back to Home</button>
  </div>

  <!-- Work Page moved to #wall-fullscreen (independent of container) -->

  <!-- Transition Video -->
  <video id="transitionVideo" muted playsinline webkit-playsinline>
    <source src="" type="video/webm">
  </video>
</div>

<script>
'use strict';

/* ========================================================================
   DEVICE DETECTION
   ======================================================================== */
const DeviceDetector = {
  isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
  isTouchDevice: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
  init() {
    console.log('üì± Device type:', this.isMobile ? 'Mobile' : 'Desktop');
    console.log('üëÜ Touch support:', this.isTouchDevice ? 'Yes' : 'No');
  }
};

/* ========================================================================
   CONFIG
   ======================================================================== */
const CONFIG = {
  ASSETS: {
    CRITICAL: [
      'assets/sprites/White.png','assets/sprites/Iris.png','assets/sprites/mask.png','assets/sprites/reflections.png',
      'assets/sprites/icon-art.png','assets/sprites/icon-contacts.png',
      'assets/sprites/icon-edu.png','assets/sprites/icon-work.png',
      'assets/transitions/contacts/transition.webm',
      'assets/transitions/contacts/reverse.webm',
      'assets/transitions/edu/edu_transition.webm',
      'assets/transitions/edu/edu_reverse.webm',
      'mog.png'
    ]
  },

  TIMING: {
    CONTACTS_ICON_FADE:     2168,   // ms into contacts forward video ‚Üí icons start fading
    EDU_ICON_FADE:          1006,   // ms into edu forward video ‚Üí icons start fading
    EDU_REVERSE_ICON_FADE:  725,    // ms into edu reverse video ‚Üí icons fade back in
    BLINK_AFTER_TRANSITION: 150,
    EYE_ACTIVATE_TIME:      4.037,  // seconds into bgVideo
    LOADING_DELAY:          500,
    LOADING_TIMEOUT:        5000,   // Force load after 5 seconds
    BLINK_SPEED:            150,
    DOUBLE_BLINK_DELAY:     180,
    BLINK_MIN_DELAY:        2400,
    BLINK_MAX_DELAY:        5000,
    EYE_FALLBACK_TIMEOUT:   8000
  },

  LAYOUT: { DESIGN_WIDTH: 1920, DESIGN_HEIGHT: 1080 },

  ICON_SETTINGS: {
    "icon-art":      { x: 220,  y: 810, scale: 2.5  },
    "icon-edu":      { x: 225,  y: 225, scale: 3  },
    "icon-work":     { x: 1690, y: 235, scale: 1.77 },
    "icon-contacts": { x: 1685, y: 810, scale: 2.2 }
  },

  TRANSITION: {
    OFFSET: 1,
    CONTACTS_FORWARD: 'assets/transitions/contacts/transition.webm',
    CONTACTS_REVERSE: 'assets/transitions/contacts/reverse.webm',
    EDU_FORWARD:      'assets/transitions/edu/edu_transition.webm',
    EDU_REVERSE:      'assets/transitions/edu/edu_reverse.webm'
  },

  EYE: { DOUBLE_BLINK_CHANCE: 0.3, REFLECTION_MOVEMENT: 0.1 },

  // All GSAP durations live here (in seconds)
  GSAP: {
    CONTAINER_FADE:          1.5,    // Duration for container fade-in after loading
    ICON_FADE:               0.6,
    EYE_FADE_FAST:           0.15,   // eye ‚Üî transition video hand-off
    EYE_FADE_ACTIVATE:       0.3,    // very first eye appearance
    EYE_RESET_DURATION:      0.8,    // eye gliding back to center
    PAGE_CONTENT_DURATION:   0.4,    // each child fade
    PAGE_CONTENT_STAGGER:    0.13,   // delay between children
    PAGE_CONTENT_DELAY:      0.15    // initial delay before first child
  },

  DEBUG: false
};

/* ========================================================================
   UTILS
   ======================================================================== */
const Utils = {
  log: (...args) => { if (CONFIG.DEBUG) console.log(...args); },
  wait: (ms) => new Promise(r => setTimeout(r, ms)),
  getElement: (id) => {
    const el = document.getElementById(id);
    if (!el) console.error(`Element not found: ${id}`);
    return el;
  }
};

/* ========================================================================
   APP SCALER
   ======================================================================== */
const AppScaler = {
  init() {
    this.updateScale();
    window.addEventListener('resize', () => this.updateScale());
  },
  updateScale() {
    const container = Utils.getElement('container');
    const winW = window.innerWidth;
    const winH = window.innerHeight;
    const designW = CONFIG.LAYOUT.DESIGN_WIDTH;
    const designH = CONFIG.LAYOUT.DESIGN_HEIGHT;
    const scale = Math.min(winW / designW, winH / designH);
    container.style.transform = `translate(-50%, -50%) scale(${scale})`;
  }
};

/* ========================================================================
   PRELOADER - FIXED VERSION
   ======================================================================== */
const Preloader = {
  loadedCount: 0,
  totalAssets: CONFIG.ASSETS.CRITICAL.length,
  forceLoadTriggered: false,
  loadingComplete: false,

  init() {
    const loadingScreen = Utils.getElement('loadingScreen');
    const container = Utils.getElement('container');

    // Preload images and videos
    CONFIG.ASSETS.CRITICAL.forEach(src => {
      if (src.endsWith('.webm') || src.endsWith('.mp4')) {
        this.preloadVideo(src);
      } else {
        this.preloadImage(src);
      }
    });

    this.updateProgress = () => {
      this.loadedCount++;
      const pct = Math.round((this.loadedCount / this.totalAssets) * 100);
      console.log(`Loading assets... ${pct}%`);

      if (this.loadedCount === this.totalAssets && !this.forceLoadTriggered) {
        this.forceLoadTriggered = true; // Prevent double-call race condition
        this.completeLoading(loadingScreen, container);
      }
    };

    // Force load after timeout
    setTimeout(() => {
      if (!this.forceLoadTriggered) {
        console.warn('‚ö†Ô∏è Loading timeout - forcing page load');
        this.forceLoadTriggered = true;
        this.completeLoading(loadingScreen, container);
      }
    }, CONFIG.TIMING.LOADING_TIMEOUT);
  },

  async completeLoading(loadingScreen, container) {
    // Initialize wall FIRST (during loading) so it's ready when needed
    console.log('üéÆ [PRELOAD] Starting wall initialization...');
    await TransitionManager.initializeWall();
    console.log('‚úÖ [PRELOAD] Wall ready!');

    // Fade out loading text first
    gsap.to(loadingScreen.querySelector('h2'), {
      opacity: 0,
      duration: 0.2,
      ease: 'power2.inOut'
    });
    
    // Fade out comets
    gsap.to('#loadingSvg', { 
      opacity: 0, 
      duration: 0.3, 
      ease: 'power2.inOut'
    });
    
    // Then fade in the container after text is gone
    gsap.to(container, {
      opacity: 1,
      duration: CONFIG.GSAP.CONTAINER_FADE,
      delay: 0.25,
      ease: 'power2.inOut',
      onComplete: () => {
        LoadingCometAnimation.stop();
        loadingScreen.style.display = 'none';
        // Start the background video once loading is done
        Utils.getElement('bgVideo').play();
        // Mark loading as complete so eye can activate
        Preloader.loadingComplete = true;
      }
    });
  },

  preloadImage(src) {
    const i = new Image();
    i.onload = () => this.updateProgress();
    i.onerror = () => {
      console.warn(`Failed to load: ${src}`);
      this.updateProgress(); // Still count it to avoid infinite loading
    };
    i.src = src;
  },

  preloadVideo(src) {
    const v = document.createElement('video');
    v.preload = 'auto';
    v.onloadeddata = () => {
      console.log(`‚úÖ Video loaded: ${src}`);
      this.updateProgress();
    };
    v.onerror = () => {
      console.warn(`Failed to load video: ${src}`);
      this.updateProgress(); // Still count it to avoid infinite loading
    };
    v.src = src;
    v.load();
  }
};

/* ========================================================================
   ICON POSITIONING
   ======================================================================== */
const IconPositioner = {
  positionIcons() {
    const container = Utils.getElement('container');
    const cw = container.offsetWidth, ch = container.offsetHeight;
    for (const id in CONFIG.ICON_SETTINGS) {
      const el = Utils.getElement(id);
      if (!el) continue;
      const s = CONFIG.ICON_SETTINGS[id];
      const scale = Math.min(cw / CONFIG.LAYOUT.DESIGN_WIDTH, ch / CONFIG.LAYOUT.DESIGN_HEIGHT);
      el.style.left = (s.x / CONFIG.LAYOUT.DESIGN_WIDTH) * 100 + '%';
      el.style.top  = (s.y / CONFIG.LAYOUT.DESIGN_HEIGHT) * 100 + '%';
      el.style.transform = `translate(-50%, -50%) scale(${s.scale * scale})`;
    }
  },
  init() {
    this.positionIcons();
    window.addEventListener('resize', () => this.positionIcons());
  }
};

/* ========================================================================
   SPRITE SHEET ICON - SIMPLIFIED VERSION
   ======================================================================== */
class SpriteSheetIcon {
  constructor(element, frameCount, frameWidth, frameHeight, spriteWidth, holdFrame = null, speeds = {}) {
    this.element = element;
    this.frameCount = frameCount;
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
    this.spriteWidth = spriteWidth;
    this.holdFrame = holdFrame;
    
    // Animation state
    this.currentFrame = 0;
    this.targetFrame = 0;
    this.isHovering = false;
    this.isHolding = false;
    this.isTouching = false;
    
    // SIMPLIFIED SPEEDS - just forward, reverse, loop
    this.forwardSpeed = speeds.forwardSpeed || 0.5;
    this.reverseSpeed = speeds.reverseSpeed || 0.3;
    this.loopSpeed = speeds.loopSpeed || 0.2;
    
    this.animationFrame = null;
    
    this.setupListeners();
    this.animate();
  }

  setupListeners() {
    this.element.addEventListener('mouseenter', () => {
      if (DeviceDetector.isTouchDevice) return;
      this.isHovering = true;
      this.element.style.filter = 'drop-shadow(0 0 10px rgba(0,0,0,1)) drop-shadow(0 0 18px rgba(0,0,0,1)) drop-shadow(0 0 28px rgba(0,0,0,1))';
      if (this.holdFrame !== null) {
        this.targetFrame = this.holdFrame;
      }
    });

    this.element.addEventListener('mouseleave', () => {
      if (DeviceDetector.isTouchDevice) return;
      this.isHovering = false;
      this.isHolding = false;
      this.targetFrame = 0;
      this.element.style.filter = 'drop-shadow(0 0 0px rgba(0,0,0,0))';
    });

    this.element.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.isTouching = this.isHovering = true;
      this.element.classList.add('touching');
      this.element.style.filter = 'drop-shadow(0 0 10px rgba(0,0,0,1)) drop-shadow(0 0 18px rgba(0,0,0,1)) drop-shadow(0 0 28px rgba(0,0,0,1))';
      if (this.holdFrame !== null) {
        this.targetFrame = this.holdFrame;
      }
    }, { passive: false });

    this.element.addEventListener('touchend', (e) => {
      e.preventDefault();
      this.element.click();
      this.isHovering = this.isHolding = this.isTouching = false;
      this.targetFrame = 0;
      this.element.style.filter = 'drop-shadow(0 0 0px rgba(0,0,0,0))';
      this.element.classList.remove('touching');
    }, { passive: false });

    this.element.addEventListener('touchcancel', () => {
      this.isHovering = this.isHolding = this.isTouching = false;
      this.targetFrame = 0;
      this.element.style.filter = 'drop-shadow(0 0 0px rgba(0,0,0,0))';
      this.element.classList.remove('touching');
    });
  }

  updateBackgroundPosition() {
    const frameIndex = Math.floor(this.currentFrame);
    const xPos = frameIndex * this.frameWidth;
    this.element.style.backgroundPosition = `-${xPos}px 0`;
  }

  animate() {
    if (this.isHovering) {
      // Forward animation
      if (this.holdFrame === null) {
        // Loop continuously (work icon)
        this.currentFrame += this.loopSpeed;
        if (this.currentFrame >= this.frameCount - 1) {
          this.currentFrame = 0;
        }
      } else {
        // Animate to hold frame (art, contacts, edu)
        if (!this.isHolding && Math.abs(this.currentFrame - this.holdFrame) < 0.5) {
          this.isHolding = true;
          this.currentFrame = this.holdFrame;
          this.targetFrame = this.holdFrame;
        }
        
        if (!this.isHolding) {
          const distance = Math.abs(this.targetFrame - this.currentFrame);
          const speed = distance < 2 ? 0.3 : this.forwardSpeed;
          this.currentFrame += (this.targetFrame - this.currentFrame) * speed;
          
          if (distance < 0.1) {
            this.currentFrame = this.targetFrame;
          }
        }
      }
    } else {
      // Reverse animation
      if (this.currentFrame > 0) {
        this.currentFrame -= this.reverseSpeed;
        if (this.currentFrame < 0) {
          this.currentFrame = 0;
        }
      }
    }

    this.updateBackgroundPosition();
    this.animationFrame = requestAnimationFrame(() => this.animate());
  }

  reset() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    this.isHovering = this.isHolding = this.isTouching = false;
    this.targetFrame = this.currentFrame = 0;
    this.element.style.filter = 'drop-shadow(0 0 0px rgba(0,0,0,0))';
    this.element.classList.remove('touching');
    this.updateBackgroundPosition();
    this.animate();
  }
}

/* ========================================================================
   TRANSITION MANAGER
   ======================================================================== */
const TransitionManager = {
  isTransitioning: false,
  transitionVideo: null,
  contactsPage: null,
  eduPage: null,
  mainContent: null,
  wallInstance: null,

  init() {
    this.transitionVideo = Utils.getElement('transitionVideo');
    this.contactsPage    = Utils.getElement('contactsPage');
    this.eduPage         = Utils.getElement('eduPage');
    this.mainContent     = Utils.getElement('mainContent');
    
    console.log('üé¨ [TRANSITION MANAGER] Initialized with paths:', {
      CONTACTS_FORWARD: CONFIG.TRANSITION.CONTACTS_FORWARD,
      CONTACTS_REVERSE: CONFIG.TRANSITION.CONTACTS_REVERSE,
      EDU_FORWARD: CONFIG.TRANSITION.EDU_FORWARD,
      EDU_REVERSE: CONFIG.TRANSITION.EDU_REVERSE
    });
    
    this.setupContactsTransition();
    this.setupEduTransition();
    this.setupWorkTransition();
    this.setupReverseTransition(Utils.getElement('backButtonContacts'), 'contacts');
    this.setupReverseTransition(Utils.getElement('backButtonEdu'),      'edu');
    // Wall back button is set up in initializeWall() - not here
    this.setupContentBackButton();
  },

  setupContentBackButton() {
    const backButton = Utils.getElement('backButtonContent');
    if (!backButton) return;
    
    backButton.addEventListener('click', async () => {
      if (this.isTransitioning) return;
      this.isTransitioning = true;
      try {
        // Fade out content
        const wallContent = Utils.getElement('wall-content');
        await new Promise(resolve => {
          gsap.to(wallContent, {
            opacity: 0,
            duration: 0.6,
            ease: 'power2.in',
            onComplete: resolve
          });
        });

        wallContent.classList.remove('visible');

        // Show home page
        this.mainContent.style.display = 'flex';
        const bg = Utils.getElement('bgVideo');
        const eyeOffset = Utils.getElement('eyeOffset');
        const icons = document.querySelectorAll('.icon');
        
        bg.style.display = 'block';
        gsap.set([bg, eyeOffset, ...icons], { opacity: 0 });
        
        await new Promise(resolve => {
          gsap.to([bg, eyeOffset, ...icons], {
            opacity: 1,
            duration: 0.6,
            ease: 'power2.out',
            onComplete: resolve
          });
          icons.forEach(i => i.classList.remove('icon-hidden'));
        });

        // Reset icon animations
        setTimeout(() => {
          Object.values(window.iconInstances).forEach(inst => inst.reset());
        }, 100);

        console.log('‚úÖ [WALL CONTENT] Back to home');
      } catch (e) {
        console.error('Content back transition error:', e);
      } finally { this.isTransitioning = false; }
    });
  },

  // NOTE: setupWorkBackButton removed - was dead code for unused #backButtonWork element
  // The actual wall back button (#backButtonWall) is handled in initializeWall()

  loadLibrary(url, globalName) {
    return new Promise((resolve, reject) => {
      // Check if library is already loaded
      if (window[globalName]) {
        console.log(`‚úÖ Library already cached: ${globalName}`);
        resolve(window[globalName]);
        return;
      }

      const script = document.createElement('script');
      script.src = url;
      script.onload = () => {
        console.log(`‚úÖ Script loaded: ${url}`);
        setTimeout(() => {
          const lib = window[globalName];
          if (lib) {
            console.log(`‚úÖ Library available as window.${globalName}`);
            resolve(lib);
          } else {
            reject(new Error(`Library ${globalName} not found after loading ${url}`));
          }
        }, 100);
      };
      script.onerror = () => reject(new Error(`Failed to load ${url}`));
      document.head.appendChild(script);
    });
  },

  async playTransitionVideo(path) {
    console.log('üé¨ [TRANSITION] Attempting to load video:', path);
    const v = this.transitionVideo, src = v.querySelector('source');
    
    v.style.transform = `translateY(${CONFIG.TRANSITION.OFFSET}px)`;
    src.src = path;
    
    console.log('üé¨ [TRANSITION] Video element src set to:', src.src);
    console.log('üé¨ [TRANSITION] Full resolved URL:', new URL(src.src, window.location.href).href);
    
    // Add error listener
    v.onerror = (e) => {
      console.error('‚ùå [TRANSITION] Video error:', e);
      console.error('‚ùå [TRANSITION] Video error details:', {
        error: v.error,
        networkState: v.networkState,
        readyState: v.readyState
      });
    };
    
    src.onerror = (e) => {
      console.error('‚ùå [TRANSITION] Source error:', e);
    };
    
    v.onloadstart = () => console.log('‚è≥ [TRANSITION] Video load started');
    v.onloadedmetadata = () => console.log('‚úÖ [TRANSITION] Video metadata loaded');
    v.oncanplay = () => console.log('‚úÖ [TRANSITION] Video can play');
    
    v.load();
    v.style.display = 'block';
    v.currentTime = 0;
    
    try {
      await v.play();
      console.log('‚ñ∂Ô∏è [TRANSITION] Video playing successfully');
    } catch (error) {
      console.error('‚ùå [TRANSITION] Play failed:', error);
      throw error;
    }
    
    return v.play();
  },

  waitForVideoEnd() {
    return new Promise(resolve => { this.transitionVideo.onended = resolve; });
  },

  fadeInPageContent(page) {
    const kids = Array.from(page.children);
    gsap.set(kids, { opacity: 0, y: 12 });
    gsap.to(kids, {
      opacity: 1, y: 0,
      duration: CONFIG.GSAP.PAGE_CONTENT_DURATION,
      stagger:  CONFIG.GSAP.PAGE_CONTENT_STAGGER,
      delay:    CONFIG.GSAP.PAGE_CONTENT_DELAY,
      ease:     'power2.out'
    });
  },

  fadeIconsOut() {
    const icons = document.querySelectorAll('.icon');
    icons.forEach(i => i.classList.add('icon-hidden'));
    gsap.to(icons, { opacity: 0, duration: CONFIG.GSAP.ICON_FADE, ease: 'power2.in' });
  },

  fadeIconsIn(delaySeconds = 0) {
    const icons = document.querySelectorAll('.icon');
    gsap.to(icons, {
      opacity: 1,
      duration: CONFIG.GSAP.ICON_FADE,
      delay:    delaySeconds,
      ease:     'power2.out',
      onStart:  () => icons.forEach(i => i.classList.remove('icon-hidden'))
    });
  },

  setupContactsTransition() {
    Utils.getElement('icon-contacts').addEventListener('click', async () => {
      console.log('üëÜ [CONTACTS] Icon clicked');
      if (this.isTransitioning) {
        console.log('‚ö†Ô∏è [CONTACTS] Already transitioning, ignoring click');
        return;
      }
      this.isTransitioning = true;
      console.log('üöÄ [CONTACTS] Starting transition');
      try {
        EyeSystem.blinkOnce();
        await Utils.wait(CONFIG.TIMING.BLINK_AFTER_TRANSITION);
        await EyeSystem.resetToCenter();

        await this.playTransitionVideo(CONFIG.TRANSITION.CONTACTS_FORWARD);
        setTimeout(() => this.fadeIconsOut(), CONFIG.TIMING.CONTACTS_ICON_FADE);
        await this.waitForVideoEnd();

        this.mainContent.style.display      = 'none';
        this.transitionVideo.style.display  = 'none';
        this.contactsPage.style.display     = 'flex';
        Utils.getElement('bgFreeze').style.display = 'block';

        this.fadeInPageContent(this.contactsPage);
        ContactsEyeSystem.start();
      } catch (e) {
        console.error('Contacts transition error:', e);
        this.handleTransitionError('contacts');
      } finally { this.isTransitioning = false; }
    });
  },

  setupEduTransition() {
    Utils.getElement('icon-edu').addEventListener('click', async () => {
      console.log('üëÜ [EDU] Icon clicked');
      if (this.isTransitioning) {
        console.log('‚ö†Ô∏è [EDU] Already transitioning, ignoring click');
        return;
      }
      this.isTransitioning = true;
      console.log('üöÄ [EDU] Starting transition');
      try {
        EyeSystem.blinkOnce();
        await Utils.wait(CONFIG.TIMING.BLINK_AFTER_TRANSITION);
        await EyeSystem.resetToCenter();

        Utils.getElement('bgFreeze').style.display = 'none';
        gsap.to(Utils.getElement('eyeOffset'), { opacity: 0, duration: CONFIG.GSAP.EYE_FADE_FAST, ease: 'power2.in' });

        this.transitionVideo.classList.add('under-icons');
        await this.playTransitionVideo(CONFIG.TRANSITION.EDU_FORWARD);
        setTimeout(() => this.fadeIconsOut(), CONFIG.TIMING.EDU_ICON_FADE);
        await this.waitForVideoEnd();

        this.transitionVideo.classList.remove('under-icons');
        this.mainContent.style.display     = 'none';
        this.transitionVideo.style.display = 'none';
        this.eduPage.style.display         = 'flex';

        this.fadeInPageContent(this.eduPage);
      } catch (e) {
        console.error('Edu transition error:', e);
        this.handleTransitionError('edu');
      } finally { this.isTransitioning = false; }
    });
  },

  setupWorkTransition() {
    Utils.getElement('icon-work').addEventListener('click', async () => {
      console.log('üëÜ [WORK] Icon clicked');
      if (this.isTransitioning) {
        console.log('‚ö†Ô∏è [WORK] Already transitioning, ignoring click');
        return;
      }
      this.isTransitioning = true;
      console.log('üöÄ [WORK] Starting transition');
      try {
        EyeSystem.blinkOnce();
        await Utils.wait(CONFIG.TIMING.BLINK_AFTER_TRANSITION);
        await EyeSystem.resetToCenter();

        // Fade out home elements + fade in wall simultaneously
        const eyeOffset = Utils.getElement('eyeOffset');
        const icons = document.querySelectorAll('.icon');
        const bg = Utils.getElement('bgVideo');
        const wallFullscreen = Utils.getElement('wall-fullscreen');
        const clickText = Utils.getElement('wall-click-text');
        const backBtn = Utils.getElement('backButtonWall');
        
        // Enable wall interactions (visibility only - physics stays off until animation completes)
        wallFullscreen.style.pointerEvents = 'auto';
        backBtn.style.pointerEvents = 'auto';
        backBtn.style.visibility = 'visible';
        clickText.style.visibility = 'visible';
        
        // Show wall immediately at full opacity (underneath home page)
        gsap.set(wallFullscreen, { opacity: 1 });
        gsap.set([backBtn, clickText], { opacity: 0 });
        
        await new Promise(resolve => {
          // Fade out home elements to reveal wall underneath
          gsap.to([eyeOffset, ...icons, bg], {
            opacity: 0,
            duration: 0.6,
            ease: 'power2.in'
          });
          // Fade in UI elements on top of wall
          gsap.to([clickText, backBtn], {
            opacity: 1,
            duration: 0.6,
            ease: 'power2.in',
            onComplete: () => {
              // NOW enable wall physics after animation is done
              console.log('üîç [WORK] Checking wallInstance:', this.wallInstance);
              console.log('üîç [WORK] setActive function:', this.wallInstance?.setActive);
              if (this.wallInstance?.setActive) {
                this.wallInstance.setActive(true);
                this.wallInstance.resetDragState?.();
                console.log('‚úÖ Wall physics now active');
              } else {
                console.error('‚ùå wallInstance.setActive not found!');
              }
              resolve();
            }
          });
          icons.forEach(i => i.classList.add('icon-hidden'));
        });

        this.mainContent.style.display = 'none';
        bg.style.display = 'none';

        console.log('‚úÖ [WORK] Work page ready');
      } catch (e) {
        console.error('Work transition error:', e);
        this.handleTransitionError('work');
      } finally { this.isTransitioning = false; }
    });
  },

  async drawGridTransition() {
    const cols = 16;
    const rows = 9;
    const gridOverlay = document.createElement('canvas');
    gridOverlay.width = window.innerWidth;
    gridOverlay.height = window.innerHeight;
    gridOverlay.style.position = 'fixed';
    gridOverlay.style.top = '0';
    gridOverlay.style.left = '0';
    gridOverlay.style.zIndex = '999';
    gridOverlay.style.cursor = 'pointer';
    document.body.appendChild(gridOverlay);

    const ctx = gridOverlay.getContext('2d');
    const cellWidth = gridOverlay.width / cols;
    const cellHeight = gridOverlay.height / rows;

    // Animate grid drawing
    const totalCells = cols * rows;
    let drawnCells = 0;
    const drawSpeed = 8; // cells per frame

    return new Promise((resolve) => {
      const animate = () => {
        ctx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 2;

        // Draw cells that are currently being animated
        for (let i = 0; i < drawnCells && i < totalCells; i++) {
          const col = i % cols;
          const row = Math.floor(i / cols);
          const x = col * cellWidth;
          const y = row * cellHeight;

          ctx.strokeRect(x, y, cellWidth, cellHeight);
        }

        drawnCells += drawSpeed;

        if (drawnCells < totalCells) {
          requestAnimationFrame(animate);
        } else {
          // Grid fully drawn, fade it out with the background
          gsap.to(gridOverlay, {
            opacity: 0,
            duration: 1,
            ease: 'power2.in',
            onComplete: () => {
              document.body.removeChild(gridOverlay);
              resolve();
            }
          });
        }
      };
      animate();
    });
  },

  async initializeWall() {
    // Prevent double initialization
    if (this.wallInstance) {
      console.warn('‚ö†Ô∏è [WALL] Already initialized, skipping');
      return;
    }
    
    console.log('üéÆ [WALL] Initializing THREE.js wall...');
    // Create or get the wallContainer div inside #wall-fullscreen
    let wallContainer = document.querySelector('#wall-fullscreen .wallContainer');
    if (!wallContainer) {
      wallContainer = document.createElement('div');
      wallContainer.className = 'wallContainer';
      Utils.getElement('wall-fullscreen').appendChild(wallContainer);
    }
    
    // Dynamically import the ES6 modules (same as WALL.html uses)
    const THREE = await import('https://unpkg.com/three@0.152.2/build/three.module.js');
    const CANNON = await import('https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js');
    
    console.log('‚úÖ Libraries loaded via dynamic import');
    
    // Scene setup
    const scene = new THREE.Scene();
    const aspect = window.innerWidth / window.innerHeight;
    const frustumHeight = 27.20;
    const frustumWidth = frustumHeight * aspect;
    
    const camera = new THREE.OrthographicCamera(
      -frustumWidth / 2, frustumWidth / 2,
      frustumHeight / 2, -frustumHeight / 2,
      0.1, 1000
    );
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    // Set initial size to match CSS size of wallContainer
    function setRendererSizeToContainer() {
      const width = wallContainer.clientWidth;
      const height = wallContainer.clientHeight;
      renderer.setSize(width, height, false);
    }
    setRendererSizeToContainer();
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.setClearColor(0x000000, 1);
    wallContainer.appendChild(renderer.domElement);
    renderer.domElement.style.zIndex = '1';
    renderer.domElement.style.position = 'absolute';
    renderer.domElement.style.inset = '0';
    console.log('üé• Renderer initialized and appended to container');
    
    scene.add(new THREE.AmbientLight(0x888888));
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 10, 10);
    scene.add(light);

    // Create text behind the wall (visible when wall is knocked down)
    const textCanvas = document.createElement('canvas');
    textCanvas.width = 2048;
    textCanvas.height = 512;
    const textCtx = textCanvas.getContext('2d');
    textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
    textCtx.fillStyle = 'white';
    textCtx.font = 'bold 120px Arial';
    textCtx.textAlign = 'center';
    textCtx.textBaseline = 'middle';
    textCtx.shadowColor = 'rgba(0,0,0,0.7)';
    textCtx.shadowBlur = 12;
    textCtx.fillText('work exp goes here', textCanvas.width / 2, textCanvas.height / 2);

    const textTexture = new THREE.CanvasTexture(textCanvas);
    textTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    textTexture.minFilter = THREE.LinearFilter;
    textTexture.magFilter = THREE.LinearFilter;
    textTexture.needsUpdate = true;
    const textMat = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true });
    const textGeo = new THREE.PlaneGeometry(30, 8, 1, 1);
    const textMesh = new THREE.Mesh(textGeo, textMat);
    textMesh.position.set(0, 13.5, -10); // Centered at wall height, behind the wall
    scene.add(textMesh);
    console.log('üìù Text mesh added at position:', textMesh.position);


    // Physics world - exactly like WALL.html
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.81, 0) });
    world.solver.iterations = 20;

    const cubeMaterial = new CANNON.Material('cube');
    const floorMaterial = new CANNON.Material('floor');

    const glueContactMaterial = new CANNON.ContactMaterial(cubeMaterial, floorMaterial, {
      friction: 0.8,
      restitution: 0.05
    });
    world.addContactMaterial(glueContactMaterial);

    const cubeToCuteMaterial = new CANNON.ContactMaterial(cubeMaterial, cubeMaterial, {
      friction: 0.8,
      restitution: 0.05
    });
    world.addContactMaterial(cubeToCuteMaterial);

    // Track all wall blocks
    const objects = [];

    // Floor - exactly like WALL.html
    const floorGeo = new THREE.BoxGeometry(50, 1, 50);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
    const floorMesh = new THREE.Mesh(floorGeo, floorMat);
    floorMesh.position.y = -0.5;
    scene.add(floorMesh);

    const floorShape = new CANNON.Box(new CANNON.Vec3(25, 0.5, 25));
    const floorBody = new CANNON.Body({ mass: 0, material: floorMaterial });
    floorBody.position.y = -0.5;
    floorBody.addShape(floorShape);
    world.addBody(floorBody);

    // Wall setup - exactly like WALL.html
    const wallRows = 9;
    const wallCols = 16;
    const cubeSize = 3;

    const wallLoaded = new Promise((resolve, reject) => {
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load('assets/background/mog.png', (baseTexture) => {
        console.log('üì∏ Texture loaded, creating wall cubes...');
        try {
          // Create cubes with mosaic texture
          for (let y = 0; y < wallRows; y++) {
            for (let x = 0; x < wallCols; x++) {
              const geo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
              
              // Create a custom canvas texture for this cube's section
              const canvas = document.createElement('canvas');
              canvas.width = 256;
              canvas.height = 256;
              const ctx = canvas.getContext('2d');
              
              // Draw the corresponding section of the mosaic
              const imgWidth = baseTexture.image.width;
              const imgHeight = baseTexture.image.height;
              
              const srcX = (x / wallCols) * imgWidth;
              const srcY = ((wallRows - 1 - y) / wallRows) * imgHeight;
              const srcW = imgWidth / wallCols;
              const srcH = imgHeight / wallRows;
              
              ctx.drawImage(baseTexture.image, srcX, srcY, srcW, srcH, 0, 0, 256, 256);
              
              const texture = new THREE.CanvasTexture(canvas);
              texture.colorSpace = THREE.SRGBColorSpace;
              const frontMat = new THREE.MeshLambertMaterial({ map: texture });
              const sideMat = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
              // Cube face order: +X, -X, +Y, -Y, +Z (front), -Z (back)
              const materials = [sideMat, sideMat, sideMat, sideMat, frontMat, sideMat];
              const mesh = new THREE.Mesh(geo, materials);
              mesh.position.set((x - (wallCols / 2)) * cubeSize, y * cubeSize + cubeSize / 2, -(cubeSize / 2));
              scene.add(mesh);

              const boxShape = new CANNON.Box(new CANNON.Vec3(cubeSize / 2, cubeSize / 2, cubeSize / 2));
              const body = new CANNON.Body({ mass: 1 });
              body.position.set((x - (wallCols / 2)) * cubeSize, y * cubeSize + cubeSize / 2, -(cubeSize / 2));
              body.addShape(boxShape);
              body.material = cubeMaterial;
              world.addBody(body);

              objects.push({ mesh: mesh, body: body });
            }
          }
          console.log('üß± Wall created with', objects.length, 'cubes');
          resolve();
        } catch (e) {
          console.error('‚ùå Error creating wall:', e);
          reject(e);
        }
      }, undefined, (error) => {
        console.error('‚ùå Failed to load texture:', error);
        reject(error);
      });
    });

    await wallLoaded;

    camera.position.z = 10.01;
    camera.position.y = 13.61;
    camera.position.x = -1.42;

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedBody = null;
    let hasDragged = false;
    let dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    let dragPoint = new THREE.Vector3();

    // Handle resize
    const onWindowResize = () => {
      // Get the CSS size of the wallContainer
      const width = wallContainer.clientWidth;
      const height = wallContainer.clientHeight;
      renderer.setSize(width, height, false);
      renderer.setPixelRatio(window.devicePixelRatio);
      // Update camera aspect and frustum
      const aspect = width / height;
      const frustumHeight = 27.20;
      const frustumWidth = frustumHeight * aspect;
      camera.left = -frustumWidth / 2;
      camera.right = frustumWidth / 2;
      camera.top = frustumHeight / 2;
      camera.bottom = -frustumHeight / 2;
      camera.updateProjectionMatrix();
    };
    window.addEventListener('resize', onWindowResize, false);
    // Also call once on init in case container size changes after DOM ready
    setTimeout(onWindowResize, 0);

    // Mouse down - select cube for dragging - exactly like WALL.html
    document.addEventListener('mousedown', (event) => {
      // Only interact when wall is active
      if (!wallActive) {
        console.log('üö´ [WALL] mousedown ignored - wallActive is', wallActive);
        return;
      }
      console.log('üëÜ [WALL] mousedown - wallActive is', wallActive);
      
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      
      const intersects = raycaster.intersectObjects(scene.children);

      for (let intersection of intersects) {
        const clickedMesh = intersection.object;
        const objectData = objects.find(obj => obj.mesh === clickedMesh);
        
        if (objectData) {
          selectedBody = objectData.body;
          dragPlane.setFromNormalAndCoplanarPoint(
            camera.position.clone().normalize(),
            selectedBody.position
          );
          raycaster.ray.intersectPlane(dragPlane, dragPoint);
          break;
        }
      }
    }, false);

    // Mouse move - drag cube - exactly like WALL.html
    document.addEventListener('mousemove', (event) => {
      if (!selectedBody || !wallActive) return;

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      raycaster.ray.intersectPlane(dragPlane, dragPoint);

      const force = dragPoint.clone().sub(selectedBody.position).multiplyScalar(5);
      selectedBody.velocity.copy(force);
      
      // Hide click text on first drag
      if (!hasDragged) {
        hasDragged = true;
        const clickTextEl = Utils.getElement('wall-click-text');
        if (clickTextEl) {
          clickTextEl.style.animation = 'none';
          clickTextEl.style.transition = 'opacity 0.5s';
          clickTextEl.style.opacity = '0';
        }
      }
    }, false);

    // Mouse up - release cube - exactly like WALL.html
    document.addEventListener('mouseup', (event) => {
      selectedBody = null;
    }, false);

    // Click - apply impulse - exactly like WALL.html
    document.addEventListener('click', (event) => {
      // Only interact when wall is active
      if (!wallActive) {
        console.log('üö´ [WALL] click ignored - wallActive is', wallActive);
        return;
      }
      
      // Don't apply impulse if clicking UI elements
      if (event.target.id === 'backButtonWall' || event.target.id === 'wall-click-text') {
        return;
      }
      
      console.log('üëÜ [WALL] click - applying impulse');
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      
      const intersects = raycaster.intersectObjects(scene.children);

      for (let intersection of intersects) {
        const clickedMesh = intersection.object;
        const objectData = objects.find(obj => obj.mesh === clickedMesh);
        
        if (objectData) {
          const impulse = new CANNON.Vec3(Math.random() * 1 - 0.5, Math.random() * 1.5 + 1.5, Math.random() * 1 - 0.5);
          objectData.body.applyImpulse(impulse, objectData.body.position);
          break;
        }
      }
    }, false);

    // Store initial body states for reset BEFORE animation starts
    console.log('üì¶ Storing initial states for', objects.length, 'objects');
    const initialStates = objects.map(obj => ({
      position: obj.body.position.clone(),
      quaternion: obj.body.quaternion.clone()
    }));

    // Flag to pause physics during reset animation
    let isResetting = false;
    
    // Flag to track if wall is currently active/shown - prevents click propagation issues
    let wallActive = false;

    // Animation loop - physics only runs when wall is active and not resetting
    function animate() {
      requestAnimationFrame(animate);

      // Only run physics when wall is active AND not resetting
      if (wallActive && !isResetting) {
        world.step(1 / 60);

        for (const { mesh, body } of objects) {
          mesh.position.copy(body.position);
          mesh.quaternion.copy(body.quaternion);
        }
      }

      renderer.render(scene, camera);
    }

    console.log('‚ñ∂Ô∏è Starting animation loop...');
    animate();

    // Wall is preloaded but hidden - pointer events disabled until work transition
    wallContainer.style.pointerEvents = 'none';
    const clickText = Utils.getElement('wall-click-text');
    const backBtn = Utils.getElement('backButtonWall');
    // Keep UI hidden initially - will be shown when entering work page
    clickText.style.visibility = 'hidden';
    backBtn.style.visibility = 'hidden';
    backBtn.style.pointerEvents = 'none';

    // Store wall instance with reset method BEFORE setting up button
    const RESET_DURATION = 1.5; // seconds - adjustable

    this.wallInstance = {
      renderer, scene, camera, objects, world, CANNON,
      setActive: (active) => { 
        console.log('üéØ [WALL] setActive called with:', active, '(was:', wallActive, ')');
        wallActive = active; 
        console.log('üéØ [WALL] wallActive now:', wallActive);
      },
      resetDragState: () => {
        hasDragged = false;
        const clickTextEl = Utils.getElement('wall-click-text');
        if (clickTextEl) {
          clickTextEl.style.animation = 'fadeInOut 2s infinite';
          clickTextEl.style.opacity = '1';
        }
      },
      resetPhysics: () => {
        console.log('üîÑ Resetting physics bodies...');
        objects.forEach((obj, i) => {
          const state = initialStates[i];
          obj.body.position.copy(state.position);
          obj.body.quaternion.copy(state.quaternion);
          obj.body.velocity.set(0, 0, 0);
          obj.body.angularVelocity.set(0, 0, 0);
          obj.mesh.position.copy(obj.body.position);
          obj.mesh.quaternion.copy(obj.body.quaternion);
        });
      },
      // Animated reset - smoothly moves cubes back to original positions
      animateReset: () => {
        return new Promise(resolve => {
          console.log('üé¨ Animating cubes back to wall...', objects.length, 'objects');
          console.log('üì¶ Initial states:', initialStates.length);
          
          // PAUSE physics - let GSAP control meshes
          isResetting = true;
          
          // Stop all body movement
          objects.forEach(obj => {
            obj.body.velocity.set(0, 0, 0);
            obj.body.angularVelocity.set(0, 0, 0);
            obj.body.sleep();
          });
          
          // Animate each mesh back to original position using GSAP
          const timeline = gsap.timeline({
            onComplete: () => {
              // Restore physics bodies to exact positions
              objects.forEach((obj, i) => {
                const state = initialStates[i];
                obj.body.position.copy(state.position);
                obj.body.quaternion.copy(state.quaternion);
                obj.body.velocity.set(0, 0, 0);
                obj.body.angularVelocity.set(0, 0, 0);
                obj.body.wakeUp();
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
              });
              // RESUME physics
              isResetting = false;
              console.log('‚úÖ Cube reset animation complete');
              resolve();
            }
          });
          
          // Animate all meshes positions
          objects.forEach((obj, i) => {
            const target = initialStates[i];
            timeline.to(obj.mesh.position, {
              x: target.position.x,
              y: target.position.y,
              z: target.position.z,
              duration: RESET_DURATION,
              ease: 'power2.inOut'
            }, 0);
            timeline.to(obj.mesh.quaternion, {
              x: target.quaternion.x,
              y: target.quaternion.y,
              z: target.quaternion.z,
              w: target.quaternion.w,
              duration: RESET_DURATION,
              ease: 'power2.inOut'
            }, 0);
          });
        });
      }
    };

    // Setup back button - use arrow function to preserve 'this' context
    const handleWallBackClick = async () => {
      console.log('üîô [BACK BUTTON] Click detected!'); // DEBUG
      if (TransitionManager.isTransitioning) {
        console.log('üîô [BACK BUTTON] Blocked - already transitioning');
        return;
      }
      TransitionManager.isTransitioning = true;
      try {
        const wallFullscreen = Utils.getElement('wall-fullscreen');
        const clickTextEl = Utils.getElement('wall-click-text');
        const backBtnEl = Utils.getElement('backButtonWall');
        
        // Deactivate wall physics immediately to prevent further interaction
        wallActive = false;
        
        // First: fade out back button and click text
        await new Promise(resolve => {
          gsap.to([backBtnEl, clickTextEl], {
            opacity: 0,
            duration: 0.3,
            ease: 'power2.in',
            onComplete: () => {
              backBtnEl.style.visibility = 'hidden';
              clickTextEl.style.visibility = 'hidden';
              resolve();
            }
          });
        });

        // Second: animate cubes back to original positions
        console.log('üîÑ [WALL EXIT] Animating reset');
        await TransitionManager.wallInstance.animateReset();
        
        // Brief pause to show completed wall before fading
        await new Promise(r => setTimeout(r, 300));
        
        // Third: fade home page ON TOP of wall (don't fade wall out)
        TransitionManager.mainContent.style.display = 'flex';
        const bg = Utils.getElement('bgVideo');
        const eyeOffset = Utils.getElement('eyeOffset');
        const icons = document.querySelectorAll('.icon');
        
        bg.style.display = 'block';
        gsap.set([bg, eyeOffset, ...icons], { opacity: 0 });
        
        await new Promise(resolve => {
          gsap.to([bg, eyeOffset, ...icons], {
            opacity: 1,
            duration: 0.6,
            ease: 'power2.out',
            onComplete: resolve
          });
          icons.forEach(i => i.classList.remove('icon-hidden'));
        });

        // NOW hide the wall (it's behind home page anyway)
        gsap.set(wallFullscreen, { opacity: 0 });
        wallFullscreen.style.pointerEvents = 'none';

        setTimeout(() => {
          Object.values(window.iconInstances).forEach(inst => inst.reset());
        }, 100);

        console.log('‚úÖ [WALL EXIT] Back to home from wall');
      } catch (e) {
        console.error('Wall back transition error:', e);
      } finally { TransitionManager.isTransitioning = false; }
    };

    backBtn.addEventListener('click', handleWallBackClick);

    // DEBUG: Track any style changes to the back button
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'style') {
          const opacity = backBtn.style.opacity;
          const visibility = backBtn.style.visibility;
          console.log('üîç [BUTTON STYLE CHANGED]', { opacity, visibility, trace: new Error().stack });
        }
      });
    });
    observer.observe(backBtn, { attributes: true, attributeFilter: ['style'] });

    console.log('‚úÖ [WALL] Wall fully initialized and running!');
    console.log('üîç [WALL] this.wallInstance:', this.wallInstance);
    console.log('üîç [WALL] TransitionManager.wallInstance:', TransitionManager.wallInstance);
  },

  setupReverseTransition(backButton, pageType) {
    backButton.addEventListener('click', async () => {
      if (this.isTransitioning) return;
      this.isTransitioning = true;
      try {
        const targetPage    = pageType === 'contacts' ? this.contactsPage : this.eduPage;
        const reverseVideo   = pageType === 'contacts' ? CONFIG.TRANSITION.CONTACTS_REVERSE : CONFIG.TRANSITION.EDU_REVERSE;

        // Stop contacts eye animation when leaving
        if (pageType === 'contacts') {
          ContactsEyeSystem.stop();
        }

        if (reverseVideo) {
          const video = this.transitionVideo, source = video.querySelector('source');
          video.style.transform = `translateY(${CONFIG.TRANSITION.OFFSET}px)`;
          source.src = reverseVideo;
          video.load();
          video.currentTime = 0;
          if (pageType === 'edu') video.classList.add('under-icons');

          video.style.display = 'block';
          await video.play();

          requestAnimationFrame(() => {
            targetPage.style.display = 'none';
            this.mainContent.style.display = 'block';
            Utils.getElement('bgFreeze').style.display = 'block';
          });

          Object.values(window.iconInstances).forEach(inst => inst.reset());

          if (pageType === 'contacts') {
            gsap.set(Utils.getElement('eyeOffset'), { opacity: 1 });
          }

          const iconDelay = (pageType === 'edu' ? CONFIG.TIMING.EDU_REVERSE_ICON_FADE : 300) / 1000;
          this.fadeIconsIn(iconDelay);

          await this.waitForVideoEnd();

          if (pageType === 'edu') {
            gsap.to(Utils.getElement('eyeOffset'), { opacity: 1, duration: CONFIG.GSAP.EYE_FADE_FAST, ease: 'power2.out' });
          }

          video.classList.remove('under-icons');
          video.style.display = 'none';
        } else {
          targetPage.style.display = 'none';
          this.mainContent.style.display = 'block';
          Utils.getElement('bgFreeze').style.display = 'block';
          Object.values(window.iconInstances).forEach(inst => inst.reset());
          this.fadeIconsIn(0.3);
          gsap.set(Utils.getElement('eyeOffset'), { opacity: 1 });
        }

        setTimeout(() => EyeSystem.blinkOnce(), 100);
      } catch (e) {
        console.error('Reverse transition error:', e);
        this.handleTransitionError(null);
      } finally { this.isTransitioning = false; }
    });
  },

  handleTransitionError(pageType) {
    this.transitionVideo.style.display = 'none';
    if (pageType === 'contacts') {
      this.mainContent.style.display   = 'none';
      this.contactsPage.style.display  = 'flex';
      this.eduPage.style.display       = 'none';
    } else if (pageType === 'edu') {
      this.mainContent.style.display   = 'none';
      this.eduPage.style.display       = 'flex';
      this.contactsPage.style.display  = 'none';
    } else {
      this.contactsPage.style.display  = 'none';
      this.eduPage.style.display       = 'none';
      this.mainContent.style.display   = 'block';
      Utils.getElement('bgFreeze').style.display = 'block';
      gsap.set(Utils.getElement('eyeOffset'), { opacity: 1 });
      Object.values(window.iconInstances).forEach(inst => inst.reset());
      this.fadeIconsIn(0);
    }
  }
};

/* ========================================================================
   EYE SYSTEM
   ======================================================================== */
const EyeSystem = {
  eyeMove: null, eyeOffset: null, blinkLid: null,
  bgVideo: null, bgFreeze: null, ctx: null,
  eyeActive: false, eyeActivationTriggered: false,
  reflectionsMove: null,

  init() {
    this.eyeMove         = Utils.getElement('eyeMove');
    this.eyeOffset       = Utils.getElement('eyeOffset');
    this.blinkLid        = Utils.getElement('blinkLid');
    this.bgVideo         = Utils.getElement('bgVideo');
    this.bgFreeze        = Utils.getElement('bgFreeze');
    this.reflectionsMove = Utils.getElement('reflectionsMove');
    this.ctx             = this.bgFreeze.getContext('2d');
    this.setupVideoListeners();
    this.setupTracking();
    this.setupFallback();
  },

  setupVideoListeners() {
    this.bgVideo.addEventListener('timeupdate', () => {
      // Don't activate eye if loading hasn't completed yet
      if (!Preloader.loadingComplete) return;
      if (this.eyeActivationTriggered || this.eyeActive) return;
      if (this.bgVideo.currentTime >= CONFIG.TIMING.EYE_ACTIVATE_TIME) this.activateEye();
    });
    this.bgVideo.addEventListener('ended', () => {
      if (!Preloader.loadingComplete) return;
      if (this.eyeActivationTriggered || this.eyeActive) return;
      this.activateEye();
    });
  },

  activateEye() {
    this.eyeActivationTriggered = true;
    this.bgFreeze.width  = this.bgVideo.videoWidth;
    this.bgFreeze.height = this.bgVideo.videoHeight;
    if (this.bgFreeze.width > 0 && this.bgFreeze.height > 0) {
      try {
        this.ctx.drawImage(this.bgVideo, 0, 0, this.bgFreeze.width, this.bgFreeze.height);
        this.bgVideo.style.display  = 'none';
        this.bgFreeze.style.display = 'block';
        gsap.to(this.eyeOffset, { opacity: 1, duration: CONFIG.GSAP.EYE_FADE_ACTIVATE, ease: 'power2.out' });
        this.eyeActive = true;
        setTimeout(() => this.blinkOnce(), 100);
        this.startBlinking();
        Utils.log('‚úÖ Eye activated!');
      } catch (e) { console.error('Failed to draw video to canvas:', e); }
    }
  },

  setupTracking() {
    document.addEventListener('mousemove', (e) => {
      if (this.eyeActive && !DeviceDetector.isTouchDevice) this.updateEyePosition(e.clientX, e.clientY);
    });
    document.addEventListener('touchmove', (e) => {
      if (this.eyeActive && e.touches.length) this.updateEyePosition(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: true });
    document.addEventListener('touchstart', (e) => {
      if (this.eyeActive && e.touches.length) this.updateEyePosition(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: true });
  },

  updateEyePosition(cx, cy) {
    const x = (cx / window.innerWidth  - 0.5) * 120;
    const y = (cy / window.innerHeight - 0.5) * 60;
    this.eyeMove.setAttribute('transform', `translate(${x}, ${y})`);
    this.reflectionsMove.setAttribute('transform',
      `translate(${x * CONFIG.EYE.REFLECTION_MOVEMENT}, ${y * CONFIG.EYE.REFLECTION_MOVEMENT})`);
  },

  setupFallback() {
    const checkFallback = () => {
      // If loading isn't complete yet, check again later
      if (!Preloader.loadingComplete) {
        setTimeout(checkFallback, 1000);
        return;
      }
      // If eye is already active, no need for fallback
      if (this.eyeActive) return;
      
      // Wait for the normal eye activation time after loading, then trigger fallback
      setTimeout(() => {
        if (!this.eyeActive) {
          console.warn('‚ö†Ô∏è Eye fallback triggered');
          gsap.to(this.eyeOffset, { opacity: 1, duration: CONFIG.GSAP.EYE_FADE_ACTIVATE });
          this.eyeActive = true;
          this.startBlinking();
        }
      }, CONFIG.TIMING.EYE_FALLBACK_TIMEOUT);
    };
    checkFallback();
  },

  blinkOnce() {
    if (!this.eyeActive) return;
    this.blinkLid.style.animation = `blink ${CONFIG.TIMING.BLINK_SPEED}ms ease-in-out`;
    this.blinkLid.addEventListener('animationend', () => { this.blinkLid.style.animation = ''; }, { once: true });
  },
  
  blink() {
    this.blinkOnce();
    if (Math.random() < CONFIG.EYE.DOUBLE_BLINK_CHANCE)
      setTimeout(() => this.blinkOnce(), CONFIG.TIMING.DOUBLE_BLINK_DELAY);
  },
  
  startBlinking() {
    const loop = () => {
      this.blink();
      setTimeout(loop, CONFIG.TIMING.BLINK_MIN_DELAY + Math.random() * (CONFIG.TIMING.BLINK_MAX_DELAY - CONFIG.TIMING.BLINK_MIN_DELAY));
    };
    loop();
  },

  resetToCenter() {
    if (!this.eyeActive) return Promise.resolve();

    const attr = this.eyeMove.getAttribute('transform') || 'translate(0,0)';
    const m    = attr.match(/translate\(([-\d.]+),\s*([-\d.]+)\)/);
    const sx   = m ? parseFloat(m[1]) : 0;
    const sy   = m ? parseFloat(m[2]) : 0;
    if (sx === 0 && sy === 0) return Promise.resolve();

    const proxy = { x: sx, y: sy };
    return new Promise(resolve => {
      gsap.to(proxy, {
        x: 0, y: 0,
        duration: CONFIG.GSAP.EYE_RESET_DURATION,
        ease: 'power3.out',
        onUpdate: () => {
          this.eyeMove.setAttribute('transform', `translate(${proxy.x}, ${proxy.y})`);
          this.reflectionsMove.setAttribute('transform',
            `translate(${proxy.x * CONFIG.EYE.REFLECTION_MOVEMENT}, ${proxy.y * CONFIG.EYE.REFLECTION_MOVEMENT})`);
        },
        onComplete: resolve
      });
    });
  }
};

/* ========================================================================
   CONTACTS EYE SYSTEM - Animated eye background for contacts page
   ======================================================================== */
const ContactsEyeSystem = {
  canvas: null,
  ctx: null,
  eyes: [],
  isActive: false,
  animationId: null,
  lastTime: 0,
  lastRandomBlink: 0,
  mouseX: 0,
  mouseY: 0,
  activeHoverPattern: null,
  eyeCache: { open: null, closed: [], openRed: null, closedRed: [], openRainbow: [], closedRainbow: [] },
  
  // Easter egg state
  lastEnterTime: 0,
  easterEggInput: null,
  easterEggBuffer: '',
  rainbowMode: false,
  rainbowHue: 0,

  // Eye dimensions and scale
  EYE_WIDTH: 60,
  EYE_HEIGHT: 43,
  EYE_SCALE: 0.85,
  
  // Hover patterns - flat indices exactly like contacts-optimized.html
  hoverPatterns: {
    email: [398,399,400,401,402,403,404,405,406,407,901,900,899,898,897,896,895,894,893,973,1049,1125,1201,1277,1278,1279,1280,1281,1282,1283,1284,1285,674,675,676,677,678,679,680,681,757,833,909,985,1061,1137,1213,1289,1288,1287,1286,718,756,793,831,868,906,943,1018,981,1056,1093,1131,938,977,1092,1054,1015,397,892,902,826,750,598,522,446,436,474,513,590,667,744,782,483,521,558,596,633,671,708,746,783,821,435,511,587,663,739,815,473,549,625,701,777,853,484,560,636,712,788,864,891,929,930,931,932,933,934,935,936,937,939,940,360,361,362,363,364,365,366,367,368,369,628,551,705,1010,1086,1162,1238,719,795,871,947,1023,1099,1175,1251,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,408,370],
    phone: [777,853,929,1005,1081,1157,626,589,551,514,476,439,440,441,442,443,445,446,447,448,486,525,563,602,640,664,590,628,702,665,627,666,703,741,601,638,639,678,677,715,679,716,754,401,402,403,404,405,407,406,444,408,409,552,515,477,562,524,485,555,556,557,558,559,635,593,631,669,744,781,706,819,894,856,1046,1084,1123,1161,1200,1201,1202,1203,1205,1206,674,712,751,789,828,866,905,1057,1094,1132,1169,1207,1168,1167,1165,1164,1166,1204,1163,1162,594,595,596,597,634,633,632,670,671,672,673,825,1015,707,708,748,711,710,709,745,783,747,749,750,787,786,746,784,822,859,821,782,820,858,897,857,895,932,970,1008,1047,1085,1124,1086,1048,1009,971,933,972,896,934,973,1010,1011,1049,1125,1087,1050,1126,1088,1127,1128,1090,1053,1129,1091,1054,902,863,826,788,827,865,864,903,940,941,978,904,942,981,1018,980,1056,1093,1131,1130,1092,1055,1017,979,1016,1089,785,1196,1197,1198,1199,815,892,967,1044,1119,943,1019,931,1007,591,600,740,637,676,714,753,791,629,667,704,742,779,598],
    social: [332,371,409,448,486,524,561,599,636,598,560,523,447,370,407,445,521,559,522,484,446,482,635,673,710,748,785,637,676,714,753,791,830,867,942,905,1017,980,1055,1092,712,788,864,940,1054,1015,977,938,900,861,823,824,786,711,674,749,750,787,826,825,863,901,939,902,862,978,1016,979,941,904,866,829,790,752,713,675,751,789,828,865,903,827,860,899,937,976,1014,1053,1091,1130,1168,1131,1093,1056,1018,981,943,906,868,593,594,555,632,630,668,706,745,783,746,671,708,707,784,782,820,857,895,821,822,859,858,933,972,1010,1049,1087,1050,1012,975,936,898,974,935,897,934,896,973,1011,1013,1051,1088,1126,1163,1125,1086,1048,1009,971,932,515,477,440,401,363,400,438,439,476,399,361,398,436,474,437,475,513,514,551,552,590,485,483,670,669,408,631,588,625,587,404,442,403]
  },
  
  init() {
    this.canvas = document.getElementById('contactsCanvas');
    if (!this.canvas) {
      console.warn('ContactsEyeSystem: Canvas not found');
      return;
    }
    this.ctx = this.canvas.getContext('2d', { alpha: false });
    this.canvas.width = CONFIG.LAYOUT.DESIGN_WIDTH;
    this.canvas.height = CONFIG.LAYOUT.DESIGN_HEIGHT;
    this.createEyeCache();
    this.createEyeGrid();
    this.setupEventListeners();
    this.setupHoverPatterns();
    this.setupTextCarousel();
    console.log('‚úÖ ContactsEyeSystem initialized');
  },
  
  createEyeCache() {
    const padding = 4;
    const w = Math.floor((64 + padding * 2) * this.EYE_SCALE);
    const h = Math.floor((42 + padding * 2) * this.EYE_SCALE);
    
    // Create open eye sprite
    const openCanvas = document.createElement('canvas');
    openCanvas.width = w;
    openCanvas.height = h;
    const openCtx = openCanvas.getContext('2d');
    
    openCtx.translate(w / 2, h / 2);
    openCtx.scale(this.EYE_SCALE, this.EYE_SCALE);
    openCtx.beginPath();
    openCtx.moveTo(-30, 0);
    openCtx.quadraticCurveTo(-15, -18, 0, -19);
    openCtx.quadraticCurveTo(15, -18, 30, 0);
    openCtx.quadraticCurveTo(15, 18, 0, 19);
    openCtx.quadraticCurveTo(-15, 18, -30, 0);
    openCtx.closePath();
    openCtx.fillStyle = '#4a4a4a';
    openCtx.fill();
    
    this.eyeCache.open = openCanvas;
    
    // Create red version of open eye
    const openRedCanvas = document.createElement('canvas');
    openRedCanvas.width = w;
    openRedCanvas.height = h;
    const openRedCtx = openRedCanvas.getContext('2d');
    openRedCtx.translate(w / 2, h / 2);
    openRedCtx.scale(this.EYE_SCALE, this.EYE_SCALE);
    openRedCtx.beginPath();
    openRedCtx.moveTo(-30, 0);
    openRedCtx.quadraticCurveTo(-15, -18, 0, -19);
    openRedCtx.quadraticCurveTo(15, -18, 30, 0);
    openRedCtx.quadraticCurveTo(15, 18, 0, 19);
    openRedCtx.quadraticCurveTo(-15, 18, -30, 0);
    openRedCtx.closePath();
    openRedCtx.fillStyle = 'rgb(120, 0, 0)';
    openRedCtx.fill();
    this.eyeCache.openRed = openRedCanvas;
    
    // Create darker variations for closing animation
    for (let i = 0; i <= 10; i++) {
      const closedCanvas = document.createElement('canvas');
      closedCanvas.width = w;
      closedCanvas.height = h;
      const closedCtx = closedCanvas.getContext('2d');
      
      closedCtx.translate(w / 2, h / 2);
      closedCtx.scale(this.EYE_SCALE, this.EYE_SCALE);
      closedCtx.beginPath();
      closedCtx.moveTo(-30, 0);
      closedCtx.quadraticCurveTo(-15, -18, 0, -19);
      closedCtx.quadraticCurveTo(15, -18, 30, 0);
      closedCtx.quadraticCurveTo(15, 18, 0, 19);
      closedCtx.quadraticCurveTo(-15, 18, -30, 0);
      closedCtx.closePath();
      
      const grayValue = Math.floor(74 - (i / 10) * 32);
      closedCtx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
      closedCtx.fill();
      
      this.eyeCache.closed.push(closedCanvas);
      
      // Create red version
      const closedRedCanvas = document.createElement('canvas');
      closedRedCanvas.width = w;
      closedRedCanvas.height = h;
      const closedRedCtx = closedRedCanvas.getContext('2d');
      closedRedCtx.translate(w / 2, h / 2);
      closedRedCtx.scale(this.EYE_SCALE, this.EYE_SCALE);
      closedRedCtx.beginPath();
      closedRedCtx.moveTo(-30, 0);
      closedRedCtx.quadraticCurveTo(-15, -18, 0, -19);
      closedRedCtx.quadraticCurveTo(15, -18, 30, 0);
      closedRedCtx.quadraticCurveTo(15, 18, 0, 19);
      closedRedCtx.quadraticCurveTo(-15, 18, -30, 0);
      closedRedCtx.closePath();
      const redValue = Math.floor(120 - (i / 10) * 60);
      closedRedCtx.fillStyle = `rgb(${redValue}, 0, 0)`;
      closedRedCtx.fill();
      this.eyeCache.closedRed.push(closedRedCanvas);
    }
    
    // Create rainbow sprites (12 hues for smooth cycling)
    for (let hueIdx = 0; hueIdx < 12; hueIdx++) {
      const hue = hueIdx * 30; // 0, 30, 60, 90... 330
      
      // Open rainbow
      const openRainbow = document.createElement('canvas');
      openRainbow.width = w;
      openRainbow.height = h;
      const orCtx = openRainbow.getContext('2d');
      orCtx.translate(w / 2, h / 2);
      orCtx.scale(this.EYE_SCALE, this.EYE_SCALE);
      orCtx.beginPath();
      orCtx.moveTo(-30, 0);
      orCtx.quadraticCurveTo(-15, -18, 0, -19);
      orCtx.quadraticCurveTo(15, -18, 30, 0);
      orCtx.quadraticCurveTo(15, 18, 0, 19);
      orCtx.quadraticCurveTo(-15, 18, -30, 0);
      orCtx.closePath();
      orCtx.fillStyle = `hsl(${hue}, 100%, 45%)`;
      orCtx.fill();
      this.eyeCache.openRainbow.push(openRainbow);
      
      // Closed rainbow (array of 11 darkness levels per hue)
      const closedForHue = [];
      for (let i = 0; i <= 10; i++) {
        const closedRainbow = document.createElement('canvas');
        closedRainbow.width = w;
        closedRainbow.height = h;
        const crCtx = closedRainbow.getContext('2d');
        crCtx.translate(w / 2, h / 2);
        crCtx.scale(this.EYE_SCALE, this.EYE_SCALE);
        crCtx.beginPath();
        crCtx.moveTo(-30, 0);
        crCtx.quadraticCurveTo(-15, -18, 0, -19);
        crCtx.quadraticCurveTo(15, -18, 30, 0);
        crCtx.quadraticCurveTo(15, 18, 0, 19);
        crCtx.quadraticCurveTo(-15, 18, -30, 0);
        crCtx.closePath();
        const lightness = 45 - (i / 10) * 20;
        crCtx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
        crCtx.fill();
        closedForHue.push(closedRainbow);
      }
      this.eyeCache.closedRainbow.push(closedForHue);
    }
  },
  
  resizeCanvas() {
    // No-op: Canvas is fixed size (1920x1080) and scaled via CSS/AppScaler
  },
  
  createEyeGrid() {
    this.eyes.length = 0;
    
    const horizontalSpacing = this.EYE_WIDTH * 0.88;
    const verticalSpacing = this.EYE_HEIGHT * 0.68;
    
    const cols = Math.ceil(this.canvas.width / horizontalSpacing) + 1;
    const rows = Math.ceil(this.canvas.height / verticalSpacing) + 1;
    
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const offsetX = (row % 2 === 0) ? 0 : horizontalSpacing / 2;
        const x = col * horizontalSpacing - offsetX;
        const y = row * verticalSpacing;
        
        this.eyes.push({
          x: x + this.EYE_WIDTH / 2,
          y: y + this.EYE_HEIGHT / 2,
          blinkState: 0,
          blinkProgress: 0,
          permanentlyClosed: false,
          closeProgress: 1,
          hoverClosed: false,
          hoverCloseProgress: 0,
          hoverBlinkState: 0,
          hoverBlinkProgress: 0
        });
      }
    }
    
    console.log(`üëÅÔ∏è Created eye grid: ${cols}√ó${rows} = ${this.eyes.length} eyes (canvas: ${this.canvas.width}√ó${this.canvas.height})`);
  },
  
  setupEventListeners() {
    // Mouse tracking - direct screen coords since canvas is fixed to viewport
    document.addEventListener('mousemove', (e) => {
      if (this.isActive) {
        const container = Utils.getElement('container');
        const rect = container.getBoundingClientRect();
        const scale = rect.width / CONFIG.LAYOUT.DESIGN_WIDTH;
        this.mouseX = (e.clientX - rect.left) / scale;
        this.mouseY = (e.clientY - rect.top) / scale;
      }
    });
    
    // Click wave effect
    document.addEventListener('click', (e) => {
      if (!this.isActive) return;
      
      const container = Utils.getElement('container');
      const rect = container.getBoundingClientRect();
      const scale = rect.width / CONFIG.LAYOUT.DESIGN_WIDTH;
      const clickX = (e.clientX - rect.left) / scale;
      const clickY = (e.clientY - rect.top) / scale;
      
      const maxDistance = Math.sqrt(this.canvas.width ** 2 + this.canvas.height ** 2);
      const TOTAL_WAVE_TIME = 1200;
      
      this.eyes.forEach(eye => {
        if (eye.permanentlyClosed) return;
        
        const dx = eye.x - clickX;
        const dy = eye.y - clickY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const delay = (distance / maxDistance) * TOTAL_WAVE_TIME + Math.random() * 60;
        
        setTimeout(() => {
          if (eye.blinkState === 0 && !eye.permanentlyClosed) {
            eye.blinkState = 1;
            eye.blinkProgress = 0;
          }
        }, delay);
      });
    });
    

    this.createEasterEggInput();
    document.addEventListener('keydown', (e) => {
      if (!this.isActive) return;
      
      if (e.key === 'Enter') {
        const now = Date.now();
        if (now - this.lastEnterTime < 300) {
          // Double-tap detected - show/focus input
          this.easterEggInput.style.opacity = '1';
          this.easterEggInput.focus();
          this.easterEggBuffer = '';
          this.easterEggInput.value = '';
        }
        this.lastEnterTime = now;
      }
    });
  },
  
  createEasterEggInput() {
    const input = document.createElement('input');
    input.type = 'text';
    input.id = 'easterEggInput';
    input.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      font-size: 18px;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #666;
      border-radius: 8px;
      color: #fff;
      outline: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 9999;
      text-transform: uppercase;
    `;
    
    // Simple hash function to hide secret words
    const hashCode = (s) => {
      let h = 0;
      for (let i = 0; i < s.length; i++) h = ((h << 5) - h) + s.charCodeAt(i) | 0;
      return h;
    };
    
    input.addEventListener('input', (e) => {
      this.easterEggBuffer = e.target.value.toUpperCase();
      const h = hashCode(this.easterEggBuffer);
      
      if (h === 2022740) { // secret activate code
        this.rainbowMode = true;
        input.style.borderColor = 'hsl(' + this.rainbowHue + ', 100%, 50%)';
        input.style.boxShadow = '0 0 20px hsl(' + this.rainbowHue + ', 100%, 50%)';
      } else if (h === 76517) { // secret deactivate code
        this.rainbowMode = false;
        input.style.borderColor = '#666';
        input.style.boxShadow = 'none';
      }
    });
    
    input.addEventListener('blur', () => {
      input.style.opacity = '0';
    });
    
    document.body.appendChild(input);
    this.easterEggInput = input;
  },
  
  setupHoverPatterns() {
    const self = this;
    
    const elements = document.querySelectorAll('#contactsPage [data-hover-pattern]');
    console.log(`üîç setupHoverPatterns: Found ${elements.length} pattern elements`);
    
    elements.forEach(element => {
      const patternName = element.getAttribute('data-hover-pattern');
      const pattern = self.hoverPatterns[patternName];
      
      console.log(`üìã Pattern ${patternName}: ${pattern ? pattern.length + ' eyes' : 'NOT FOUND'}`);
      
      if (!pattern) return;
      
      element.addEventListener('mouseenter', () => {
        console.log(`üñ±Ô∏è mouseenter: ${patternName}, isActive=${self.isActive}, eyes.length=${self.eyes.length}`);
        if (!self.isActive) return;
        
        // Clear old pattern
        if (self.activeHoverPattern && self.activeHoverPattern !== patternName) {
          const oldPattern = self.hoverPatterns[self.activeHoverPattern];
          if (oldPattern) {
            oldPattern.forEach(idx => self.resetEyeHoverState(idx));
          }
        }
        
        self.activeHoverPattern = patternName;
        
        pattern.forEach(eyeIndex => {
          if (self.eyes[eyeIndex]) {
            self.eyes[eyeIndex].hoverBlinkState = 0;
            self.eyes[eyeIndex].hoverBlinkProgress = 0;
            self.eyes[eyeIndex].hoverCloseProgress = 0;
            self.eyes[eyeIndex].hoverClosed = true;
          }
        });
      });
      
      element.addEventListener('mouseleave', () => {
        if (self.activeHoverPattern === patternName) {
          self.activeHoverPattern = null;
          pattern.forEach(idx => self.resetEyeHoverState(idx));
        }
      });
    });
  },
  
  resetEyeHoverState(eyeIndex) {
    if (this.eyes[eyeIndex]) {
      this.eyes[eyeIndex].hoverClosed = false;
      this.eyes[eyeIndex].hoverBlinkState = 0;
      this.eyes[eyeIndex].hoverBlinkProgress = 0;
      this.eyes[eyeIndex].hoverCloseProgress = 0;
    }
  },
  
  setupTextCarousel() {
    // Split text into characters for carousel effect
    document.querySelectorAll('#contactsPage .body-line .value').forEach(valueElement => {
      const text = valueElement.textContent;
      valueElement.innerHTML = '';
      
      for (let char of text) {
        const charWrapper = document.createElement('span');
        charWrapper.className = 'char';
        
        const charInner = document.createElement('span');
        charInner.className = 'char-inner';
        charInner.textContent = char;
        charInner.setAttribute('data-char', char);
        
        charWrapper.appendChild(charInner);
        valueElement.appendChild(charWrapper);
      }
    });
    
    // Add hover listeners to trigger animation
    document.querySelectorAll('#contactsPage .body-line').forEach(line => {
      line.addEventListener('mouseenter', function() {
        this.classList.add('animating');
        const totalAnimationTime = 1750;
        
        setTimeout(() => {
          this.classList.remove('animating');
          void this.offsetWidth;
        }, totalAnimationTime);
      });
    });
  },
  
  easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
  },
  
  drawEye(eye, eyeIndex) {
    const { x, y, blinkProgress, permanentlyClosed, closeProgress, hoverClosed, hoverCloseProgress, hoverBlinkState, hoverBlinkProgress } = eye;
    
    const imgW = this.eyeCache.open.width;
    const imgH = this.eyeCache.open.height;
    
    // Calculate hover blink scale
    let hoverBlinkScale = 1;
    let isInBlinkSequence = hoverBlinkState >= 1 && hoverBlinkState <= 4;
    
    if (hoverBlinkState === 1 || hoverBlinkState === 3) {
      hoverBlinkScale = 1 - hoverBlinkProgress * 0.92;
    } else if (hoverBlinkState === 2 || hoverBlinkState === 4) {
      hoverBlinkScale = 0.08 + hoverBlinkProgress * 0.92;
    }
    
    const effectiveCloseProgress = Math.max(closeProgress > 0 ? closeProgress : 0, hoverCloseProgress || 0);
    const isClosed = permanentlyClosed || effectiveCloseProgress > 0 || hoverBlinkState > 0;
    
    // Determine if we should show red flash (during any blink animation)
    let redFlashIntensity = 0;
    if (blinkProgress > 0) {
      // Regular blink / wave blink - peak red at middle of blink
      if (blinkProgress < 0.5) {
        redFlashIntensity = blinkProgress * 2; // 0 -> 1
      } else {
        redFlashIntensity = (1 - blinkProgress) * 2; // 1 -> 0
      }
    }
    if (isInBlinkSequence) {
      // Hover blink sequence - flash red during closing phases
      if (hoverBlinkState === 1 || hoverBlinkState === 3) {
        redFlashIntensity = Math.max(redFlashIntensity, hoverBlinkProgress);
      } else if (hoverBlinkState === 2 || hoverBlinkState === 4) {
        redFlashIntensity = Math.max(redFlashIntensity, 1 - hoverBlinkProgress);
      }
    }
    
    if (isClosed) {
      let scaleY;
      if (isInBlinkSequence) {
        scaleY = hoverBlinkScale;
      } else {
        scaleY = 1 - (effectiveCloseProgress * 0.95);
      }
      if (scaleY < 0.05) scaleY = 0.05;
      
      let darkProgress = effectiveCloseProgress;
      if (isInBlinkSequence) {
        if (hoverBlinkState === 1 || hoverBlinkState === 3) {
          darkProgress = hoverBlinkProgress;
        } else {
          darkProgress = 1 - hoverBlinkProgress;
        }
      }
      const darkIndex = Math.min(10, Math.floor(darkProgress * 10));
      const sprite = this.eyeCache.closed[darkIndex];
      
      this.ctx.save();
      this.ctx.translate(x, y);
      this.ctx.scale(1, scaleY);
      
      // Crossfade between gray and colored sprite
      if (redFlashIntensity > 0) {
        // Each eye gets its own hue based on position for rainbow gradient effect
        const eyeHueOffset = (x / this.canvas.width + y / this.canvas.height) * 180;
        const hueIndex = Math.floor(((this.rainbowHue + eyeHueOffset) % 360 / 360) * 12) % 12;
        const colorSprite = this.rainbowMode 
          ? this.eyeCache.closedRainbow[hueIndex][darkIndex]
          : this.eyeCache.closedRed[darkIndex];
        this.ctx.globalAlpha = 1 - redFlashIntensity;
        this.ctx.drawImage(sprite, -imgW / 2, -imgH / 2);
        this.ctx.globalAlpha = redFlashIntensity;
        this.ctx.drawImage(colorSprite, -imgW / 2, -imgH / 2);
        this.ctx.globalAlpha = 1;
      } else {
        this.ctx.drawImage(sprite, -imgW / 2, -imgH / 2);
      }
      
      this.ctx.restore();
      
      if (scaleY > 0.3) {
        const dx = this.mouseX - x;
        const dy = this.mouseY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        const MAX_MOVE_X = 20 * this.EYE_SCALE;
        const MAX_MOVE_Y = 10 * this.EYE_SCALE;
        const moveX = Math.cos(angle) * Math.min(distance / 8, MAX_MOVE_X);
        const moveY = Math.sin(angle) * Math.min(distance / 8, MAX_MOVE_Y);
        
        this.ctx.beginPath();
        this.ctx.arc(x + moveX, y + moveY, 14 * this.EYE_SCALE, 0, Math.PI * 2);
        this.ctx.fillStyle = '#000000';
        this.ctx.fill();
        
        this.ctx.beginPath();
        this.ctx.arc(x + moveX - 3 * this.EYE_SCALE, y + moveY - 3 * this.EYE_SCALE, 3 * this.EYE_SCALE, 0, Math.PI * 2);
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        this.ctx.fill();
      }
      return;
    }
    
    // Calculate blink scale
    let scaleY = 1;
    if (blinkProgress > 0) {
      if (blinkProgress < 0.35) {
        const t = blinkProgress / 0.35;
        const eased = this.easeInOutCubic(t);
        scaleY = 1 - eased * 0.92;
      } else if (blinkProgress < 0.5) {
        scaleY = 0.08;
      } else if (blinkProgress < 0.85) {
        const t = (blinkProgress - 0.5) / 0.35;
        const eased = this.easeInOutCubic(t);
        scaleY = 0.08 + eased * 0.92;
      } else {
        const t = (blinkProgress - 0.85) / 0.15;
        scaleY = 1 - (1 - t) * 0.02;
      }
    }
    
    this.ctx.save();
    this.ctx.translate(x, y);
    this.ctx.scale(1, scaleY);
    
    // Crossfade between gray and colored sprite
    if (redFlashIntensity > 0) {
      // Each eye gets its own hue based on position for rainbow gradient effect
      const eyeHueOffset = (x / this.canvas.width + y / this.canvas.height) * 180;
      const hueIndex = Math.floor(((this.rainbowHue + eyeHueOffset) % 360 / 360) * 12) % 12;
      const colorSprite = this.rainbowMode 
        ? this.eyeCache.openRainbow[hueIndex]
        : this.eyeCache.openRed;
      this.ctx.globalAlpha = 1 - redFlashIntensity;
      this.ctx.drawImage(this.eyeCache.open, -imgW / 2, -imgH / 2);
      this.ctx.globalAlpha = redFlashIntensity;
      this.ctx.drawImage(colorSprite, -imgW / 2, -imgH / 2);
      this.ctx.globalAlpha = 1;
    } else {
      this.ctx.drawImage(this.eyeCache.open, -imgW / 2, -imgH / 2);
    }
    
    this.ctx.restore();
    
    // Calculate pupil position
    const dx = this.mouseX - x;
    const dy = this.mouseY - y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    
    const MAX_MOVE_X = 20 * this.EYE_SCALE;
    const MAX_MOVE_Y = 10 * this.EYE_SCALE;
    
    const moveX = Math.cos(angle) * Math.min(distance / 8, MAX_MOVE_X);
    const moveY = Math.sin(angle) * Math.min(distance / 8, MAX_MOVE_Y);
    
    if (scaleY > 0.3) {
      this.ctx.beginPath();
      this.ctx.arc(x + moveX, y + moveY, 14 * this.EYE_SCALE, 0, Math.PI * 2);
      this.ctx.fillStyle = '#000000';
      this.ctx.fill();
      
      this.ctx.beginPath();
      this.ctx.arc(x + moveX - 3 * this.EYE_SCALE, y + moveY - 3 * this.EYE_SCALE, 3 * this.EYE_SCALE, 0, Math.PI * 2);
      this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      this.ctx.fill();
    }
  },
  
  animate(currentTime) {
    if (!this.isActive) return;
    
    const deltaTime = currentTime - this.lastTime;
    this.lastTime = currentTime;
    
    // Update rainbow hue for easter egg
    if (this.rainbowMode) {
      this.rainbowHue = (this.rainbowHue + deltaTime * 0.2) % 360;
      // Update input glow color
      if (this.easterEggInput) {
        this.easterEggInput.style.borderColor = `hsl(${this.rainbowHue}, 100%, 50%)`;
        this.easterEggInput.style.boxShadow = `0 0 20px hsl(${this.rainbowHue}, 100%, 50%)`;
      }
    }
    
    // Trigger random blinks
    if (currentTime - this.lastRandomBlink > Math.random() * 4000 + 1000) {
      const numBlinks = Math.floor(Math.random() * 3) + 2;
      for (let i = 0; i < numBlinks; i++) {
        const randomEye = this.eyes[Math.floor(Math.random() * this.eyes.length)];
        if (randomEye && randomEye.blinkState === 0 && !randomEye.permanentlyClosed) {
          randomEye.blinkState = 1;
          randomEye.blinkProgress = 0;
        }
      }
      this.lastRandomBlink = currentTime;
    }
    
    // Clear canvas
    this.ctx.fillStyle = '#000000';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Update and draw all eyes
    this.eyes.forEach((eye, index) => {
      // Update blink animation
      if (eye.blinkState !== 0 && !eye.permanentlyClosed) {
        eye.blinkProgress += deltaTime / 350;
        if (eye.blinkProgress >= 1) {
          eye.blinkState = 0;
          eye.blinkProgress = 0;
        }
      }
      
      // Animate permanent close
      if (eye.permanentlyClosed && eye.closeProgress < 1) {
        eye.closeProgress += deltaTime / 300;
        if (eye.closeProgress > 1) eye.closeProgress = 1;
      } else if (!eye.permanentlyClosed && eye.closeProgress > 0) {
        eye.closeProgress -= deltaTime / 300;
        if (eye.closeProgress < 0) eye.closeProgress = 0;
      }
      
      // Animate hover blink sequence
      if (eye.hoverClosed) {
        switch (eye.hoverBlinkState) {
          case 0:
            eye.hoverBlinkState = 1;
            eye.hoverBlinkProgress = 0;
            break;
          case 1:
            eye.hoverBlinkProgress += deltaTime / 60;
            if (eye.hoverBlinkProgress >= 1) {
              eye.hoverBlinkState = 2;
              eye.hoverBlinkProgress = 0;
            }
            break;
          case 2:
            eye.hoverBlinkProgress += deltaTime / 60;
            if (eye.hoverBlinkProgress >= 1) {
              eye.hoverBlinkState = 3;
              eye.hoverBlinkProgress = 0;
            }
            break;
          case 3:
            eye.hoverBlinkProgress += deltaTime / 60;
            if (eye.hoverBlinkProgress >= 1) {
              eye.hoverBlinkState = 4;
              eye.hoverBlinkProgress = 0;
            }
            break;
          case 4:
            eye.hoverBlinkProgress += deltaTime / 60;
            if (eye.hoverBlinkProgress >= 1) {
              eye.hoverBlinkState = 5;
              eye.hoverBlinkProgress = 0;
            }
            break;
          case 5:
            eye.hoverCloseProgress += deltaTime / 150;
            if (eye.hoverCloseProgress >= 1) {
              eye.hoverCloseProgress = 1;
              eye.hoverBlinkState = 6;
            }
            break;
          case 6:
            break;
        }
      } else {
        if (eye.hoverBlinkState !== 0 || eye.hoverCloseProgress > 0) {
          eye.hoverCloseProgress -= deltaTime / 200;
          if (eye.hoverCloseProgress <= 0) {
            eye.hoverCloseProgress = 0;
            eye.hoverBlinkState = 0;
            eye.hoverBlinkProgress = 0;
          }
        }
      }
      
      this.drawEye(eye, index);
    });
    
    this.animationId = requestAnimationFrame((t) => this.animate(t));
  },
  
  start() {
    if (this.isActive) return;
    
    console.log('‚ñ∂Ô∏è ContactsEyeSystem starting...');
    this.isActive = true;
    this.mouseX = CONFIG.LAYOUT.DESIGN_WIDTH / 2;
    this.mouseY = CONFIG.LAYOUT.DESIGN_HEIGHT / 2;
    this.lastTime = performance.now();
    this.lastRandomBlink = 0;
    this.activeHoverPattern = null;
    
    // Reset all eyes
    this.eyes.forEach(eye => {
      eye.blinkState = 0;
      eye.blinkProgress = 0;
      eye.hoverClosed = false;
      eye.hoverCloseProgress = 0;
      eye.hoverBlinkState = 0;
      eye.hoverBlinkProgress = 0;
    });
    
    this.animationId = requestAnimationFrame((t) => this.animate(t));
    console.log('‚úÖ ContactsEyeSystem started');
  },
  
  stop() {
    if (!this.isActive) return;
    
    console.log('‚èπÔ∏è ContactsEyeSystem stopping...');
    this.isActive = false;
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    this.activeHoverPattern = null;
    console.log('‚úÖ ContactsEyeSystem stopped');
  }
};

/* ========================================================================
   LOADING SCREEN COMET ANIMATION
   ======================================================================== */
const LoadingCometAnimation = {
  // üéÆ CONFIGURATION
  ANIMATION_SPEED: 200,
  COMET_LENGTH: 200,
  COMET_SPACING: 600,
  GRADIENT_LAYERS: 8,
  STROKE_THICKNESS: 1,
  TIP_COLOR: '#FF000D',
  TAIL_COLOR: '#000000',
  TIP_OPACITY: 1,
  TAIL_OPACITY: 1,
  RANDOM_START: true,
  COMETS_PER_PATH: 1,

  allAnimatedPaths: [],
  lastTime: performance.now(),
  animationFrame: null,

  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  },

  interpolateColor(color1, color2, factor) {
    const c1 = this.hexToRgb(color1);
    const c2 = this.hexToRgb(color2);
    const r = Math.round(c1.r + factor * (c2.r - c1.r));
    const g = Math.round(c1.g + factor * (c2.g - c1.g));
    const b = Math.round(c1.b + factor * (c2.b - c1.b));
    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
  },

  generateGradient() {
    const colors = [];
    for (let i = 0; i < this.GRADIENT_LAYERS; i++) {
      const factor = i / (this.GRADIENT_LAYERS - 1);
      colors.push(this.interpolateColor(this.TIP_COLOR, this.TAIL_COLOR, factor));
    }
    return colors;
  },

  init() {
    const svg = document.getElementById("loadingSvg");
    const originalGroup = document.getElementById("loading-original-paths");
    const originalPaths = originalGroup.querySelectorAll("path, line, polyline, polygon");

    if (originalPaths.length === 0) {
      console.log('‚ö†Ô∏è No SVG paths found for loading animation');
      return;
    }

    const gradientColors = this.generateGradient();

    originalPaths.forEach((originalPath) => {
      const pathD = originalPath.getAttribute('d');
      const strokeWidth = parseFloat(originalPath.getAttribute('stroke-width')) || this.STROKE_THICKNESS;

      for (let cometIndex = 0; cometIndex < this.COMETS_PER_PATH; cometIndex++) {
        const layerGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svg.appendChild(layerGroup);

        const patternLength = this.COMET_LENGTH + this.COMET_SPACING;
        let baseOffset;

        if (this.RANDOM_START) {
          baseOffset = Math.random() * patternLength;
        } else {
          baseOffset = (cometIndex / this.COMETS_PER_PATH) * patternLength;
        }

        for (let layer = this.GRADIENT_LAYERS - 1; layer >= 0; layer--) {
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          path.setAttribute('d', pathD);
          path.setAttribute('stroke', gradientColors[layer]);
          path.setAttribute('stroke-width', strokeWidth);
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke-linecap', 'round');
          path.setAttribute('stroke-linejoin', 'round');

          const opacityFactor = layer / (this.GRADIENT_LAYERS - 1);
          const opacity = this.TIP_OPACITY + (this.TAIL_OPACITY - this.TIP_OPACITY) * opacityFactor;
          path.setAttribute('opacity', opacity);

          path.style.strokeDasharray = `${this.COMET_LENGTH} ${this.COMET_SPACING}`;

          const layerOffset = (layer / this.GRADIENT_LAYERS) * this.COMET_LENGTH;

          path.dataset.patternLength = patternLength;
          path.dataset.offset = baseOffset;
          path.dataset.layerOffset = layerOffset;
          path.style.strokeDashoffset = baseOffset + layerOffset;

          layerGroup.appendChild(path);
          this.allAnimatedPaths.push(path);
        }
      }
    });

    originalGroup.style.display = 'none';
    this.animate();

    console.log(`‚ú® Loading comet animation initialized: ${originalPaths.length} paths, ${this.allAnimatedPaths.length} total elements`);
  },

  animate() {
    const now = performance.now();
    const delta = (now - this.lastTime) / 1000;
    this.lastTime = now;

    this.allAnimatedPaths.forEach(path => {
      let offset = parseFloat(path.dataset.offset);
      const patternLength = parseFloat(path.dataset.patternLength);
      const layerOffset = parseFloat(path.dataset.layerOffset);

      offset -= this.ANIMATION_SPEED * delta;
      offset %= patternLength;

      path.dataset.offset = offset;
      path.style.strokeDashoffset = offset + layerOffset;
    });

    this.animationFrame = requestAnimationFrame(() => this.animate());
  },

  stop() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
  }
};

/* ========================================================================
   INIT
   ======================================================================== */
document.addEventListener('DOMContentLoaded', () => {
  DeviceDetector.init();
  AppScaler.init();
  LoadingCometAnimation.init();
  Preloader.init();
  IconPositioner.init();

  // Create sprite sheet icons with SIMPLIFIED SPEEDS
  window.iconInstances = {};
  const iconIds = ['art', 'contacts', 'edu', 'work'];
  
  iconIds.forEach(id => {
    try {
      const el = Utils.getElement(`icon-${id}`);
      if (!el) {
        console.error(`\u274c Icon element not found: icon-${id}`);
        return;
      }
      console.log(`‚úÖ Found icon-${id}:`, el);
      
      // Create icon instance based on ID
      if (id === 'art') {
        window.iconInstances.art = new SpriteSheetIcon(el, 48, 180, 169, 8640, 18, { forwardSpeed: 0.1, reverseSpeed: 0.3 });
      } else if (id === 'contacts') {
        window.iconInstances.contacts = new SpriteSheetIcon(el, 30, 180, 203, 5400, 17, { forwardSpeed: 0.03, reverseSpeed: 0.3 });
      } else if (id === 'edu') {
        window.iconInstances.edu = new SpriteSheetIcon(el, 73, 180, 105, 13136, 45, { forwardSpeed: 0.035, reverseSpeed: 0.5 });
      } else if (id === 'work') {
        window.iconInstances.work = new SpriteSheetIcon(el, 29, 180, 226, 5220, null, { loopSpeed: 0.2, reverseSpeed: 0.3 });
      }
      console.log(`\u2714\ufe0f Icon ${id} created successfully`);
    } catch (e) {
      console.error(`\u274c Error creating icon ${id}:`, e);
    }
  });

  console.log('‚úÖ All icon instances created:', window.iconInstances);

  TransitionManager.init();
  EyeSystem.init();
  ContactsEyeSystem.init();
  
  
  Utils.log('‚úÖ Application initialized with sprite sheets!');
});
</script>
</body>
</html>
